ca65 V2.18 - Git 39c0abed5
Main file   : main.asm
Current file: main.asm

000000r 1               ;
000000r 1               ; Adria main glue file
000000r 1               ;
000000r 1               ; Version history:
000000r 1               ;	05 Jan 2021	- Initial version
000000r 1               ;	16 jan 2021	- Added comment about use of WDC65C51 with known bug for
000000r 1               ;			  Rx status bit stuck
000000r 1               ;	18 feb 2021	- In SPRINT we now save the 16 bit .Y to the
000000r 1               ;			  stack, before actually printing char. When
000000r 1               ;			  returned, we reset the register widths and
000000r 1               ;			  retrieve the .Y
000000r 1               ;
000000r 1               ;
000000r 1               ; BEFORE USAGE, SET THE CORRECT OSCILLATOR CLOCK SPEED IN "global.asm"
000000r 1               ;=======================================================================
000000r 1               ; Assembler target selection
000000r 1               	.p816				; Build for 65816 CPU
000000r 1               
000000r 1               	.listbytes	unlimited	; Show all bytes (on Linux/macOS)
000000r 1               ;	.listbytes	255		; Show max 255 bytes on Windows
000000r 1               	.smart		+		; Let the assembler act smart
000000r 1               
000000r 1               	.a8				; But for now, start in 8-bit
000000r 1               	.i8
000000r 1               	.debuginfo			; Generate label information
000000r 1               
000000r 1               ;=======================================================================
000000r 1               ; Assembler/linker directives
000000r 1               ;=======================================================================
000000r 1               ; Data segment - Not here (yet)
000000r 1               ;---------------------------------------
000000r 1               	.data
000000r 1               
000000r 1               ;---------------------------------------
000000r 1               ; Code segment
000000r 1               ;---------------------------------------
000000r 1               	.code
000000r 1               	.org	$C000			; The ROM starts at $00/C000
00C000  1               
00C000  1               ;---------------------------------------
00C000  1               ; Include global equations, macros, etc
00C000  1               ;---------------------------------------
00C000  1               	.include	"config/global.asm"
00C000  2               ;
00C000  2               ; Adria global equations, macros, etc
00C000  2               ;
00C000  2               ; Version history:
00C000  2               ;	05 Jan 2021	- Initial version
00C000  2               ;	08 feb 2021	- Some minor changes to interrupt handlers
00C000  2               ;	25 feb 2021	- Consolidate ZP usage (try to make it one block)
00C000  2               ;=======================================================================
00C000  2               ; Assembly related variables (for conditional assembly)
00C000  2               ;---------------------------------------
00C000  2               OSCCLK		=	4		; Clock speed of main oscillator
00C000  2               SYSCLK		=	OSCCLK / 4	; Clock speed of PHI2
00C000  2               
00C000  2               ;---------------------------------------
00C000  2               ; Macros
00C000  2               ;---------------------------------------
00C000  2               	.macro	bios_version
00C000  2               	.byte	'0'			; Major
00C000  2               	.byte	'.'
00C000  2               	.byte	'1'			; Minor
00C000  2               	.byte	'.'
00C000  2               	.byte	'3'			; Revision
00C000  2               	.endmacro
00C000  2               
00C000  2               	.macro	longi			; Set .X and .Y to 16-bit
00C000  2               	rep	#%00010000
00C000  2               	.i16
00C000  2               	.endmacro
00C000  2               
00C000  2               	.macro	shorti			; Set .X and .Y to 8-bit
00C000  2               	sep	#%00010000
00C000  2               	.i8
00C000  2               	.endmacro
00C000  2               
00C000  2               	.macro	longa			; Set .A to 16-bit
00C000  2               	rep	#%00100000
00C000  2               	.a16
00C000  2               	.endmacro
00C000  2               
00C000  2               	.macro	shorta			; Set .A to 8-bit
00C000  2               	sep	#%00100000
00C000  2               	.a8
00C000  2               	.endmacro
00C000  2               
00C000  2               	.macro	longr			; Set all registers to 16-bit
00C000  2               	rep	#%00110000		; Set 16-bit .A, .X and .Y
00C000  2               	.a16
00C000  2               	.i16
00C000  2               	.endmacro
00C000  2               
00C000  2               	.macro	shortr			; Set all registers to 8-bit
00C000  2               	sep	#%00110000		; Set 8-bit .A, .X and .Y
00C000  2               	.a8
00C000  2               	.i8
00C000  2               	.endmacro
00C000  2               
00C000  2               ;---------------------------------------
00C000  2               ; Constants
00C000  2               ;---------------------------------------
00C000  2               _constants:
00C000  2               BELL		= $07			; <Bell>	/ <Ctrl-G>
00C000  2               BS		= $08			; <Backspace> 	/ <Ctrl-H>
00C000  2               HT		= $09			; <Tab>		/ <Ctrl-I>
00C000  2               LF		= $0A			; <LF>
00C000  2               CR		= $0D			; <CR>
00C000  2               ESC		= $1B			; <Esc>
00C000  2               SPACE		= $20			; <Space>
00C000  2               DEL		= $7f			; <Del>
00C000  2               
00C000  2               a_asclcl	= 'a'			; Start of lowercase ASCII
00C000  2               a_asclch	= 'z'			; End of lowercase ASCII
00C000  2               a_lctouc	= $5F			; Lower to Upper conversion mask
00C000  2               
00C000  2               PROMPT		= '#'			; Our monitor prompt
00C000  2               
00C000  2               ;---------------------------------------
00C000  2               ; Data type sizes
00C000  2               ;---------------------------------------
00C000  2               _data_sizes:
00C000  2               s_bi_nibble	= 4			; Nibble		(4 bits)
00C000  2               s_bi_byte	= 8			; Byte			(8 bits)
00C000  2               ;
00C000  2               ;s_byte		= 1			; Byte 			(8 bits)
00C000  2               ;s_word		= 2			; Word 			(16 bits)
00C000  2               ;s_xword	= 3			; Extended word 	(24 bits)
00C000  2               ;s_dword	= 4			; Double word		(32 bits
00C000  2               ;s_rampage	= $0100			; 65xx RAM page size	(256 bytes)
00C000  2               
00C000  2               ; Registers
00C000  2               ;s_dbr		= s_byte		; Data Bank Register size
00C000  2               ;s_dp		= s_word		; Direct Page size
00C000  2               ;s_pbr		= s_byte		; Program Bank Register size
00C000  2               ;s_pc		= s_word		; Program Counter size
00C000  2               ;s_sp		= s_word		; Stack Pointer size
00C000  2               ;s_sr		= s_byte		; Status/Processor Register size
00C000  2               
00C000  2               ; Misc
00C000  2               ;s_address	= s_xword		; 24-bit address
00C000  2               
00C000  2               ;---------------------------------------
00C000  2               ; Status register flags
00C000  2               ;---------------------------------------
00C000  2               ;sr_carry	= %00000001		; Carry
00C000  2               ;sr_zero		= sr_carry 	<< 1	; Zero
00C000  2               ;sr_irq		= sr_zero	<< 1	; IRQ
00C000  2               ;sr_dbm		= sr_irq   	<< 1	; Decimal mode
00C000  2               ;sr_ixw		= sr_dbm	<< 1	; Index width (native)
00C000  2                     					;	0 - 16 bit .X and .Y
00C000  2                      					;	1 -  8 bit .X and .Y
00C000  2                      					; Break (emulation)
00C000  2               ;sr_amw		= sr_ixw   	<< 1	; Memory, .A width (native)
00C000  2                      					;	0 - 16 bit .A
00C000  2                      					;	1 -  8 bit .A
00C000  2               ;sr_ovl		= sr_amw   	<< 1	; Overflow
00C000  2               ;sr_neg		= sr_ovl   	<< 1	; Negative
00C000  2               
00C000  2               ;---------------------------------------
00C000  2               ; Systemwide equations
00C000  2               ;---------------------------------------
00C000  2               _equations:
00C000  2               zero_page	= $80			; We use ZP/DP $80-$FF for monitor
00C000  2               kbdbuffer	= $0200			; We want to create a 127 byte buffer?
00C000  2               stack		= $0100			; Default stack in native mode
00C000  2               
00C000  2               ;---------------------------------------
00C000  2               ; Zero Page/Direct Page usage
00C000  2               ;---------------------------------------
00C000  2               ;_zp_usage:
00C000  2               ;registers
00C000  2               ;reg_pbr		= zero_page		; $80 - .PBR     - Program Bank Register
00C000  2               ;reg_pc		= reg_pbr  + s_pbr	; $81 - .PC      - Program Counter
00C000  2               ;reg_sr		= reg_pc   + s_pc	; $83 - .SR      - Status/Processor
00C000  2               ;       					;		   Register
00C000  2               ;reg_a		= reg_sr   + s_sr	; $84 - .C       - 16 bit Accumulator
00C000  2               ;       					;	- .B MSB
00C000  2               ;       					;	- .A LSB - 8 bit Accumulator
00C000  2               ;reg_x		= reg_a    + s_word	; $86 - .X       - 16 bit X register
00C000  2               ;reg_y		= reg_x    + s_word	; $88 - .Y       - 16 bit Y register
00C000  2               ;reg_sp		= reg_y    + s_word	; $8A - .SP      - Stack Pointer
00C000  2               ;reg_dp		= reg_sp   + s_sp	; $8C - .DP      - Direct Page
00C000  2               ;reg_dbr		= reg_dp   + s_dp	; $8e - .DBR     - Data Bank Register
00C000  2               ;
00C000  2               ;General Workspace
00C000  2               ;addr_a		= reg_dbr  + s_dbr	; $8f - Address #1 placeholder
00C000  2               ;addr_b		= addr_a   + s_address	; $92 - Address #2 placeholder
00C000  2               ;kbdbuffer_ptr	= addr_b   + s_address	; $95 - Keyboard buffer index pointer
00C000  2               ;sysbrqvector	= kbdbuffer_ptr + s_word; $98 - Original (system) BRQ vector
00C000  2               
00C000  2               ;---------------------------------------
00C000  2               ; Vector location(s)
00C000  2               ;---------------------------------------
00C000  2               _vectors:
00C000  2               
00C000  2               ;---------------------------------------
00C000  2               ; Reset vector location(s)
00C000  2               ;---------------------------------------
00C000  2               _reset_vectors:				; All vectors should have a
00C000  2               VECTOR_RES	=	$02D0		;  - 2-byte address
00C000  2               CHKSUM_RES	=	$02D2		;  - 2-byte checksum
00C000  2               
00C000  2               VECTOR_NMI	=	$02D4
00C000  2               CHKSUM_NMI	=	$02D6
00C000  2               
00C000  2               VECTOR_INT	=	$02D8
00C000  2               CHKSUM_INT	=	$02DA
00C000  2               
00C000  2               VECTOR_BRK	=	$02DC
00C000  2               CHKSUM_BRK	=	$02DE
00C000  2               ;---------------------------------------
00C000  2               ; Input/output vector location(s)
00C000  2               ;---------------------------------------
00C000  2               _io_vectors:				; We expect the I/O vectors to
00C000  2               VECTOR_CHAR_OUT	=	$02E0		; be 2 bytes wide, without
00C000  2               VECTOR_CHAR_IN	=	$02E2		; checksum(s)
00C000  2               VECTOR_CHAR_SCAN=	$02E4
00C000  2               
00C000  2               ;---------------------------------------
00C000  2               ; Slot/device assignments
00C000  2               ;---------------------------------------
00C000  2               _io_assignments:
00C000  2               _ACIA:					; ACIA (UART) will be mapped to
00C000  2               UART_IOBASE	=	$C020
00C000  2               ; OLD: TO BE REMOVED
00C000  2               ;ACIA_DATA	=	$C020		; slot #1 (/IOSEL0) at address
00C000  2               ;ACIA_STATUS	=	$C021		; $00/C020..$00/C02F with the help
00C000  2               ;ACIA_CMD	=	$C022		; from the GALs
00C000  2               ;ACIA_CTL	=	$C023
00C000  2               
00C000  2               ;---------------------------------------
00C000  2               ; Device driver entry point(s)
00C000  2               ; ROM routines
00C000  2               ;---------------------------------------
00C000  2               _intel_upload:
00C000  2               HEXINTEL	=	$D000
00C000  2               
00C000  2               _sys_monitor:
00C000  2               SYSMONITOR	=	$D800
00C000  2               
00C000  2               _device_drivers:
00C000  2               UART_DRIVER	=	$CD00
00C000  2               
00C000  2               _isr:
00C000  2               ISR		=	$FC00
00C000  2               
00C000  2               _jumptables:
00C000  2               JUMP		= 	$FCA0
00C000  2               
00C000  2               _ROM_routines:
00C000  2               RESET_ROUTINES	=	$FD00
00C000  2               
00C000  1               
00C000  1               ;###################
00C000  1               ; Fill "empty" space(s)/unused addresses with $00
00C000  1               ;###################
00C000  1               ; Size table header row
00C000  1               ;###################
00C000  1               	.out .concat("                                  Start      End      Size   (Decimal)")
00C000  1               	.out .concat("                                  -----      ----     -----  ---------")
00C000  1               
00C000  1               ; UART driver(s)
00C000  1               ;=======================
00C000  1               ; In order to support multiple UART options (e.g. 6551, NXP SC28L92), replace
00C000  1               ; the included filename for the desired solution.
00C000  1               ;=======================
00C000  1               _incl_uart:
00C000  1  00 00 00 00  	.res		UART_DRIVER - *, $00
00C004  1  00 00 00 00  
00C008  1  00 00 00 00  
00C00C  1  00 00 00 00  
00C010  1  00 00 00 00  
00C014  1  00 00 00 00  
00C018  1  00 00 00 00  
00C01C  1  00 00 00 00  
00C020  1  00 00 00 00  
00C024  1  00 00 00 00  
00C028  1  00 00 00 00  
00C02C  1  00 00 00 00  
00C030  1  00 00 00 00  
00C034  1  00 00 00 00  
00C038  1  00 00 00 00  
00C03C  1  00 00 00 00  
00C040  1  00 00 00 00  
00C044  1  00 00 00 00  
00C048  1  00 00 00 00  
00C04C  1  00 00 00 00  
00C050  1  00 00 00 00  
00C054  1  00 00 00 00  
00C058  1  00 00 00 00  
00C05C  1  00 00 00 00  
00C060  1  00 00 00 00  
00C064  1  00 00 00 00  
00C068  1  00 00 00 00  
00C06C  1  00 00 00 00  
00C070  1  00 00 00 00  
00C074  1  00 00 00 00  
00C078  1  00 00 00 00  
00C07C  1  00 00 00 00  
00C080  1  00 00 00 00  
00C084  1  00 00 00 00  
00C088  1  00 00 00 00  
00C08C  1  00 00 00 00  
00C090  1  00 00 00 00  
00C094  1  00 00 00 00  
00C098  1  00 00 00 00  
00C09C  1  00 00 00 00  
00C0A0  1  00 00 00 00  
00C0A4  1  00 00 00 00  
00C0A8  1  00 00 00 00  
00C0AC  1  00 00 00 00  
00C0B0  1  00 00 00 00  
00C0B4  1  00 00 00 00  
00C0B8  1  00 00 00 00  
00C0BC  1  00 00 00 00  
00C0C0  1  00 00 00 00  
00C0C4  1  00 00 00 00  
00C0C8  1  00 00 00 00  
00C0CC  1  00 00 00 00  
00C0D0  1  00 00 00 00  
00C0D4  1  00 00 00 00  
00C0D8  1  00 00 00 00  
00C0DC  1  00 00 00 00  
00C0E0  1  00 00 00 00  
00C0E4  1  00 00 00 00  
00C0E8  1  00 00 00 00  
00C0EC  1  00 00 00 00  
00C0F0  1  00 00 00 00  
00C0F4  1  00 00 00 00  
00C0F8  1  00 00 00 00  
00C0FC  1  00 00 00 00  
00C100  1  00 00 00 00  
00C104  1  00 00 00 00  
00C108  1  00 00 00 00  
00C10C  1  00 00 00 00  
00C110  1  00 00 00 00  
00C114  1  00 00 00 00  
00C118  1  00 00 00 00  
00C11C  1  00 00 00 00  
00C120  1  00 00 00 00  
00C124  1  00 00 00 00  
00C128  1  00 00 00 00  
00C12C  1  00 00 00 00  
00C130  1  00 00 00 00  
00C134  1  00 00 00 00  
00C138  1  00 00 00 00  
00C13C  1  00 00 00 00  
00C140  1  00 00 00 00  
00C144  1  00 00 00 00  
00C148  1  00 00 00 00  
00C14C  1  00 00 00 00  
00C150  1  00 00 00 00  
00C154  1  00 00 00 00  
00C158  1  00 00 00 00  
00C15C  1  00 00 00 00  
00C160  1  00 00 00 00  
00C164  1  00 00 00 00  
00C168  1  00 00 00 00  
00C16C  1  00 00 00 00  
00C170  1  00 00 00 00  
00C174  1  00 00 00 00  
00C178  1  00 00 00 00  
00C17C  1  00 00 00 00  
00C180  1  00 00 00 00  
00C184  1  00 00 00 00  
00C188  1  00 00 00 00  
00C18C  1  00 00 00 00  
00C190  1  00 00 00 00  
00C194  1  00 00 00 00  
00C198  1  00 00 00 00  
00C19C  1  00 00 00 00  
00C1A0  1  00 00 00 00  
00C1A4  1  00 00 00 00  
00C1A8  1  00 00 00 00  
00C1AC  1  00 00 00 00  
00C1B0  1  00 00 00 00  
00C1B4  1  00 00 00 00  
00C1B8  1  00 00 00 00  
00C1BC  1  00 00 00 00  
00C1C0  1  00 00 00 00  
00C1C4  1  00 00 00 00  
00C1C8  1  00 00 00 00  
00C1CC  1  00 00 00 00  
00C1D0  1  00 00 00 00  
00C1D4  1  00 00 00 00  
00C1D8  1  00 00 00 00  
00C1DC  1  00 00 00 00  
00C1E0  1  00 00 00 00  
00C1E4  1  00 00 00 00  
00C1E8  1  00 00 00 00  
00C1EC  1  00 00 00 00  
00C1F0  1  00 00 00 00  
00C1F4  1  00 00 00 00  
00C1F8  1  00 00 00 00  
00C1FC  1  00 00 00 00  
00C200  1  00 00 00 00  
00C204  1  00 00 00 00  
00C208  1  00 00 00 00  
00C20C  1  00 00 00 00  
00C210  1  00 00 00 00  
00C214  1  00 00 00 00  
00C218  1  00 00 00 00  
00C21C  1  00 00 00 00  
00C220  1  00 00 00 00  
00C224  1  00 00 00 00  
00C228  1  00 00 00 00  
00C22C  1  00 00 00 00  
00C230  1  00 00 00 00  
00C234  1  00 00 00 00  
00C238  1  00 00 00 00  
00C23C  1  00 00 00 00  
00C240  1  00 00 00 00  
00C244  1  00 00 00 00  
00C248  1  00 00 00 00  
00C24C  1  00 00 00 00  
00C250  1  00 00 00 00  
00C254  1  00 00 00 00  
00C258  1  00 00 00 00  
00C25C  1  00 00 00 00  
00C260  1  00 00 00 00  
00C264  1  00 00 00 00  
00C268  1  00 00 00 00  
00C26C  1  00 00 00 00  
00C270  1  00 00 00 00  
00C274  1  00 00 00 00  
00C278  1  00 00 00 00  
00C27C  1  00 00 00 00  
00C280  1  00 00 00 00  
00C284  1  00 00 00 00  
00C288  1  00 00 00 00  
00C28C  1  00 00 00 00  
00C290  1  00 00 00 00  
00C294  1  00 00 00 00  
00C298  1  00 00 00 00  
00C29C  1  00 00 00 00  
00C2A0  1  00 00 00 00  
00C2A4  1  00 00 00 00  
00C2A8  1  00 00 00 00  
00C2AC  1  00 00 00 00  
00C2B0  1  00 00 00 00  
00C2B4  1  00 00 00 00  
00C2B8  1  00 00 00 00  
00C2BC  1  00 00 00 00  
00C2C0  1  00 00 00 00  
00C2C4  1  00 00 00 00  
00C2C8  1  00 00 00 00  
00C2CC  1  00 00 00 00  
00C2D0  1  00 00 00 00  
00C2D4  1  00 00 00 00  
00C2D8  1  00 00 00 00  
00C2DC  1  00 00 00 00  
00C2E0  1  00 00 00 00  
00C2E4  1  00 00 00 00  
00C2E8  1  00 00 00 00  
00C2EC  1  00 00 00 00  
00C2F0  1  00 00 00 00  
00C2F4  1  00 00 00 00  
00C2F8  1  00 00 00 00  
00C2FC  1  00 00 00 00  
00C300  1  00 00 00 00  
00C304  1  00 00 00 00  
00C308  1  00 00 00 00  
00C30C  1  00 00 00 00  
00C310  1  00 00 00 00  
00C314  1  00 00 00 00  
00C318  1  00 00 00 00  
00C31C  1  00 00 00 00  
00C320  1  00 00 00 00  
00C324  1  00 00 00 00  
00C328  1  00 00 00 00  
00C32C  1  00 00 00 00  
00C330  1  00 00 00 00  
00C334  1  00 00 00 00  
00C338  1  00 00 00 00  
00C33C  1  00 00 00 00  
00C340  1  00 00 00 00  
00C344  1  00 00 00 00  
00C348  1  00 00 00 00  
00C34C  1  00 00 00 00  
00C350  1  00 00 00 00  
00C354  1  00 00 00 00  
00C358  1  00 00 00 00  
00C35C  1  00 00 00 00  
00C360  1  00 00 00 00  
00C364  1  00 00 00 00  
00C368  1  00 00 00 00  
00C36C  1  00 00 00 00  
00C370  1  00 00 00 00  
00C374  1  00 00 00 00  
00C378  1  00 00 00 00  
00C37C  1  00 00 00 00  
00C380  1  00 00 00 00  
00C384  1  00 00 00 00  
00C388  1  00 00 00 00  
00C38C  1  00 00 00 00  
00C390  1  00 00 00 00  
00C394  1  00 00 00 00  
00C398  1  00 00 00 00  
00C39C  1  00 00 00 00  
00C3A0  1  00 00 00 00  
00C3A4  1  00 00 00 00  
00C3A8  1  00 00 00 00  
00C3AC  1  00 00 00 00  
00C3B0  1  00 00 00 00  
00C3B4  1  00 00 00 00  
00C3B8  1  00 00 00 00  
00C3BC  1  00 00 00 00  
00C3C0  1  00 00 00 00  
00C3C4  1  00 00 00 00  
00C3C8  1  00 00 00 00  
00C3CC  1  00 00 00 00  
00C3D0  1  00 00 00 00  
00C3D4  1  00 00 00 00  
00C3D8  1  00 00 00 00  
00C3DC  1  00 00 00 00  
00C3E0  1  00 00 00 00  
00C3E4  1  00 00 00 00  
00C3E8  1  00 00 00 00  
00C3EC  1  00 00 00 00  
00C3F0  1  00 00 00 00  
00C3F4  1  00 00 00 00  
00C3F8  1  00 00 00 00  
00C3FC  1  00 00 00 00  
00C400  1  00 00 00 00  
00C404  1  00 00 00 00  
00C408  1  00 00 00 00  
00C40C  1  00 00 00 00  
00C410  1  00 00 00 00  
00C414  1  00 00 00 00  
00C418  1  00 00 00 00  
00C41C  1  00 00 00 00  
00C420  1  00 00 00 00  
00C424  1  00 00 00 00  
00C428  1  00 00 00 00  
00C42C  1  00 00 00 00  
00C430  1  00 00 00 00  
00C434  1  00 00 00 00  
00C438  1  00 00 00 00  
00C43C  1  00 00 00 00  
00C440  1  00 00 00 00  
00C444  1  00 00 00 00  
00C448  1  00 00 00 00  
00C44C  1  00 00 00 00  
00C450  1  00 00 00 00  
00C454  1  00 00 00 00  
00C458  1  00 00 00 00  
00C45C  1  00 00 00 00  
00C460  1  00 00 00 00  
00C464  1  00 00 00 00  
00C468  1  00 00 00 00  
00C46C  1  00 00 00 00  
00C470  1  00 00 00 00  
00C474  1  00 00 00 00  
00C478  1  00 00 00 00  
00C47C  1  00 00 00 00  
00C480  1  00 00 00 00  
00C484  1  00 00 00 00  
00C488  1  00 00 00 00  
00C48C  1  00 00 00 00  
00C490  1  00 00 00 00  
00C494  1  00 00 00 00  
00C498  1  00 00 00 00  
00C49C  1  00 00 00 00  
00C4A0  1  00 00 00 00  
00C4A4  1  00 00 00 00  
00C4A8  1  00 00 00 00  
00C4AC  1  00 00 00 00  
00C4B0  1  00 00 00 00  
00C4B4  1  00 00 00 00  
00C4B8  1  00 00 00 00  
00C4BC  1  00 00 00 00  
00C4C0  1  00 00 00 00  
00C4C4  1  00 00 00 00  
00C4C8  1  00 00 00 00  
00C4CC  1  00 00 00 00  
00C4D0  1  00 00 00 00  
00C4D4  1  00 00 00 00  
00C4D8  1  00 00 00 00  
00C4DC  1  00 00 00 00  
00C4E0  1  00 00 00 00  
00C4E4  1  00 00 00 00  
00C4E8  1  00 00 00 00  
00C4EC  1  00 00 00 00  
00C4F0  1  00 00 00 00  
00C4F4  1  00 00 00 00  
00C4F8  1  00 00 00 00  
00C4FC  1  00 00 00 00  
00C500  1  00 00 00 00  
00C504  1  00 00 00 00  
00C508  1  00 00 00 00  
00C50C  1  00 00 00 00  
00C510  1  00 00 00 00  
00C514  1  00 00 00 00  
00C518  1  00 00 00 00  
00C51C  1  00 00 00 00  
00C520  1  00 00 00 00  
00C524  1  00 00 00 00  
00C528  1  00 00 00 00  
00C52C  1  00 00 00 00  
00C530  1  00 00 00 00  
00C534  1  00 00 00 00  
00C538  1  00 00 00 00  
00C53C  1  00 00 00 00  
00C540  1  00 00 00 00  
00C544  1  00 00 00 00  
00C548  1  00 00 00 00  
00C54C  1  00 00 00 00  
00C550  1  00 00 00 00  
00C554  1  00 00 00 00  
00C558  1  00 00 00 00  
00C55C  1  00 00 00 00  
00C560  1  00 00 00 00  
00C564  1  00 00 00 00  
00C568  1  00 00 00 00  
00C56C  1  00 00 00 00  
00C570  1  00 00 00 00  
00C574  1  00 00 00 00  
00C578  1  00 00 00 00  
00C57C  1  00 00 00 00  
00C580  1  00 00 00 00  
00C584  1  00 00 00 00  
00C588  1  00 00 00 00  
00C58C  1  00 00 00 00  
00C590  1  00 00 00 00  
00C594  1  00 00 00 00  
00C598  1  00 00 00 00  
00C59C  1  00 00 00 00  
00C5A0  1  00 00 00 00  
00C5A4  1  00 00 00 00  
00C5A8  1  00 00 00 00  
00C5AC  1  00 00 00 00  
00C5B0  1  00 00 00 00  
00C5B4  1  00 00 00 00  
00C5B8  1  00 00 00 00  
00C5BC  1  00 00 00 00  
00C5C0  1  00 00 00 00  
00C5C4  1  00 00 00 00  
00C5C8  1  00 00 00 00  
00C5CC  1  00 00 00 00  
00C5D0  1  00 00 00 00  
00C5D4  1  00 00 00 00  
00C5D8  1  00 00 00 00  
00C5DC  1  00 00 00 00  
00C5E0  1  00 00 00 00  
00C5E4  1  00 00 00 00  
00C5E8  1  00 00 00 00  
00C5EC  1  00 00 00 00  
00C5F0  1  00 00 00 00  
00C5F4  1  00 00 00 00  
00C5F8  1  00 00 00 00  
00C5FC  1  00 00 00 00  
00C600  1  00 00 00 00  
00C604  1  00 00 00 00  
00C608  1  00 00 00 00  
00C60C  1  00 00 00 00  
00C610  1  00 00 00 00  
00C614  1  00 00 00 00  
00C618  1  00 00 00 00  
00C61C  1  00 00 00 00  
00C620  1  00 00 00 00  
00C624  1  00 00 00 00  
00C628  1  00 00 00 00  
00C62C  1  00 00 00 00  
00C630  1  00 00 00 00  
00C634  1  00 00 00 00  
00C638  1  00 00 00 00  
00C63C  1  00 00 00 00  
00C640  1  00 00 00 00  
00C644  1  00 00 00 00  
00C648  1  00 00 00 00  
00C64C  1  00 00 00 00  
00C650  1  00 00 00 00  
00C654  1  00 00 00 00  
00C658  1  00 00 00 00  
00C65C  1  00 00 00 00  
00C660  1  00 00 00 00  
00C664  1  00 00 00 00  
00C668  1  00 00 00 00  
00C66C  1  00 00 00 00  
00C670  1  00 00 00 00  
00C674  1  00 00 00 00  
00C678  1  00 00 00 00  
00C67C  1  00 00 00 00  
00C680  1  00 00 00 00  
00C684  1  00 00 00 00  
00C688  1  00 00 00 00  
00C68C  1  00 00 00 00  
00C690  1  00 00 00 00  
00C694  1  00 00 00 00  
00C698  1  00 00 00 00  
00C69C  1  00 00 00 00  
00C6A0  1  00 00 00 00  
00C6A4  1  00 00 00 00  
00C6A8  1  00 00 00 00  
00C6AC  1  00 00 00 00  
00C6B0  1  00 00 00 00  
00C6B4  1  00 00 00 00  
00C6B8  1  00 00 00 00  
00C6BC  1  00 00 00 00  
00C6C0  1  00 00 00 00  
00C6C4  1  00 00 00 00  
00C6C8  1  00 00 00 00  
00C6CC  1  00 00 00 00  
00C6D0  1  00 00 00 00  
00C6D4  1  00 00 00 00  
00C6D8  1  00 00 00 00  
00C6DC  1  00 00 00 00  
00C6E0  1  00 00 00 00  
00C6E4  1  00 00 00 00  
00C6E8  1  00 00 00 00  
00C6EC  1  00 00 00 00  
00C6F0  1  00 00 00 00  
00C6F4  1  00 00 00 00  
00C6F8  1  00 00 00 00  
00C6FC  1  00 00 00 00  
00C700  1  00 00 00 00  
00C704  1  00 00 00 00  
00C708  1  00 00 00 00  
00C70C  1  00 00 00 00  
00C710  1  00 00 00 00  
00C714  1  00 00 00 00  
00C718  1  00 00 00 00  
00C71C  1  00 00 00 00  
00C720  1  00 00 00 00  
00C724  1  00 00 00 00  
00C728  1  00 00 00 00  
00C72C  1  00 00 00 00  
00C730  1  00 00 00 00  
00C734  1  00 00 00 00  
00C738  1  00 00 00 00  
00C73C  1  00 00 00 00  
00C740  1  00 00 00 00  
00C744  1  00 00 00 00  
00C748  1  00 00 00 00  
00C74C  1  00 00 00 00  
00C750  1  00 00 00 00  
00C754  1  00 00 00 00  
00C758  1  00 00 00 00  
00C75C  1  00 00 00 00  
00C760  1  00 00 00 00  
00C764  1  00 00 00 00  
00C768  1  00 00 00 00  
00C76C  1  00 00 00 00  
00C770  1  00 00 00 00  
00C774  1  00 00 00 00  
00C778  1  00 00 00 00  
00C77C  1  00 00 00 00  
00C780  1  00 00 00 00  
00C784  1  00 00 00 00  
00C788  1  00 00 00 00  
00C78C  1  00 00 00 00  
00C790  1  00 00 00 00  
00C794  1  00 00 00 00  
00C798  1  00 00 00 00  
00C79C  1  00 00 00 00  
00C7A0  1  00 00 00 00  
00C7A4  1  00 00 00 00  
00C7A8  1  00 00 00 00  
00C7AC  1  00 00 00 00  
00C7B0  1  00 00 00 00  
00C7B4  1  00 00 00 00  
00C7B8  1  00 00 00 00  
00C7BC  1  00 00 00 00  
00C7C0  1  00 00 00 00  
00C7C4  1  00 00 00 00  
00C7C8  1  00 00 00 00  
00C7CC  1  00 00 00 00  
00C7D0  1  00 00 00 00  
00C7D4  1  00 00 00 00  
00C7D8  1  00 00 00 00  
00C7DC  1  00 00 00 00  
00C7E0  1  00 00 00 00  
00C7E4  1  00 00 00 00  
00C7E8  1  00 00 00 00  
00C7EC  1  00 00 00 00  
00C7F0  1  00 00 00 00  
00C7F4  1  00 00 00 00  
00C7F8  1  00 00 00 00  
00C7FC  1  00 00 00 00  
00C800  1  00 00 00 00  
00C804  1  00 00 00 00  
00C808  1  00 00 00 00  
00C80C  1  00 00 00 00  
00C810  1  00 00 00 00  
00C814  1  00 00 00 00  
00C818  1  00 00 00 00  
00C81C  1  00 00 00 00  
00C820  1  00 00 00 00  
00C824  1  00 00 00 00  
00C828  1  00 00 00 00  
00C82C  1  00 00 00 00  
00C830  1  00 00 00 00  
00C834  1  00 00 00 00  
00C838  1  00 00 00 00  
00C83C  1  00 00 00 00  
00C840  1  00 00 00 00  
00C844  1  00 00 00 00  
00C848  1  00 00 00 00  
00C84C  1  00 00 00 00  
00C850  1  00 00 00 00  
00C854  1  00 00 00 00  
00C858  1  00 00 00 00  
00C85C  1  00 00 00 00  
00C860  1  00 00 00 00  
00C864  1  00 00 00 00  
00C868  1  00 00 00 00  
00C86C  1  00 00 00 00  
00C870  1  00 00 00 00  
00C874  1  00 00 00 00  
00C878  1  00 00 00 00  
00C87C  1  00 00 00 00  
00C880  1  00 00 00 00  
00C884  1  00 00 00 00  
00C888  1  00 00 00 00  
00C88C  1  00 00 00 00  
00C890  1  00 00 00 00  
00C894  1  00 00 00 00  
00C898  1  00 00 00 00  
00C89C  1  00 00 00 00  
00C8A0  1  00 00 00 00  
00C8A4  1  00 00 00 00  
00C8A8  1  00 00 00 00  
00C8AC  1  00 00 00 00  
00C8B0  1  00 00 00 00  
00C8B4  1  00 00 00 00  
00C8B8  1  00 00 00 00  
00C8BC  1  00 00 00 00  
00C8C0  1  00 00 00 00  
00C8C4  1  00 00 00 00  
00C8C8  1  00 00 00 00  
00C8CC  1  00 00 00 00  
00C8D0  1  00 00 00 00  
00C8D4  1  00 00 00 00  
00C8D8  1  00 00 00 00  
00C8DC  1  00 00 00 00  
00C8E0  1  00 00 00 00  
00C8E4  1  00 00 00 00  
00C8E8  1  00 00 00 00  
00C8EC  1  00 00 00 00  
00C8F0  1  00 00 00 00  
00C8F4  1  00 00 00 00  
00C8F8  1  00 00 00 00  
00C8FC  1  00 00 00 00  
00C900  1  00 00 00 00  
00C904  1  00 00 00 00  
00C908  1  00 00 00 00  
00C90C  1  00 00 00 00  
00C910  1  00 00 00 00  
00C914  1  00 00 00 00  
00C918  1  00 00 00 00  
00C91C  1  00 00 00 00  
00C920  1  00 00 00 00  
00C924  1  00 00 00 00  
00C928  1  00 00 00 00  
00C92C  1  00 00 00 00  
00C930  1  00 00 00 00  
00C934  1  00 00 00 00  
00C938  1  00 00 00 00  
00C93C  1  00 00 00 00  
00C940  1  00 00 00 00  
00C944  1  00 00 00 00  
00C948  1  00 00 00 00  
00C94C  1  00 00 00 00  
00C950  1  00 00 00 00  
00C954  1  00 00 00 00  
00C958  1  00 00 00 00  
00C95C  1  00 00 00 00  
00C960  1  00 00 00 00  
00C964  1  00 00 00 00  
00C968  1  00 00 00 00  
00C96C  1  00 00 00 00  
00C970  1  00 00 00 00  
00C974  1  00 00 00 00  
00C978  1  00 00 00 00  
00C97C  1  00 00 00 00  
00C980  1  00 00 00 00  
00C984  1  00 00 00 00  
00C988  1  00 00 00 00  
00C98C  1  00 00 00 00  
00C990  1  00 00 00 00  
00C994  1  00 00 00 00  
00C998  1  00 00 00 00  
00C99C  1  00 00 00 00  
00C9A0  1  00 00 00 00  
00C9A4  1  00 00 00 00  
00C9A8  1  00 00 00 00  
00C9AC  1  00 00 00 00  
00C9B0  1  00 00 00 00  
00C9B4  1  00 00 00 00  
00C9B8  1  00 00 00 00  
00C9BC  1  00 00 00 00  
00C9C0  1  00 00 00 00  
00C9C4  1  00 00 00 00  
00C9C8  1  00 00 00 00  
00C9CC  1  00 00 00 00  
00C9D0  1  00 00 00 00  
00C9D4  1  00 00 00 00  
00C9D8  1  00 00 00 00  
00C9DC  1  00 00 00 00  
00C9E0  1  00 00 00 00  
00C9E4  1  00 00 00 00  
00C9E8  1  00 00 00 00  
00C9EC  1  00 00 00 00  
00C9F0  1  00 00 00 00  
00C9F4  1  00 00 00 00  
00C9F8  1  00 00 00 00  
00C9FC  1  00 00 00 00  
00CA00  1  00 00 00 00  
00CA04  1  00 00 00 00  
00CA08  1  00 00 00 00  
00CA0C  1  00 00 00 00  
00CA10  1  00 00 00 00  
00CA14  1  00 00 00 00  
00CA18  1  00 00 00 00  
00CA1C  1  00 00 00 00  
00CA20  1  00 00 00 00  
00CA24  1  00 00 00 00  
00CA28  1  00 00 00 00  
00CA2C  1  00 00 00 00  
00CA30  1  00 00 00 00  
00CA34  1  00 00 00 00  
00CA38  1  00 00 00 00  
00CA3C  1  00 00 00 00  
00CA40  1  00 00 00 00  
00CA44  1  00 00 00 00  
00CA48  1  00 00 00 00  
00CA4C  1  00 00 00 00  
00CA50  1  00 00 00 00  
00CA54  1  00 00 00 00  
00CA58  1  00 00 00 00  
00CA5C  1  00 00 00 00  
00CA60  1  00 00 00 00  
00CA64  1  00 00 00 00  
00CA68  1  00 00 00 00  
00CA6C  1  00 00 00 00  
00CA70  1  00 00 00 00  
00CA74  1  00 00 00 00  
00CA78  1  00 00 00 00  
00CA7C  1  00 00 00 00  
00CA80  1  00 00 00 00  
00CA84  1  00 00 00 00  
00CA88  1  00 00 00 00  
00CA8C  1  00 00 00 00  
00CA90  1  00 00 00 00  
00CA94  1  00 00 00 00  
00CA98  1  00 00 00 00  
00CA9C  1  00 00 00 00  
00CAA0  1  00 00 00 00  
00CAA4  1  00 00 00 00  
00CAA8  1  00 00 00 00  
00CAAC  1  00 00 00 00  
00CAB0  1  00 00 00 00  
00CAB4  1  00 00 00 00  
00CAB8  1  00 00 00 00  
00CABC  1  00 00 00 00  
00CAC0  1  00 00 00 00  
00CAC4  1  00 00 00 00  
00CAC8  1  00 00 00 00  
00CACC  1  00 00 00 00  
00CAD0  1  00 00 00 00  
00CAD4  1  00 00 00 00  
00CAD8  1  00 00 00 00  
00CADC  1  00 00 00 00  
00CAE0  1  00 00 00 00  
00CAE4  1  00 00 00 00  
00CAE8  1  00 00 00 00  
00CAEC  1  00 00 00 00  
00CAF0  1  00 00 00 00  
00CAF4  1  00 00 00 00  
00CAF8  1  00 00 00 00  
00CAFC  1  00 00 00 00  
00CB00  1  00 00 00 00  
00CB04  1  00 00 00 00  
00CB08  1  00 00 00 00  
00CB0C  1  00 00 00 00  
00CB10  1  00 00 00 00  
00CB14  1  00 00 00 00  
00CB18  1  00 00 00 00  
00CB1C  1  00 00 00 00  
00CB20  1  00 00 00 00  
00CB24  1  00 00 00 00  
00CB28  1  00 00 00 00  
00CB2C  1  00 00 00 00  
00CB30  1  00 00 00 00  
00CB34  1  00 00 00 00  
00CB38  1  00 00 00 00  
00CB3C  1  00 00 00 00  
00CB40  1  00 00 00 00  
00CB44  1  00 00 00 00  
00CB48  1  00 00 00 00  
00CB4C  1  00 00 00 00  
00CB50  1  00 00 00 00  
00CB54  1  00 00 00 00  
00CB58  1  00 00 00 00  
00CB5C  1  00 00 00 00  
00CB60  1  00 00 00 00  
00CB64  1  00 00 00 00  
00CB68  1  00 00 00 00  
00CB6C  1  00 00 00 00  
00CB70  1  00 00 00 00  
00CB74  1  00 00 00 00  
00CB78  1  00 00 00 00  
00CB7C  1  00 00 00 00  
00CB80  1  00 00 00 00  
00CB84  1  00 00 00 00  
00CB88  1  00 00 00 00  
00CB8C  1  00 00 00 00  
00CB90  1  00 00 00 00  
00CB94  1  00 00 00 00  
00CB98  1  00 00 00 00  
00CB9C  1  00 00 00 00  
00CBA0  1  00 00 00 00  
00CBA4  1  00 00 00 00  
00CBA8  1  00 00 00 00  
00CBAC  1  00 00 00 00  
00CBB0  1  00 00 00 00  
00CBB4  1  00 00 00 00  
00CBB8  1  00 00 00 00  
00CBBC  1  00 00 00 00  
00CBC0  1  00 00 00 00  
00CBC4  1  00 00 00 00  
00CBC8  1  00 00 00 00  
00CBCC  1  00 00 00 00  
00CBD0  1  00 00 00 00  
00CBD4  1  00 00 00 00  
00CBD8  1  00 00 00 00  
00CBDC  1  00 00 00 00  
00CBE0  1  00 00 00 00  
00CBE4  1  00 00 00 00  
00CBE8  1  00 00 00 00  
00CBEC  1  00 00 00 00  
00CBF0  1  00 00 00 00  
00CBF4  1  00 00 00 00  
00CBF8  1  00 00 00 00  
00CBFC  1  00 00 00 00  
00CC00  1  00 00 00 00  
00CC04  1  00 00 00 00  
00CC08  1  00 00 00 00  
00CC0C  1  00 00 00 00  
00CC10  1  00 00 00 00  
00CC14  1  00 00 00 00  
00CC18  1  00 00 00 00  
00CC1C  1  00 00 00 00  
00CC20  1  00 00 00 00  
00CC24  1  00 00 00 00  
00CC28  1  00 00 00 00  
00CC2C  1  00 00 00 00  
00CC30  1  00 00 00 00  
00CC34  1  00 00 00 00  
00CC38  1  00 00 00 00  
00CC3C  1  00 00 00 00  
00CC40  1  00 00 00 00  
00CC44  1  00 00 00 00  
00CC48  1  00 00 00 00  
00CC4C  1  00 00 00 00  
00CC50  1  00 00 00 00  
00CC54  1  00 00 00 00  
00CC58  1  00 00 00 00  
00CC5C  1  00 00 00 00  
00CC60  1  00 00 00 00  
00CC64  1  00 00 00 00  
00CC68  1  00 00 00 00  
00CC6C  1  00 00 00 00  
00CC70  1  00 00 00 00  
00CC74  1  00 00 00 00  
00CC78  1  00 00 00 00  
00CC7C  1  00 00 00 00  
00CC80  1  00 00 00 00  
00CC84  1  00 00 00 00  
00CC88  1  00 00 00 00  
00CC8C  1  00 00 00 00  
00CC90  1  00 00 00 00  
00CC94  1  00 00 00 00  
00CC98  1  00 00 00 00  
00CC9C  1  00 00 00 00  
00CCA0  1  00 00 00 00  
00CCA4  1  00 00 00 00  
00CCA8  1  00 00 00 00  
00CCAC  1  00 00 00 00  
00CCB0  1  00 00 00 00  
00CCB4  1  00 00 00 00  
00CCB8  1  00 00 00 00  
00CCBC  1  00 00 00 00  
00CCC0  1  00 00 00 00  
00CCC4  1  00 00 00 00  
00CCC8  1  00 00 00 00  
00CCCC  1  00 00 00 00  
00CCD0  1  00 00 00 00  
00CCD4  1  00 00 00 00  
00CCD8  1  00 00 00 00  
00CCDC  1  00 00 00 00  
00CCE0  1  00 00 00 00  
00CCE4  1  00 00 00 00  
00CCE8  1  00 00 00 00  
00CCEC  1  00 00 00 00  
00CCF0  1  00 00 00 00  
00CCF4  1  00 00 00 00  
00CCF8  1  00 00 00 00  
00CCFC  1  00 00 00 00  
00CD00  1               ;	.include	"hardware/6551/6551.asm"
00CD00  1               	.include	"hardware/NXP28L92/NXP28L92.asm"
00CD00  2               ;===============================================================================
00CD00  2               ;   A D R I A   - Philips/NXP 28L9x Driver skeleton
00CD00  2               ;
00CD00  2               ; 	This source file is the base skeleton for the driver for the
00CD00  2               ;	Philips/NXP 28L9x IC.
00CD00  2               ;
00CD00  2               ;	This driver is (largely) based on the driver by
00CD00  2               ;	BDD (sbc.bcstechnology.net) and his documents "28l91 Driving" and
00CD00  2               ;	"28L92 Interfacing".
00CD00  2               ;	(Most of this driver is copied from/based on his work!)
00CD00  2               ;
00CD00  2               ;	Written for use with the CC65 assembler.
00CD00  2               ;
00CD00  2               ;	Version history:
00CD00  2               ;		26 jan 2021 	- Inital version
00CD00  2               ;		18 feb 2021 	- Userland driver seems to work, migrating to
00CD00  2               ;				  ROM based driver
00CD00  2               ;				- For now, channel B ISR is INCOMPLETE
00CD00  2               ;				- Added blocking input routine for channel A
00CD00  2               ;-------------------------------------------------------------------------------
00CD00  2               ; For the userland driver we use the unique functions names when accessing the
00CD00  2               ; frontend of the driver (e.g. routines available to users).
00CD00  2               ; for the ROM based driver, we the more "generic" names. This is to avoid major
00CD00  2               ; rewrites.
00CD00  2               ; Also the userland driver was/is loaded at $00/4000. The ROM based driver will
00CD00  2               ; be loaded at $00/FB00.
00CD00  2               ;
00CD00  2               ; ----------------------
00CD00  2               ; Routine name "translation" table
00CD00  2               ; ----------------------
00CD00  2               ; Userland		ROM
00CD00  2               ; ______________	________________
00CD00  2               ; nx_init		uart_init	- Initialize driver
00CD00  2               ; nx_sioget_a		uart_scan	- Non blocking input (scan)
00CD00  2               ; nx_sioget_a_block	uart_input	- Blocking input (non-scan!)
00CD00  2               ; nx_sioput_a		uart_output	- Output
00CD00  2               ; nx_sioget_b
00CD00  2               ; nx_sioput_b
00CD00  2               ;
00CD00  2               ; Userland or ROM driver
00CD00  2               ;-----------------------
00CD00  2               ; If we want to assemble the userland driver, set NX_USERDRIVER to 1, otherwise
00CD00  2               ; set to =
00CD00  2               NX_USERDRIVER		= 0
00CD00  2               ;===============================================================================
00CD00  2               ;	Linker directives
00CD00  2               ;---------------------------------------
00CD00  2               	.p816
00CD00  2               	.listbytes	unlimited
00CD00  2               	.smart 		+
00CD00  2               ;
00CD00  2               .if	NX_USERDRIVER 	= 1
00CD00  2               	UART_DRIVER	= $4000		; Load address for userland
00CD00  2               .endif
00CD00  2               ;
00CD00  2               	.org		UART_DRIVER
00CD00  2               ;
00CD00  2               ;---------------------------------------
00CD00  2               ;	Includes to sub-modules
00CD00  2               ;---------------------------------------
00CD00  2               	.include	"hardware/NXP28L92/nx_macro.asm"
00CD00  3               ;===============================================================================
00CD00  3               ;   A D R I A   - Philips/NXP 28L9x Macro file
00CD00  3               ;
00CD00  3               ; 	This source file holds the global macro definitions to ease the
00CD00  3               ;	development of the drivre for the Philips/NXP 28L9x IC.
00CD00  3               ;
00CD00  3               ;	Version history:
00CD00  3               ;		26 jan 2021 	- Inital version
00CD00  3               ;		18 feb 2021 	- Userland driver seems to work, migrating to
00CD00  3               ;				  ROM based driver
00CD00  3               ;===============================================================================
00CD00  3               ; 	Version information
00CD00  3               ;---------------------------------------
00CD00  3               	.macro	nx_9x_version
00CD00  3               	.byte	'0'			; Major
00CD00  3               	.byte	'.'
00CD00  3               	.byte	'2'			; Minor
00CD00  3               	.byte	'.'
00CD00  3               	.byte	'0'			; Revision
00CD00  3               	.endmacro
00CD00  3               ;
00CD00  3               .if	NX_USERDRIVER	= 1
00CD00  3               ;
00CD00  3               ;---------------------------------------
00CD00  3               ;	Register width selection
00CD00  3               ;---------------------------------------
00CD00  3               	.macro	longi			; Set .X and .Y to 16-bit
00CD00  3               	rep	#%00010000
00CD00  3               	.i16
00CD00  3               	.endmacro
00CD00  3               ;
00CD00  3               	.macro	shorti			; Set .X and .Y to 8-bit
00CD00  3               	sep	#%00010000
00CD00  3               	.i8
00CD00  3               	.endmacro
00CD00  3               ;
00CD00  3               	.macro	longa			; Set .A to 16-bit
00CD00  3               	rep	#%00100000
00CD00  3               	.a16
00CD00  3               	.endmacro
00CD00  3               ;
00CD00  3               	.macro	shorta			; Set .A to 8-bit
00CD00  3               	sep	#%00100000
00CD00  3               	.a8
00CD00  3               	.endmacro
00CD00  3               ;
00CD00  3               	.macro	longr			; Set all registers to 16-bit
00CD00  3               	rep	#%00110000		; Set 16-bit .A, .X and .Y
00CD00  3               	.a16
00CD00  3               	.i16
00CD00  3               	.endmacro
00CD00  3               ;
00CD00  3               	.macro	shortr			; Set all registers to 8-bit
00CD00  3               	sep	#%00110000		; Set 8-bit .A, .X and .Y
00CD00  3               	.a8
00CD00  3               	.i8
00CD00  3               	.endmacro
00CD00  3               .endif
00CD00  3               
00CD00  2               	.include	"hardware/NXP28L92/nx_global.asm"
00CD00  3               ;===============================================================================
00CD00  3               ;   A D R I A   - Philips/NXP 28L9x Global definitions file
00CD00  3               ;
00CD00  3               ; 	This source file holds the global definitions for the drivre for the
00CD00  3               ;	Philips/NXP 28L9x IC.
00CD00  3               ;
00CD00  3               ;	Version history:
00CD00  3               ;		26 jan 2021 	- Initial version
00CD00  3               ;		18 feb 2021 	- Userland driver seems to work, migrating to
00CD00  3               ;				  ROM based driver
00CD00  3               ;		25 feb 2021	- Consolidate ZP usage (try to make it one
00CD00  3               ;				  block)
00CD00  3               ;===============================================================================
00CD00  3               ; GENERIC
00CD00  3               ;=======================================
00CD00  3               ; Size data types
00CD00  3               ;---------------------------------------
00CD00  3               .if NX_USERDRIVER
00CD00  3               s_bi_bit	= 1			;  1 bit
00CD00  3               s_bi_nibble	= 4			;  4 bit, nibble (or nybble)
00CD00  3               s_bi_nybble	= s_bi_nibble
00CD00  3               s_bi_byte	= 8			;  8 bit, 1 byte
00CD00  3               ;
00CD00  3               s_byte		= 1			;  8 bit, 1 byte
00CD00  3               s_word		= 2			; 16 bit, 2 bytes
00CD00  3               s_xword		= 3			; 24 bit, 3 bytes
00CD00  3               s_dword		= 4			; 32 bit, 4 bytes
00CD00  3               ;
00CD00  3               s_ptr		= s_word		; Pointer	, 16 bit, 2 bytes
00CD00  3               s_dptr		= s_word * 2		; Double pointer, 32 bit, 4 bytes
00CD00  3               s_rampage	= $0100			; 65xx size of RAM page (256 bytes)
00CD00  3               s_bank		= $ffff			; 65816 size of RAM bank (65536 bytes)
00CD00  3               ;
00CD00  3               s_mpudbrx	= s_byte		; Size of Data Bank register
00CD00  3               s_mpudpx	= s_word		; Size of Direct Page register
00CD00  3               s_mpupbx	= s_byte		; Size of Program Bank register
00CD00  3               s_mpupcx	= s_word		; Size of Program Counter register
00CD00  3               s_mpuspx	= s_word		; Size of Stack Pointer register
00CD00  3               s_mpusrx	= s_byte		; Size of Processor Status register
00CD00  3               ;
00CD00  3               ;---------------------------------------
00CD00  3               ; Flags
00CD00  3               ;---------------------------------------
00CD00  3               ; 	Status Register
00CD00  3               ;		   +----------> 1 = result = negative
00CD00  3               ;		   |+---------> 1 = sign overflow
00CD00  3               ;		   ||           1 = 8 bit .A & memory
00CD00  3               ;		   ||+--------> 0 = 16 bit .A & memory
00CD00  3               ;		   |||          1 = 8 bit index
00CD00  3               ;		   |||+-------> 0 = 16 bit index
00CD00  3               ;		   ||||         1 = decimal arithmetic mode
00CD00  3               ;		   ||||+------> 0 = binary arithmetic mode
00CD00  3               ;		   |||||+-----> 1 = IRQ disabled
00CD00  3               ;		   ||||||+----> 1 = result = zero
00CD00  3               ;		   |||||||+---> 1 = carry set/generated
00CD00  3               ;		   ||||||||
00CD00  3               ;		   NVmxDIZC
00CD00  3               ;---------------
00CD00  3               sr_carry	= %0000001		; C => carry
00CD00  3               sr_zero		= sr_carry 	<< 1	; Z => zero
00CD00  3               sr_irq		= sr_zero 	<< 1	; I => IRQ
00CD00  3               sr_bdm		= sr_irq 	<< 1	; D => decimal mode
00CD00  3               sr_ixw		= sr_bdm	<< 1	; x => index register width
00CD00  3               sr_amw		= sr_ixw	<< 1	; m => memory and .A width
00CD00  3               sr_ovl		= sr_amw	<< 1	; V => overflow
00CD00  3               sr_neg		= sr_ovl	<< 1	; N => negative
00CD00  3               ;---------------
00CD00  3               ; 	Status Register - Inverted
00CD00  3               ;---------------
00CD00  3               sr_carry_i	= sr_carry ^ %11111111	; C
00CD00  3               sr_zero_i	= sr_zero  ^ %11111111	; Z
00CD00  3               sr_irq_i	= sr_irq   ^ %11111111	; I
00CD00  3               sr_bdm_i	= sr_bdm   ^ %11111111	; D
00CD00  3               sr_ixw_i	= sr_ixw   ^ %11111111	; x
00CD00  3               sr_amw_i	= sr_amw   ^ %11111111	; m
00CD00  3               sr_ovl_i	= sr_ovl   ^ %11111111	; V
00CD00  3               sr_neg_i	= sr_neg   ^ %11111111	; N
00CD00  3               ;
00CD00  3               ;---------------------------------------
00CD00  3               ; Constants
00CD00  3               ;---------------------------------------
00CD00  3               BELL		= $07			; <Bell>
00CD00  3               BS		= $08			; <Backspace>
00CD00  3               HTAB		= $09			; <Tab>
00CD00  3               LF		= $0A			; <LF>
00CD00  3               CR		= $0D			; <CR>
00CD00  3               SPACE		= $20			; <Space>
00CD00  3               DEL		= $7F			; <Del>
00CD00  3               ;
00CD00  3               ;---------------------------------------
00CD00  3               ; Pointers/addresses
00CD00  3               ;---------------------------------------
00CD00  3               ;	SUPERMON816
00CD00  3               ;---------------
00CD00  3               DPYHEX		= $DFAD			; Display contents of .A as byte
00CD00  3               NEWLINE		= $DFC4			; Go to new line
00CD00  3               ;---------------
00CD00  3               ;	ROM
00CD00  3               ;---------------
00CD00  3               VECTOR_INT	= $02D8			; /IRQ jump vector
00CD00  3               CHKSUM_INT	= $02DA			; /IRQ jump vector checksum
00CD00  3               CHAR_OUT	= $FD0C			; Current Character Out jump routine
00CD00  3               ;
00CD00  3               .endif
00CD00  3               ;
00CD00  3               ;=======================================
00CD00  3               ; 	DRIVER
00CD00  3               ;=======================================
00CD00  3               ; Size data types
00CD00  3               ;---------------------------------------
00CD00  3               s_uptime	= s_dword		; Uptime ticker	, 32 bit, 4 bytes
00CD00  3               ;
00CD00  3               s_e32_buf	= s_rampage / 2		; Size of a UART I/O buffer
00CD00  3               s_e32_space	= s_e32_buf * n_e32_buf	; Total space reserved for UART I/O
00CD00  3               					; buffers
00CD00  3               ;
00CD00  3               ;---------------------------------------
00CD00  3               ; Flags
00CD00  3               ;---------------------------------------
00CD00  3               ;	Channel TxD status
00CD00  3               ; 	Only A and B are used, rest is
00CD00  3               ;	already defined for future use
00CD00  3               e32_tx_sta	= %00000001		; Channel A TxD status
00CD00  3               e32_tx_stb	= e32_tx_sta	<< 1	; Channel B TxD status
00CD00  3               e32_tx_stc	= e32_tx_stb	<< 1	; Channel C TxD status
00CD00  3               e32_tx_std	= e32_tx_stc	<< 1	; Channel D TxD status
00CD00  3               e32_tx_ste	= e32_tx_std	<< 1	; Channel E TxD status
00CD00  3               e32_tx_stf	= e32_tx_ste	<< 1	; Channel F TxD status
00CD00  3               e32_tx_stg	= e32_tx_stf	<< 1	; Channel G TxD status
00CD00  3               e32_tx_sth	= e32_tx_stg	<< 1	; Channel H TxD status
00CD00  3               ;
00CD00  3               ;buf_idx_mask	= s_e32_buf ^ %01111111	; Buffer index wrap mask
00CD00  3               buf_idx_mask	= s_e32_buf - 1		; Buffer index wrap mask (as per BDD)
00CD00  3               ;
00CD00  3               ; 28L9x driver status flags
00CD00  3               nx_driver_init	= %10000000		; Driver initialization status
00CD00  3               nx_txa_dis	= %01000000		; TxD channel A flag
00CD00  3               nx_txb_dis	= %00100000		; TxD channel B flag
00CD00  3               ;
00CD00  3               ;	SR masks
00CD00  3               msk_sr_rx_rdy	= %00000001		; RHR not empty mask
00CD00  3               msk_sr_rx_full	= %00000010		; RHR full empty
00CD00  3               msk_sr_tx_rdy	= %00000100		; THR not full mask
00CD00  3               msk_sr_tx_empty	= %00001000		; THR empty mask
00CD00  3               ;
00CD00  3               ;	IRQ masks
00CD00  3               ;---------------
00CD00  3               msk_irq_txa	= %00000001		; Channel A TxRDY IRQ mask
00CD00  3               msk_irq_rxa	= %00000010		; Channel A RxRDY IRQ mask
00CD00  3               msk_irq_ct	= %00001000		; Counter Ready Mask
00CD00  3               msk_irq_txb	= %00010000		; Channel B TxRDY IRQ mask
00CD00  3               msk_irq_rxb	= %00100000		; Channel B RxRDY IRQ mask
00CD00  3               ;
00CD00  3               ;---------------------------------------
00CD00  3               ; Constants
00CD00  3               ;---------------------------------------
00CD00  3               n_chan_9x	= 2			; Number of channels
00CD00  3               n_reg_9x	= 8			; Number of registers per channel
00CD00  3               n_tot_reg_9x	= n_chan_9x * n_reg_9x	; Total number of registers
00CD00  3               ;
00CD00  3               nx_q_size	= s_rampage / 2		; Size of a ring buffer (127)
00CD00  3               nx_q_base	= $2000			; For now we define our queues at $2000
00CD00  3               nx_rx_qa	= nx_q_base		; RxD queue channel A
00CD00  3               nx_tx_qa	= nx_rx_qa + nx_q_size	; TxD queue channel A
00CD00  3               nx_rx_qb	= nx_tx_qa + nx_q_size	; RxD queue channel B
00CD00  3               nx_tx_qb	= nx_rx_qb + nx_q_size	; TxD queue channel B
00CD00  3               ;
00CD00  3               n_e32_buf	= 4			; # of UART I/O buffers
00CD00  3               ;
00CD00  3               x1_freq		= 3686400		; Clock freq of X1 in Hz
00CD00  3               nx_ct_scale	= x1_freq / 2		; C/T scaled clock
00CD00  3               hz		= 100			; Frequency of C/T IRQs (in Hz)
00CD00  3               ;
00CD00  3               ;---------------------------------------
00CD00  3               ; Pointers/addresses
00CD00  3               ;---------------------------------------
00CD00  3               ; 	Zeropage / Direct Page
00CD00  3               ;---------------
00CD00  3               nx_zeropage	= $60			; We use ZP from $60
00CD00  3               nx_jiffycnt	= nx_zeropage		; Jiffy counter
00CD00  3               ;---------------
00CD00  3               ;	Uptime is little endian!
00CD00  3               ;---------------
00CD00  3               nx_uptimecnt	= nx_jiffycnt  + s_byte	; 32 bit uptime counter
00CD00  3               ;
00CD00  3               ;	RxD and TxD GET and PUT indexes channel A
00CD00  3               nx_rx_get_a	= nx_uptimecnt + s_dword;
00CD00  3               nx_tx_get_a	= nx_rx_get_a  + s_byte	;
00CD00  3               nx_rx_put_a	= nx_tx_get_a  + s_byte	;
00CD00  3               nx_tx_put_a	= nx_rx_put_a  + s_byte	;
00CD00  3               ;
00CD00  3               ;	RxD and TxD GET and PUT indexes channel B
00CD00  3               nx_rx_get_b	= nx_tx_put_a  + s_byte	;
00CD00  3               nx_tx_get_b	= nx_rx_get_b  + s_byte	;
00CD00  3               nx_rx_put_b	= nx_tx_get_b  + s_byte	;
00CD00  3               nx_tx_put_b	= nx_rx_put_b  + s_byte	;
00CD00  3               ;
00CD00  3               nx_tx_status	= nx_tx_put_b + s_byte	; Driver TxD status register
00CD00  3               ;
00CD00  3               rom_irq		= nx_tx_status + s_byte	; Store original IRQ jump vector!
00CD00  3               ;---------------
00CD00  3               ; 	I/O
00CD00  3               ;---------------
00CD00  3               .if	NX_USERDRIVER
00CD00  3               NX_IOBASE	= $C400			; NXP 28L92 is based in slot #4
00CD00  3               					; (userland) driver
00CD00  3               .else
00CD00  3               ;
00CD00  3               NX_IOBASE	= UART_IOBASE
00CD00  3               .endif
00CD00  3               ;
00CD00  3               ;---------------------------------------
00CD00  3               ; Data Registers
00CD00  3               ;---------------------------------------
00CD00  3               ;	Offsets to IO_BASE
00CD00  3               ;---------------
00CD00  3               dr_mra		= %0000			; Mode Register A
00CD00  3               dr_sra		= %0001			; Status Register a
00CD00  3               dr_rxfifoa	= %0011			; Rx Holding Register A
00CD00  3               dr_ipcr		= %0100			; Input Port Change Register
00CD00  3               dr_isr		= %0101			; Interrupt Status Register
00CD00  3               dr_ctu		= %0110			; Counter/Timer (MSB)
00CD00  3               dr_ctl		= %0111			; Counter/Timer (LSB)
00CD00  3               dr_mrb		= %1000			; Mode Register B
00CD00  3               dr_srb		= %1001			; Status Register B
00CD00  3               dr_rxfifob	= %1011			; Rx Holding Register B
00CD00  3               dr_misc		= %1100			; Miscellaneous Register (Intel mode)
00CD00  3               dr_ipr		= %1101			; Input Port Register
00CD00  3               dr_cnt_start	= %1110			; Start counter command
00CD00  3               dr_cnt_stop	= %1111			; Stop counter command
00CD00  3               ; During write
00CD00  3               ;dr_mra	= %0000				; Mode Register A (Same when Reading)
00CD00  3               dr_csra		= %0001			; Clock Select Register A
00CD00  3               dr_cra		= %0010			; Command Register A
00CD00  3               dr_txfifoa	= %0011			; Tx Holding Register A
00CD00  3               dr_acr		= %0100			; Auxiliary Control Register
00CD00  3               dr_imr		= %0101			; Interrupt Mask Register
00CD00  3               dr_ctpu		= %0110			; Counter/Timer Upper Preset Reg (MSB)
00CD00  3               dr_ctpl		= %0111			; Counter/Timer Lower Preset Reg (LSB)
00CD00  3               ;dr_mrb		= %1000			; Mode Register B (Same when Reading)
00CD00  3               dr_csrb		= %1001			; Clock Select Register B
00CD00  3               dr_crb		= %1010			; Command Register B
00CD00  3               dr_txfifob	= %1011			; Tx Holding Register B
00CD00  3               ;dr_misc	= %1100			; Miscellaneous Register (Intel mode)
00CD00  3               dr_opcr		= %1101			; Output Port Configuration Register
00CD00  3               dr_sopr		= %1110			; Set Output Port Bits Command
00CD00  3               dr_ropr		= %1111			; Reset Output Port Bits Command
00CD00  3               ;---------------------------------------
00CD00  3               ; 29L9x Registers (explained)
00CD00  3               ;---------------------------------------
00CD00  3               ;	MISC - Miscellaneous Register (Intel mode)
00CD00  3               ;
00CD00  3               ; We only explain the possible flags
00CD00  3               ;
00CD00  3               nx_misc_def	= %00000000
00CD00  3               ;		   xxxxxxxx
00CD00  3               ;		   ||||||||
00CD00  3               ;		   |||+++++---> z: Unused
00CD00  3               ;		   |||
00CD00  3               ;		   ||+--------> 1: Disable transmitter channel B
00CD00  3               ;		   |+---------> 1: Disable transmitter channel A
00CD00  3               ;		   +----------> 1: Driver initialized
00CD00  3               ;---------------
00CD00  3               ; 	ACR - Auxiliary Control Register
00CD00  3               ;---------------
00CD00  3               ;nx_acr_def	= %01100000
00CD00  3               nx_acr_def	= %11100000
00CD00  3               ;		   xxxxxxxx
00CD00  3               ;		   ||||||||
00CD00  3               ;		   |||||||+---> 1: enable IP0 IRQ
00CD00  3               ;		   ||||||+----> 1: enable IP1 IRQ
00CD00  3               ;		   |||||+-----> 1: enable IP2 IRQ
00CD00  3               ;		   ||||+------> 1: enable IP3 IRQ
00CD00  3               ;		   |+++-------> C/T setup:
00CD00  3               ;		   |
00CD00  3               ;		   |            654  Mode     Source
00CD00  3               ;		   |            -------------------------------
00CD00  3               ;		   |            000  counter  IP2
00CD00  3               ;		   |            001  counter  TxD Ch 1 1X clock
00CD00  3               ;		   |            010  counter  TxD Ch 2 1X clock
00CD00  3               ;		   |            011  counter  Xtal/16
00CD00  3               ;		   |            100  timer    IP2
00CD00  3               ;		   |            101  timer    IP2/16
00CD00  3               ;		   |            110  timer    Xtal
00CD00  3               ;		   |            111  timer    Xtal/16
00CD00  3               ;		   |            -------------------------------
00CD00  3               ;		   |
00CD00  3               ;		   +----------> 0: select BRG set #1 (38.4k max)
00CD00  3               ;		                1: select BRG set #2 (19.2k max)
00CD00  3               ;
00CD00  3               ;---------------
00CD00  3               ; 	CR - Command Register
00CD00  3               ;---------------
00CD00  3               nx_cr_rx_ena	= %00000001		; Enable receiver
00CD00  3               nx_cr_rx_dis	= %00000010		; Disable receiver
00CD00  3               ;
00CD00  3               nx_cr_tx_ena	= %00000100		; Enable transmitter
00CD00  3               nx_cr_tx_dis	= %00001000		; Disable transmitter
00CD00  3               ;
00CD00  3               nx_cr_mr1	= %00010000		; Select MR1
00CD00  3               ;
00CD00  3               nx_cr_rx_res	= %00100000		; Reset receiver
00CD00  3               nx_cr_tx_res	= %00110000		; Reset transmitter
00CD00  3               nx_cr_err_res	= %01000000		; Reset error status
00CD00  3               nx_cr_bir_res	= %01010000		; Reset Received Break Change IRQ
00CD00  3               ;
00CD00  3               nx_cr_brk_sta	= %01100000		; Start break
00CD00  3               nx_cr_brk_stp	= %01110000		; Stop break
00CD00  3               ;
00CD00  3               nx_cr_rts_ass	= %10000000		; Assert RTS
00CD00  3               nx_cr_rts_dea	= %10010000		; Deassert RTS
00CD00  3               ;
00CD00  3               nx_cr_tmr_mod	= %10100000		; Select C/T timer mode
00CD00  3               ;
00CD00  3               nx_cr_mr0	= %10110000		; Select MR0
00CD00  3               ;
00CD00  3               nx_cr_cnt_mod	= %11000000		; Select C/T counter mode
00CD00  3               ;
00CD00  3               nx_cr_pwr_dwn	= %11100000		; Power down mode	(Port A only)
00CD00  3               nx_cr_pwr_up	= %11110000		; Normal power mode	(Port A only)
00CD00  3               ;
00CD00  3               ;	Combined CR commands
00CD00  3               nx_cr_rxtx_ena	= nx_cr_rx_ena | nx_cr_tx_ena
00CD00  3               nx_cr_rxtx_dis	= nx_cr_rx_dis | nx_cr_tx_dis
00CD00  3               ;
00CD00  3               ;---------------
00CD00  3               ; 	CSR - Clock Select Register
00CD00  3               ;---------------
00CD00  3               nx_csr		= %11001100		; RxD and TxD at 38k4 baud
00CD00  3               					; MR[0] = 0 & ACR[7] = 0
00CD00  3               ;---------------
00CD00  3               ; 	CT - Counter / Timer
00CD00  3               ;---------------
00CD00  3               nx_cnt_lo	= <(nx_ct_scale/hz)	; Underflows/sec LSB
00CD00  3               nx_cnt_hi	= >(nx_ct_scale/hz)	; Underflows/sec MSB
00CD00  3               ;
00CD00  3               ;---------------
00CD00  3               ; 	IMR - Interrupt Mask Register
00CD00  3               ;---------------
00CD00  3               					; Enable channel A RxD and TxD IRQs
00CD00  3               nx_irq_a	= msk_irq_txa | msk_irq_rxa
00CD00  3               					; Enable channel B RxD and TxD IRQs
00CD00  3               nx_irq_b	= msk_irq_txb | msk_irq_rxb
00CD00  3               					; Set IRQ Sources (Port A, B and C/T)
00CD00  3               nx_irq_msk	= nx_irq_a | nx_irq_b | msk_irq_ct
00CD00  3               ;
00CD00  3               ;---------------
00CD00  3               ; 	MR0 - Mode 0 Register
00CD00  3               ;---------------
00CD00  3               nx_mr0		= %11001000
00CD00  3               ;		   ||||||||
00CD00  3               ;		   |||||+++----> Baud rate: Normal mode
00CD00  3               ;		   ||||+-------> 16-deep FIFO
00CD00  3               ;		   ||++--------> TxD interrupts only when FIFO is empty
00CD00  3               ;		   |+----------> RxD interrupts only when FIFO is full
00CD00  3               ;		   |             (also see MR1[6])
00CD00  3               ;		   +-----------> Enable RxD watchdog timer
00CD00  3               ;
00CD00  3               ;---------------
00CD00  3               ; 	MR1 - Mode 1 Register
00CD00  3               ;---------------
00CD00  3               nx_mr1		= %11010011
00CD00  3               ;		   ||||||||
00CD00  3               ;		   ||||||++----> 8 bit character size
00CD00  3               ;		   |||||+------> Parity type (ignored)
00CD00  3               ;		   |||++-------> No parity generated or checked
00CD00  3               ;		   ||+---------> Character error mode
00CD00  3               ;		   |+----------> RxD interrupts only when FIFO is full
00CD00  3               ;		   |		 (See also MR0[6]
00CD00  3               ;		   +-----------> RxD controls RTS
00CD00  3               ;
00CD00  3               ;---------------
00CD00  3               ; 	MR2 - Mode 2 Register
00CD00  3               ;---------------
00CD00  3               nx_mr2		= %00010111		; Normal mode, auto RTS
00CD00  3               ;		   ||||||||
00CD00  3               ;		   ||||++++---> stop bit length
00CD00  3               ;		   ||||
00CD00  3               ;		   |||+-------> TxD CTS mode:  	 0: off
00CD00  3               ;		   |||                         	 1: on
00CD00  3               ;		   ||+--------> TxD RTS mode:  	 0: off
00CD00  3               ;		   ||                          	 1: on
00CD00  3               ;		   ++---------> channel mode: 	00: normal
00CD00  3               ;	           		                01: auto echo
00CD00  3               ;	                           		10: local loop
00CD00  3               ;	                           		11: remote loop
00CD00  3               ;
00CD00  3               ;---------------
00CD00  3               ; 	OPCR - Output Port Configuration Register
00CD00  3               ;---------------
00CD00  3               nx_opcr_def	= %11110000		; OP4-7 as IRQ outputs
00CD00  3               
00CD00  3               
00CD00  3               
00CD00  2               	.include	"hardware/NXP28L92/nx_frontend.asm"
00CD00  3               ;===============================================================================
00CD00  3               ;   A D R I A   - Philips/NXP 28L9x Front-end Test routine(s)
00CD00  3               ;
00CD00  3               ; 	This source file holds the front-end routine(s) for the
00CD00  3               ;	Philips/NXP 28L9x IC.
00CD00  3               ;
00CD00  3               ;	Version history:
00CD00  3               ;		26 jan 2021 	- Inital version
00CD00  3               ;		18 feb 2021 	- Userland driver seems to work, migrating to
00CD00  3               ;				  ROM based driver
00CD00  3               ;===============================================================================
00CD00  3               ; Process Receive Request
00CD00  3               ;
00CD00  3               ; Call the subroutine and the routine will try to "get" a datum from the
00CD00  3               ; corresponding RxQ. If this succeeds, the routine will return:
00CD00  3               ;	.A	- valid datum
00CD00  3               ;	carry	- clear
00CD00  3               ;
00CD00  3               ; If no datum is present in the RxQ, the routine will return:
00CD00  3               ;	.A	- unchanged
00CD00  3               ;	carry	- set
00CD00  3               ;
00CD00  3               ; NOTE: Carry will also be returned set, if the driver hasn't been initialized,
00CD00  3               ;	yet...
00CD00  3               ;-------------------------------------------------------------------------------
00CD00  3               ; nx_sioget_a - Process datum from channel A RxQ
00CD00  3               ;-----------------------
00CD00  3               uart_scan:
00CD00  3               nx_sioget_a:
00CD00  3  E2 30        	shortr				; Make sure we are in 8-bit registers
00CD02  3  38           	sec				; Default: assume error
00CD03  3  2C 2C C0     	bit	NX_IOBASE + dr_misc	; Read bit 7 of dr_misc, if set, driver
00CD06  3               					; has been initialized
00CD06  3  10 19        	bpl	@done			; No, error
00CD08  3               ;
00CD08  3  DA           	phx				; Save .X
00CD09  3  AE 65 00     	ldx	nx_rx_get_a		; RxD "get" index
00CD0C  3  EC 67 00     	cpx	nx_rx_put_a		; Compare with RxD "put" index
00CD0F  3  F0 0F        	beq	@no_datum		; No datum available
00CD11  3               ;
00CD11  3  BD 00 20     	lda	nx_rx_qa, X		; Get datum from queue
00CD14  3  EB           	xba				; Move .A to .B
00CD15  3  AD 65 00     	lda	nx_rx_get_a		; Get "get" index
00CD18  3  1A           	inc	a			; bump "get" index
00CD19  3  29 7F        	and	#buf_idx_mask		; Deal with wrap
00CD1B  3  8D 65 00     	sta	nx_rx_get_a		; Store new "get" index
00CD1E  3  EB           	xba				; Restore datum to .A (from .B)
00CD1F  3               ;	inc	nx_rx_get_a		; Increment "get" index
00CD1F  3  18           	clc				; Clear error (carry)
00CD20  3               ;
00CD20  3               @no_datum:
00CD20  3  FA           	plx				; Restore .X
00CD21  3               ;
00CD21  3               @done:
00CD21  3  60           	rts
00CD22  3               ;===============================================================================
00CD22  3               ; Process Receive Request (blocking)
00CD22  3               ;
00CD22  3               ; Call the subroutine and the routine will try to "get" a datum from the
00CD22  3               ; corresponding RxQ. If this succeeds, the routine will return:
00CD22  3               ;	.A	- valid datum
00CD22  3               ;
00CD22  3               ; If no datum is present in the RxQ (yet), the routine loop until there is
00CD22  3               ;-------------------------------------------------------------------------------
00CD22  3               ; nx_sioget_a_block - Read datum Channel A RxQ, blocks when no data is available
00CD22  3               ;-----------------------
00CD22  3               uart_input:
00CD22  3               nx_sioget_a_block:
00CD22  3  E2 30        	shortr
00CD24  3  2C 2C C0     	bit	NX_IOBASE + dr_misc	; Is the driver initialized?
00CD27  3  10 18        	bpl	@done			; Nope, just return!
00CD29  3               ;
00CD29  3  DA           	phx				; Save .X
00CD2A  3               @try:
00CD2A  3  AE 65 00     	ldx	nx_rx_get_a		; get "get" index
00CD2D  3  EC 67 00     	cpx	nx_rx_put_a		; Same as "put" index"
00CD30  3  F0 F8        	beq	@try			; If no new datum, retry ...
00CD32  3               ;	bne	@datum			; No, process datum
00CD32  3               ;					; Otherwise, waste some time waiting
00CD32  3               ;	bra	@try
00CD32  3               ;
00CD32  3               @datum:
00CD32  3  BD 00 20     	lda	nx_rx_qa, X
00CD35  3  EB           	xba				; Save datum to .B
00CD36  3  AD 65 00     	lda	nx_rx_get_a		; Get current "get" index
00CD39  3  1A           	inc	a			; Bump index
00CD3A  3  29 7F        	and	#buf_idx_mask		; Deal with wrap
00CD3C  3  8D 65 00     	sta	nx_rx_get_a		; Save new "get" index
00CD3F  3  EB           	xba				; Restore datum from .B
00CD40  3               ;	inc	nx_rx_get_a
00CD40  3               
00CD40  3  FA           	plx				; Restore .X
00CD41  3               @done:
00CD41  3  60           	rts
00CD42  3               
00CD42  3               ;
00CD42  3               ;-----------------------
00CD42  3               ; nx_sioget_b - Process datum from channel B RxQ
00CD42  3               ;-----------------------
00CD42  3               nx_sioget_b:
00CD42  3  E2 30        	shortr				; Make sure we are in 8-bit registers
00CD44  3  38           	sec				; Default: assume error
00CD45  3  2C 2C C0     	bit	NX_IOBASE + dr_misc	; Read bit 7 of dr_misc, if set, driver
00CD48  3               					; has been initialized
00CD48  3  10 11        	bpl	@done			; No, error
00CD4A  3               ;
00CD4A  3  DA           	phx				; Save .X
00CD4B  3  AE 69 00     	ldx	nx_rx_get_b		; RxD "get" index
00CD4E  3  EC 6B 00     	cpx	nx_rx_put_b		; Compare with RxD "put" index
00CD51  3  F0 07        	beq	@no_datum		; No datum available
00CD53  3               ;
00CD53  3  BD 00 21     	lda	nx_rx_qb, X		; Get datum from queue
00CD56  3  EE 69 00     	inc	nx_rx_get_b		; Increment "get" index
00CD59  3  18           	clc				; Clear error (carry)
00CD5A  3               ;
00CD5A  3               @no_datum:
00CD5A  3  FA           	plx				; Restore .X
00CD5B  3               ;
00CD5B  3               @done:
00CD5B  3  60           	rts
00CD5C  3               ;
00CD5C  3               ;-------------------------------------------------------------------------------
00CD5C  3               ; Process Transmit Request
00CD5C  3               ;
00CD5C  3               ; Call the subroutine and the routine will try to "put" a datum into the
00CD5C  3               ; corresponding TxQ. If this succeeds, the routine will return:
00CD5C  3               ;	carry	- clear
00CD5C  3               ;
00CD5C  3               ; NOTE: Carry will be set, if the driver hasn't been initialized,
00CD5C  3               ;	yet...
00CD5C  3               ;-------------------------------------------------------------------------------
00CD5C  3               ; nx_sioput_a - Process datum for channel A TxQ
00CD5C  3               ;-----------------------
00CD5C  3               uart_output:
00CD5C  3               nx_sioput_a:
00CD5C  3  08           	php
00CD5D  3  E2 30        	shortr				; 8 bit registers
00CD5F  3  38           	sec				; Default, assume error
00CD60  3  2C 2C C0     	bit	NX_IOBASE + dr_misc	; Read bit 7 of dr_misc, if set, driver
00CD63  3               					; has been initialized
00CD63  3  10 28        	bpl	@done			; No, error!
00CD65  3               ;
00CD65  3  48           	pha				; Preserve .A
00CD66  3  DA           	phx				; Preserve .X
00CD67  3               ;
00CD67  3  EB           	xba				; Save datum to .B
00CD68  3               ;
00CD68  3  AD 68 00     	lda	nx_tx_put_a		; Get TxD "put" index
00CD6B  3  1A           	ina				; Increment "put" index
00CD6C  3  29 7F        	and	#buf_idx_mask		; Deal with wrap
00CD6E  3               ;
00CD6E  3               @full:					; Loop here until there is space in TxQ
00CD6E  3  CD 66 00     	cmp	nx_tx_get_a		; TxQ "get" index
00CD71  3  F0 FB        	beq	@full			; TxQ is full, block...
00CD73  3               ;
00CD73  3  AE 68 00     	ldx	nx_tx_put_a
00CD76  3  EB           	xba				; Restore datum in .A, save new "put"
00CD77  3  9D 80 20     	sta	nx_tx_qa, X		; Put datum into TxQ
00CD7A  3  EB           	xba				; Retrieve new "put" index from .B
00CD7B  3  8D 68 00     	sta	nx_tx_put_a
00CD7E  3               ;
00CD7E  3               ;	ldx	nx_tx_put_a		; TxQ "put" index
00CD7E  3               ;	inx
00CD7E  3               ;
00CD7E  3               ;@full:
00CD7E  3               ;	cpx	nx_tx_get_a		; TxQ "get" index
00CD7E  3               ;	beq	@full			; TxQ is full, block...
00CD7E  3               ;
00CD7E  3               ;	dex				; Realign "put" index and ...
00CD7E  3               ;	sta	nx_tx_qa, X		; ... put datum into TxQ
00CD7E  3               ;	inc	nx_tx_put_a		; Bump "put" index
00CD7E  3               ;
00CD7E  3               ;---------------
00CD7E  3               ;	Manage transmitter
00CD7E  3               ;---------------
00CD7E  3  A9 40        	lda	#nx_txa_dis		; Transmitter disabled flag
00CD80  3  1C 2C C0     	trb	NX_IOBASE + dr_misc	; is transmitter disabled?
00CD83  3  F0 05        	beq	@cleanup		; No
00CD85  3               
00CD85  3  A9 04        	lda	#nx_cr_tx_ena		; Yes, enable transmitter
00CD87  3  8D 22 C0     	sta	NX_IOBASE + dr_cra
00CD8A  3               ;
00CD8A  3               @cleanup:
00CD8A  3  FA           	plx
00CD8B  3  68           	pla
00CD8C  3  18           	clc
00CD8D  3               ;
00CD8D  3               @done:
00CD8D  3  28           	plp				; Restore .SR
00CD8E  3  60           	rts
00CD8F  3               ;
00CD8F  3               ;-----------------------
00CD8F  3               ; nx_sioput_b - Process datum from channel B TxQ
00CD8F  3               ;-----------------------
00CD8F  3               nx_sioput_b:
00CD8F  3  08           	php
00CD90  3  E2 30        	shortr				; 8 bit registers
00CD92  3  38           	sec				; Default, assume error
00CD93  3  2C 2C C0     	bit	NX_IOBASE + dr_misc	; Read bit 7 of dr_misc, if set, driver
00CD96  3               					; has been initialized
00CD96  3  10 28        	bpl	@done			; No, error!
00CD98  3               ;
00CD98  3  48           	pha				; Preserve .A
00CD99  3  DA           	phx				; Preserve .X
00CD9A  3               ;
00CD9A  3  EB           	xba				; Save datum to .B
00CD9B  3               ;
00CD9B  3  AD 6C 00     	lda	nx_tx_put_b		; Get TxD "put" index
00CD9E  3  1A           	inc	a			; Increment "put" index
00CD9F  3  29 7F        	and	#buf_idx_mask		; Deal with wrap
00CDA1  3               ;
00CDA1  3               @full:					; Loop here until there is space in TxQ
00CDA1  3  CD 6A 00     	cmp	nx_tx_get_b		; TxQ "get" index
00CDA4  3  F0 FB        	beq	@full			; TxQ is full, block...
00CDA6  3               ;
00CDA6  3  AE 6C 00     	ldx	nx_tx_put_b
00CDA9  3  EB           	xba				; Restore datum in .A, save new "put"
00CDAA  3  9D 80 21     	sta	nx_tx_qb, X		; Put datum into TxQ
00CDAD  3  EB           	xba				; Retrieve new "put" index from .B
00CDAE  3  8D 6C 00     	sta	nx_tx_put_b
00CDB1  3               ;
00CDB1  3               ;---------------
00CDB1  3               ;	Manage transmitter
00CDB1  3               ;---------------
00CDB1  3  A9 20        	lda	#nx_txb_dis		; Transmitter disabled flag
00CDB3  3  1C 2C C0     	trb	NX_IOBASE + dr_misc	; is transmitter disabled?
00CDB6  3  F0 05        	beq	@cleanup		; No
00CDB8  3               
00CDB8  3  A9 04        	lda	#nx_cr_tx_ena		; Yes, enable transmitter
00CDBA  3  8D 2A C0     	sta	NX_IOBASE + dr_crb
00CDBD  3               ;
00CDBD  3               @cleanup:
00CDBD  3  FA           	plx
00CDBE  3  68           	pla
00CDBF  3  18           	clc
00CDC0  3               ;
00CDC0  3               @done:
00CDC0  3  28           	plp				; Restore .SR
00CDC1  3  60           	rts
00CDC2  3               ;
00CDC2  3               ;-------------------------------------------------------------------------------
00CDC2  3               ; UART Channel B Control
00CDC2  3               ;
00CDC2  3               ; Enable/disable channel based on carry value. Routine is based (copied ;)) from
00CDC2  3               ; BDD's SBC POCv1 ROM
00CDC2  3               ;
00CDC2  3               ; carry = 1	=> Enable channel B
00CDC2  3               ; carry = 0	=> Disable channel B
00CDC2  3               ;-------------------------------------------------------------------------------
00CDC2  3               nx_chan_b_ctl:
00CDC2  3  E2 20        	shorta
00CDC4  3  90 04        	bcc	nx_dis_chanb		; If carry is cleared, disable channel B
00CDC6  3               ;
00CDC6  3               nx_ena_chanb:
00CDC6  3  A9 85        	lda	#(nx_cr_rxtx_ena | nx_cr_rts_ass)
00CDC8  3  80 02        	bra	nx_chanctl		; Write to DUART command register
00CDCA  3               ;
00CDCA  3               nx_dis_chanb:
00CDCA  3  A9 9A        	lda	#(nx_cr_rxtx_dis | nx_cr_rts_dea)
00CDCC  3               ;
00CDCC  3               nx_chanctl:
00CDCC  3  8D 2A C0     	sta	NX_IOBASE + dr_crb	; Save to Command Register channel B
00CDCF  3  CB           	wai				; We have to wait two /IRQs?
00CDD0  3  CB           	wai
00CDD1  3  60           	rts
00CDD2  3               
00CDD2  2               ;
00CDD2  2               ; Interrupt Service handler has been moved to the "generic" ROM environment
00CDD2  2               ;	.include	"interrupt.asm"
00CDD2  2               	.include	"hardware/NXP28L92/nx_init.asm"
00CDD2  3               ;===============================================================================
00CDD2  3               ;   A D R I A   - Philips/NXP 28L9x Initialization routine(s)
00CDD2  3               ;
00CDD2  3               ; 	This source file holds the initialization routine(s) for the
00CDD2  3               ;	Philips/NXP 28L9x IC.
00CDD2  3               ;
00CDD2  3               ;	Version history:
00CDD2  3               ;		26 jan 2021 	- Inital version
00CDD2  3               ;		18 feb 2021 	- Userland driver seems to work, migrating to
00CDD2  3               ;				  ROM based driver
00CDD2  3               ;===============================================================================
00CDD2  3               ; nx_init - Initialize 28L9x environment
00CDD2  3               ;
00CDD2  3               ; Will read the configuration parameters from the table (bottom-up) and write
00CDD2  3               ; them to the 29L9x.
00CDD2  3               ;
00CDD2  3               ; Currently the table is made for the 28L92 (2 ports), but this can be extended
00CDD2  3               ; to the 8-port variant.
00CDD2  3               ;
00CDD2  3               ; Returns with carry cleared.
00CDD2  3               ;-------------------------------------------------------------------------------
00CDD2  3               uart_init:
00CDD2  3               nx_init:
00CDD2  3  E2 30        	shortr
00CDD4  3  78           	sei				; Disable interrupts until done
00CDD5  3               ;---------------------------------------
00CDD5  3               ; We use register $0C (dr_misc) of the 28L9x as temporary storage
00CDD5  3               ; and to indicate the driver initialization has succeeded. Initially we zero
00CDD5  3               ; this register
00CDD5  3  9C 2C C0     	stz	NX_IOBASE + dr_misc
00CDD8  3               ;
00CDD8  3               ; Clear used/reserved zeropage (DP) locations
00CDD8  3               ;---------------------------------------
00CDD8  3  A2 00        	ldx	#$00
00CDDA  3               @nextZP:
00CDDA  3  74 60        	stz	nx_zeropage, X
00CDDC  3  E8           	inx
00CDDD  3  E0 20        	cpx	#$20			; Reserve $20 (32) bytes and clear these
00CDDF  3  D0 F9        	bne	@nextZP
00CDE1  3               ;
00CDE1  3               ; Clear RxQ and TxQ buffer space
00CDE1  3  C2 10        	longi				; We use 16-bit index registers
00CDE3  3  A2 00 00     	ldx	#$0000
00CDE6  3               @nextBuf:
00CDE6  3  9E 00 20     	stz	nx_q_base, X		; Clear buffer space with $00
00CDE9  3  E8           	inx
00CDEA  3  E0 00 02     	cpx	#$0200			; 4 * $80
00CDED  3  D0 F7        	bne	@nextBuf
00CDEF  3  E2 10        	shorti				; And don't forget to return to 8-bit
00CDF1  3               ;
00CDF1  3               ; Prepare jiffy counter
00CDF1  3               ;---------------------------------------
00CDF1  3  A9 64        	lda	#hz
00CDF3  3  85 60        	sta	nx_jiffycnt
00CDF5  3               ;
00CDF5  3               ; Set up the 28L9x IC using the setup/lookup table
00CDF5  3               ;---------------------------------------
00CDF5  3  A0 42        	ldy	#size_l92_suTable - 2	; Get size of setup/lookup table
00CDF7  3               @setup:
00CDF7  3  BE 12 CE     	ldx	l92_suTable, Y		; Read register offset
00CDFA  3  B9 13 CE     	lda	l92_suTable + s_byte, Y	; Read register parameter
00CDFD  3               ;
00CDFD  3  9D 20 C0     	sta	NX_IOBASE, X		; Write to register
00CE00  3               ;
00CE00  3  88           	dey				; As we use two bytes per register, ...
00CE01  3  88           	dey				; ... we have to decrement .Y by 2
00CE02  3  10 F3        	bpl	@setup			; Continue until we have reached top
00CE04  3               
00CE04  3               ; Only used when debugging/userland
00CE04  3               .if NX_USERDRIVER = 1
00CE04  3               ; before we return, just point to our IRQ handler (when in userland!)
00CE04  3               	longr
00CE04  3               	lda	VECTOR_INT		; Get original /IRQ vector
00CE04  3               	sta	rom_irq			; Save it for later
00CE04  3               ;
00CE04  3               	lda	#nx_irq			; Install our new /IRQ vector
00CE04  3               	tax
00CE04  3               	eor	#$DEAD			; Calculate checksum (force invalid for
00CE04  3               					; now)
00CE04  3               	sta	CHKSUM_INT		; Store the checksum
00CE04  3               	stx	VECTOR_INT		; Save the new vector
00CE04  3               ;
00CE04  3               	shortr				; 8 bit registers
00CE04  3               .endif
00CE04  3               ;
00CE04  3               ; Before we return we have to start the counter by reading IOBASE + dr_cnt_start
00CE04  3               ; As BDD mentioned, it might be safer to use a BIT instruction
00CE04  3               ;	lda	IOBASE + dr_cnt_start
00CE04  3  2C 2E C0     	bit	NX_IOBASE + dr_cnt_start
00CE07  3               ;
00CE07  3               ; Now we should get a 100Hz ticker and by enabling the interrupts (below), we
00CE07  3               ; should now have a 0.01 second clock timer ;)
00CE07  3               ;
00CE07  3               ; Before returning, set the nx_driver_init flag
00CE07  3  A9 80        	lda	#nx_driver_init
00CE09  3  0C 2C C0     	tsb	NX_IOBASE + dr_misc	; Store this is the dr_misc register
00CE0C  3  0C 6D 00     	tsb	nx_tx_status
00CE0F  3               ;
00CE0F  3  58           	cli				; Enable interrupts
00CE10  3  18           	clc				; C is cleared, no error
00CE11  3  60           	rts
00CE12  3               ;
00CE12  3               
00CE12  2               	.include	"hardware/NXP28L92/nx_tables.asm"
00CE12  3               ;===============================================================================
00CE12  3               ;   A D R I A   - Philips/NXP 28L9x Fixed data/reference/lookup tables
00CE12  3               ;
00CE12  3               ;	Version history:
00CE12  3               ;		26 jan 2021 - Inital version
00CE12  3               ;		08 feb 2020 - Changed Counter mode to Timer mode
00CE12  3               ;===============================================================================
00CE12  3               ; l92_suTable - 28L9x initialization sequence for two (2) ports
00CE12  3               ;---------------------------------------
00CE12  3               l92_suTable:				; Philip/NXP 28L9x Initialization Table
00CE12  3               ;
00CE12  3               ; vvv  DEBUG  vvv
00CE12  3               ; Disabled IRQ for now, we have to start them manually)
00CE12  3  05 3B        	.byte	dr_imr, nx_irq_msk	; IMR (Enable IRQs)
00CE14  3               ;	.byte	dr_imr, msk_irq_ct	; For testing, only enable CT IRQs
00CE14  3               ; ^^^  DEBUG  ^^^
00CE14  3               ;
00CE14  3  06 48        	.byte	dr_ctu, nx_cnt_hi	; CTU
00CE16  3  07 00        	.byte	dr_ctl, nx_cnt_lo	; CTL
00CE18  3               
00CE18  3  0A 0A        	.byte	dr_crb, nx_cr_rxtx_dis	; CRB - Disable RxD and TxD
00CE1A  3               ;---------------------------------------
00CE1A  3               ; Port B will be disabled, for now!
00CE1A  3               ;---------------------------------------
00CE1A  3               ;
00CE1A  3  09 CC        	.byte	dr_csrb, nx_csr		; CSR - Set Clock Register
00CE1C  3  08 17        	.byte	dr_mrb, nx_mr2		; MR2 - Set Mode Register 2
00CE1E  3  08 D3        	.byte	dr_mrb, nx_mr1		; MR1 - Set Mode Register 1
00CE20  3  0A 10        	.byte	dr_crb, nx_cr_mr1	; CRA - Select Mode Register 1
00CE22  3  08 C8        	.byte	dr_mrb, nx_mr0		; MR0 - Set Memory Register 0
00CE24  3  0A B0        	.byte	dr_crb, nx_cr_mr0	; CRA - Select Mode Register 0
00CE26  3               ;---------------------------------------
00CE26  3               ; Port B
00CE26  3               ;---------------------------------------
00CE26  3               ;
00CE26  3  02 80        	.byte	dr_cra, nx_cr_rts_ass	; CRA - Assert RTS
00CE28  3  02 05        	.byte	dr_cra, nx_cr_rxtx_ena	; CRA - Enable RxD and TxD
00CE2A  3               
00CE2A  3               ;	.byte	dr_cra, nx_cr_rxtx_dis	; CRA - For now, disable RxD and TxD
00CE2A  3               ;
00CE2A  3               ;---------------------------------------
00CE2A  3               ; Enable port A
00CE2A  3               ;---------------------------------------
00CE2A  3               ;
00CE2A  3  01 CC        	.byte	dr_csra, nx_csr		; CSR - Set Clock Register
00CE2C  3  00 17        	.byte	dr_mra, nx_mr2		; MR2 - Set Mode Register 2
00CE2E  3  00 D3        	.byte	dr_mra, nx_mr1		; MR1 - Set Mode Register 1
00CE30  3  02 10        	.byte	dr_cra, nx_cr_mr1	; CRA - Select Mode Register 1
00CE32  3  00 C8        	.byte	dr_mra, nx_mr0		; MR0 - Set Memory Register 0
00CE34  3  02 B0        	.byte	dr_cra, nx_cr_mr0	; CRA - Select Mode Register 0
00CE36  3               ;---------------------------------------
00CE36  3               ; Port A
00CE36  3               ;---------------------------------------
00CE36  3               ;
00CE36  3  04 E0        	.byte	dr_acr, nx_acr_def	; ACR - Auxiliary Control Register
00CE38  3               ;---------------------------------------
00CE38  3               ; ACR
00CE38  3               ;---------------------------------------
00CE38  3               ;
00CE38  3  0D F0        	.byte	dr_opcr, nx_opcr_def	; OPCR - Output Port Configuration Reg
00CE3A  3               ;---------------------------------------
00CE3A  3               ; OPCR
00CE3A  3               ;---------------------------------------
00CE3A  3               ;
00CE3A  3  0A C0        	.byte	dr_crb, nx_cr_cnt_mod 	; CRB - Select C/T Counter mode
00CE3C  3  0A 40        	.byte	dr_crb, nx_cr_err_res	; CRB - Reset error status
00CE3E  3  0A 50        	.byte	dr_crb, nx_cr_bir_res	; CRB - Reset Received Break Change IRQ
00CE40  3  0A 30        	.byte	dr_crb, nx_cr_tx_res	; CRB - Reset transmitter
00CE42  3  0A 20        	.byte	dr_crb, nx_cr_rx_res	; CRB - Reset receiver
00CE44  3  0A 90        	.byte	dr_crb, nx_cr_rts_dea 	; CRB - Deassert RTS
00CE46  3               ;---------------------------------------
00CE46  3               ; Init port B
00CE46  3               ;---------------------------------------
00CE46  3               
00CE46  3  02 C0        	.byte	dr_cra, nx_cr_cnt_mod 	; CRA - Select C/T Counter mode
00CE48  3  02 40        	.byte	dr_cra, nx_cr_err_res	; CRA - Reset error status
00CE4A  3  02 50        	.byte	dr_cra, nx_cr_bir_res	; CRA - Reset Received Break Change IRQ
00CE4C  3  02 30        	.byte	dr_cra, nx_cr_tx_res	; CRA - Reset transmitter
00CE4E  3  02 20        	.byte	dr_cra, nx_cr_rx_res	; CRA - Reset receiver
00CE50  3  02 90        	.byte	dr_cra, nx_cr_rts_dea 	; CRA - Deassert RTS
00CE52  3               ;---------------------------------------
00CE52  3               ; Init port A
00CE52  3               ;---------------------------------------
00CE52  3               ;
00CE52  3  05 00        	.byte	dr_imr, $00		; IMR - Disable IRQs
00CE54  3  02 F0        	.byte	dr_cra, nx_cr_pwr_up	; CRA - Power up
00CE56  3               ;---------------------------------------
00CE56  3               ; Size of table
00CE56  3               ;---------------------------------------
00CE56  3               size_l92_suTable	= * - l92_suTable
00CE56  3               ;
00CE56  3               ;***********************
00CE56  3               ; DEBUG, remove when done!
00CE56  3               ;***********************
00CE56  3  44 00        	.word	size_l92_suTable
00CE58  3  00 48        	.word	nx_ct_scale/hz
00CE5A  3  00           	.byte	<(nx_ct_scale/hz)
00CE5B  3  48           	.byte	>(nx_ct_scale/hz)
00CE5C  3               ;
00CE5C  3  60           	.byte	nx_jiffycnt
00CE5D  3  61           	.byte	nx_uptimecnt
00CE5E  3  65           	.byte	nx_rx_get_a
00CE5F  3  67           	.byte	nx_rx_put_a
00CE60  3  66           	.byte	nx_tx_get_a
00CE61  3  68           	.byte	nx_tx_put_a
00CE62  3  6D           	.byte	nx_tx_status
00CE63  3  6E           	.byte	rom_irq
00CE64  3               
00CE64  2               ;
00CE64  2               ;---------------------------------------
00CE64  2               ; Used to calculate memory footprint of the module
00CE64  2               ;---------------------------------------
00CE64  2               ; End of routines
00CE64  2               ; Calculation of usage
00CE64  2               _uart_end	=	*
00CE64  2               _uart_size 	=	_uart_end - UART_DRIVER
00CE64  2               	.out .concat("UART driver                       $", .sprintf("%04x", UART_DRIVER), "      $", .sprintf("%04x", _uart_end), "    $", .sprintf("%04x", _uart_size), "  (", .sprintf("%05d", _uart_size), ")")
00CE64  2               ;	.out	.concat("---- Size of UART (28L92) routines:   $", .sprintf("%04x", _uart_size), "(", .sprintf("%05d", _uart_size), ")")
00CE64  2               ;=======================================================================
00CE64  2               
00CE64  1               
00CE64  1               ; Intel Hex Uploader
00CE64  1               _incl_intel:
00CE64  1  00 00 00 00  	.res		HEXINTEL - *, $00
00CE68  1  00 00 00 00  
00CE6C  1  00 00 00 00  
00CE70  1  00 00 00 00  
00CE74  1  00 00 00 00  
00CE78  1  00 00 00 00  
00CE7C  1  00 00 00 00  
00CE80  1  00 00 00 00  
00CE84  1  00 00 00 00  
00CE88  1  00 00 00 00  
00CE8C  1  00 00 00 00  
00CE90  1  00 00 00 00  
00CE94  1  00 00 00 00  
00CE98  1  00 00 00 00  
00CE9C  1  00 00 00 00  
00CEA0  1  00 00 00 00  
00CEA4  1  00 00 00 00  
00CEA8  1  00 00 00 00  
00CEAC  1  00 00 00 00  
00CEB0  1  00 00 00 00  
00CEB4  1  00 00 00 00  
00CEB8  1  00 00 00 00  
00CEBC  1  00 00 00 00  
00CEC0  1  00 00 00 00  
00CEC4  1  00 00 00 00  
00CEC8  1  00 00 00 00  
00CECC  1  00 00 00 00  
00CED0  1  00 00 00 00  
00CED4  1  00 00 00 00  
00CED8  1  00 00 00 00  
00CEDC  1  00 00 00 00  
00CEE0  1  00 00 00 00  
00CEE4  1  00 00 00 00  
00CEE8  1  00 00 00 00  
00CEEC  1  00 00 00 00  
00CEF0  1  00 00 00 00  
00CEF4  1  00 00 00 00  
00CEF8  1  00 00 00 00  
00CEFC  1  00 00 00 00  
00CF00  1  00 00 00 00  
00CF04  1  00 00 00 00  
00CF08  1  00 00 00 00  
00CF0C  1  00 00 00 00  
00CF10  1  00 00 00 00  
00CF14  1  00 00 00 00  
00CF18  1  00 00 00 00  
00CF1C  1  00 00 00 00  
00CF20  1  00 00 00 00  
00CF24  1  00 00 00 00  
00CF28  1  00 00 00 00  
00CF2C  1  00 00 00 00  
00CF30  1  00 00 00 00  
00CF34  1  00 00 00 00  
00CF38  1  00 00 00 00  
00CF3C  1  00 00 00 00  
00CF40  1  00 00 00 00  
00CF44  1  00 00 00 00  
00CF48  1  00 00 00 00  
00CF4C  1  00 00 00 00  
00CF50  1  00 00 00 00  
00CF54  1  00 00 00 00  
00CF58  1  00 00 00 00  
00CF5C  1  00 00 00 00  
00CF60  1  00 00 00 00  
00CF64  1  00 00 00 00  
00CF68  1  00 00 00 00  
00CF6C  1  00 00 00 00  
00CF70  1  00 00 00 00  
00CF74  1  00 00 00 00  
00CF78  1  00 00 00 00  
00CF7C  1  00 00 00 00  
00CF80  1  00 00 00 00  
00CF84  1  00 00 00 00  
00CF88  1  00 00 00 00  
00CF8C  1  00 00 00 00  
00CF90  1  00 00 00 00  
00CF94  1  00 00 00 00  
00CF98  1  00 00 00 00  
00CF9C  1  00 00 00 00  
00CFA0  1  00 00 00 00  
00CFA4  1  00 00 00 00  
00CFA8  1  00 00 00 00  
00CFAC  1  00 00 00 00  
00CFB0  1  00 00 00 00  
00CFB4  1  00 00 00 00  
00CFB8  1  00 00 00 00  
00CFBC  1  00 00 00 00  
00CFC0  1  00 00 00 00  
00CFC4  1  00 00 00 00  
00CFC8  1  00 00 00 00  
00CFCC  1  00 00 00 00  
00CFD0  1  00 00 00 00  
00CFD4  1  00 00 00 00  
00CFD8  1  00 00 00 00  
00CFDC  1  00 00 00 00  
00CFE0  1  00 00 00 00  
00CFE4  1  00 00 00 00  
00CFE8  1  00 00 00 00  
00CFEC  1  00 00 00 00  
00CFF0  1  00 00 00 00  
00CFF4  1  00 00 00 00  
00CFF8  1  00 00 00 00  
00CFFC  1  00 00 00 00  
00D000  1               	.include	"apps/hexintel.asm"
00D000  2               ;
00D000  2               ;  Adria Intel Hex Uploader
00D000  2               ;
00D000  2               ;  Version history:
00D000  2               ;	2020-09-09	- Initial version, for use with Supermon816 monitor
00D000  2               ;	25 feb 2021	- Consolidate ZP usage (try to make it one block)
00D000  2               ;
00D000  2               ; This Intel Hex Downloader is based on/copied from/written by Ross Archer
00D000  2               ;==============================================================================
00D000  2               ; (Additional assembler/linker directives
00D000  2               	.listbytes	255
00D000  2               	.p816
00D000  2               
00D000  2               	.org	HEXINTEL
00D000  2               
00D000  2               ; Equates
00D000  2               DPL		= $70			; $70 - Data pointer (two bytes)
00D000  2               DPH		= DPL + s_byte		; $71 - High byte of data pointer
00D000  2               RECLEN		= DPH + s_byte		; $72 - Record length in bytes
00D000  2               START_LO	= RECLEN + s_byte	; $73 - Low byte start address record
00D000  2               START_HI	= START_LO + s_byte	; $74 - High byte start address record
00D000  2               RECTYPE		= START_HI + s_byte	; $75 - Record type
00D000  2               RECCHKSUM	= RECTYPE + s_byte	; $76 - Record checksum accumulator
00D000  2               DLFAIL		= RECCHKSUM + s_byte	; $77 - Flag for download failure
00D000  2               TEMP		= DLFAIL + s_byte	; $78 - Save temporary hex value
00D000  2               PROG_START	= TEMP + s_byte		; $79 - Program start address
00D000  2               
00D000  2               strtintel:
00D000  2  9C 77 00     	stz	DLFAIL			; Start by assuming no failure (yet)
00D003  2  9C 79 00     	stz	PROG_START
00D006  2  9C 7A 00     	stz	PROG_START + 1
00D009  2               
00D009  2  F4 02 D1     	pea	mm_strt			; Print prompt
00D00C  2  20 D9 DF     	jsr	sprint
00D00F  2               
00D00F  2               
00D00F  2               hdwrecs:
00D00F  2  20 10 FD     	jsr	char_in			; Get data from ACIA
00D012  2  C9 03        	cmp	#$03			; Did we get a <Ctrl-C>
00D014  2  D0 0B        	bne	@a
00D016  2  C9 1B        	cmp	#ESC			; Did we get an <Esc>
00D018  2  D0 07        	bne	@a
00D01A  2               
00D01A  2  F4 E0 D1     	pea	mm_cancel		; Yep, show cancelled message
00D01D  2  20 D9 DF     	jsr	sprint
00D020  2  60           	rts
00D021  2               
00D021  2               @a:					; Nope, continue
00D021  2  C9 3A        	cmp	#':'			; Wait for start of record mark ":"
00D023  2  D0 EA        	bne	hdwrecs			; not yet?
00D025  2               	; Start of record marker has been found
00D025  2  20 DB D0     	jsr	GETHEX			; get record length
00D028  2  8D 72 00     	sta	RECLEN			; save it
00D02B  2  8D 76 00     	sta	RECCHKSUM		; And save first byte of chksum
00D02E  2  20 DB D0     	jsr	GETHEX			; Get high byte of start address
00D031  2  8D 74 00     	sta	START_HI
00D034  2  18           	clc
00D035  2  6D 76 00     	adc	RECCHKSUM		; Add in the chksum
00D038  2  8D 76 00     	sta	RECCHKSUM
00D03B  2  20 DB D0     	jsr	GETHEX			; Get low byte of address
00D03E  2  8D 73 00     	sta	START_LO
00D041  2  18           	clc
00D042  2  6D 76 00     	adc	RECCHKSUM
00D045  2  8D 76 00     	sta	RECCHKSUM
00D048  2  20 DB D0     	jsr	GETHEX			; Get record type
00D04B  2  8D 75 00     	sta	RECTYPE
00D04E  2  18           	clc
00D04F  2  6D 76 00     	adc	RECCHKSUM
00D052  2  8D 76 00     	sta	RECCHKSUM
00D055  2  AD 75 00     	lda	RECTYPE
00D058  2  D0 31        	bne	HDER1			; End-Of-Record
00D05A  2  AE 72 00     	ldx	RECLEN			; Number of bytes to write to memory
00D05D  2  A0 00        	ldy	#$00			; Start offset at 0
00D05F  2               HDLP1:
00D05F  2  20 DB D0     	jsr	GETHEX			; Get data byte
00D062  2  91 73        	sta	(START_LO), y		; Save it to RAM
00D064  2  18           	clc
00D065  2  6D 76 00     	adc	RECCHKSUM
00D068  2  8D 76 00     	sta	RECCHKSUM
00D06B  2  C8           	iny				; Increment data pointer
00D06C  2  CA           	dex				; Decrement count
00D06D  2  D0 F0        	bne	HDLP1			; Continue until counter = 0
00D06F  2  20 DB D0     	jsr	GETHEX			; get the checksum
00D072  2  18           	clc
00D073  2  6D 76 00     	adc	RECCHKSUM
00D076  2  D0 08        	bne	HDDLF1			; If failed, report it
00D078  2               ; Another successful record processed
00D078  2  A9 23        	lda	#'#'			; Record == OK ==> "#"
00D07A  2               ;	sta	ACIA_DATA		; Write to ACIA, but don't wait
00D07A  2  20 5C CD     	jsr	uart_output
00D07D  2  4C 0F D0     	jmp	hdwrecs			; get next record
00D080  2               HDDLF1:
00D080  2  A9 46        	lda	#'F'			; Record == Fail ==> "F"
00D082  2  8D 77 00     	sta	DLFAIL
00D085  2               ;	sta	ACIA_DATA
00D085  2  20 5C CD     	jsr	uart_output
00D088  2  4C 0F D0     	jmp	hdwrecs
00D08B  2               
00D08B  2               HDER1:
00D08B  2  C9 01        	cmp	#1			; Check for End-of-record type
00D08D  2  F0 15        	beq	HDER2
00D08F  2  F4 51 D1     	pea	mm_unkn
00D092  2  20 D9 DF     	jsr	sprint
00D095  2  AD 75 00     	lda	RECTYPE
00D098  2  8D 77 00     	sta	DLFAIL
00D09B  2               ;	jsr	PUTHEX
00D09B  2  20 AD DF     	jsr	dpyhex
00D09E  2  20 C4 DF     	jsr	newline			; Known entry in ROM ;)
00D0A1  2  4C 0F D0     	jmp	hdwrecs
00D0A4  2               
00D0A4  2               HDER2:
00D0A4  2  20 DB D0     	jsr	GETHEX			; Get checksum
00D0A7  2  18           	clc
00D0A8  2  6D 76 00     	adc	RECCHKSUM		; Add previous .A value
00D0AB  2  F0 07        	beq	HDER3			; CHKSUM = 0 means OK
00D0AD  2  F4 6B D1     	pea	mm_bad			; Warn user of bad checksum
00D0B0  2  20 D9 DF     	jsr	sprint
00D0B3  2  60           	rts
00D0B4  2               
00D0B4  2               HDER3:
00D0B4  2  AD 77 00     	lda	DLFAIL
00D0B7  2  F0 0A        	beq	HDEROK			; 0 = OK, non-zero = error
00D0B9  2               
00D0B9  2  F4 88 D1     	pea	mm_fail
00D0BC  2  20 D9 DF     	jsr	sprint
00D0BF  2               
00D0BF  2  38           	sec				; Indicate an error
00D0C0  2  4C FF D8     	jmp	monerr
00D0C3  2               
00D0C3  2               HDEROK:
00D0C3  2  F4 AF D1     	pea 	mm_succ
00D0C6  2  20 D9 DF     	jsr	sprint
00D0C9  2  AD 74 00     	lda	START_HI
00D0CC  2               ;	jsr	PUTHEX
00D0CC  2  20 AD DF     	jsr	dpyhex
00D0CF  2  AD 73 00     	lda	START_LO
00D0D2  2               ;	jsr	PUTHEX
00D0D2  2  20 AD DF     	jsr	dpyhex
00D0D5  2  20 C4 DF     	jsr	newline
00D0D8  2  4C BE D8     	jmp	monce
00D0DB  2               
00D0DB  2               ;
00D0DB  2               ; GETHEX - get hex value from ACIA
00D0DB  2               ;	We might reuse the Supermon816 routines later on (just to shrink the
00D0DB  2               ;	size of the code)
00D0DB  2               ;
00D0DB  2               GETHEX:
00D0DB  2  20 10 FD     	jsr	char_in			; We use a blocking ACIA get char
00D0DE  2  20 F4 D0     	jsr	MKNIBL			; Convert to 0..F numeric
00D0E1  2  0A           	asl
00D0E2  2  0A           	asl
00D0E3  2  0A           	asl
00D0E4  2  0A           	asl				; Now we have the upper nibble
00D0E5  2  29 F0        	and	#$f0
00D0E7  2  8D 78 00     	sta	TEMP
00D0EA  2  20 10 FD     	jsr	char_in			; Get second nibble
00D0ED  2  20 F4 D0     	jsr	MKNIBL
00D0F0  2  0D 78 00     	ora	TEMP
00D0F3  2  60           	rts				; Return with complete byte in TEMP
00D0F4  2               
00D0F4  2               ;
00D0F4  2               ; MKNIBL - Convert the ASCII nibble to numeric value 0..F
00D0F4  2               ;	We might reuse the Supermon816 routines later on (just to shrink the
00D0F4  2               ;	size of the code)
00D0F4  2               ;
00D0F4  2               MKNIBL:
00D0F4  2  C9 3A        	cmp	#'9' + 1		; See if it is 0-9 or 'A'..'F'
00D0F6  2  90 02        	bcc	MKNNH			; If we borrowed, we lost the carry, so 0..9
00D0F8  2  E9 08        	sbc	#7 + 1			; Subtract off extra 7 (sbc subtracts off one less)
00D0FA  2               	; If we fall through, carry is set unlike direct entry at MKNNH
00D0FA  2               MKNNH:
00D0FA  2  E9 2F        	sbc	#'0' - 1		; Subtract off '0' (if carry clear coming in)
00D0FC  2  29 0F        	and	#$0f			; No upper nibble, no matter what
00D0FE  2  60           	rts				; And return with nibble
00D0FF  2               
00D0FF  2               ; PUTHEX - Put byte in .A as hexidecimal
00D0FF  2               PUTHEX:
00D0FF  2               ;	pha
00D0FF  2               ;	lsr
00D0FF  2               ;	lsr
00D0FF  2               ;	lsr
00D0FF  2               ;	lsr
00D0FF  2               ;	jsr	PRNIBL
00D0FF  2               ;	pla
00D0FF  2               ;PRNIBL:
00D0FF  2               ;	and	#$0f			; Strip off the low nibble
00D0FF  2               ;	cmp	#$0a
00D0FF  2               ;	bcc	NOTHEX
00D0FF  2               ;	adc	#$06			; Add 7 (6+carry), result will be carry clear
00D0FF  2               ;NOTHEX:
00D0FF  2               ;	adc	#'0'			; If carry=0, 0..9
00D0FF  2               ;	jmp	putcha			; Write .A to terminal
00D0FF  2  4C AD DF     	jmp	dpyhex
00D102  2               
00D102  2               ;
00D102  2               ; Strings to print
00D102  2               mm_strt:
00D102  2  0A 0D 0A 0D  	.byte	LF, CR, LF, CR
00D106  2  53 65 6E 64  	.byte	"Send binary code in Intel Hex format"
00D10A  2  20 62 69 6E  
00D10E  2  61 72 79 20  
00D112  2  63 6F 64 65  
00D116  2  20 69 6E 20  
00D11A  2  49 6E 74 65  
00D11E  2  6C 20 48 65  
00D122  2  78 20 66 6F  
00D126  2  72 6D 61 74  
00D12A  2  0A 0D        	.byte	LF, CR
00D12C  2  61 74 20 31  	.byte 	"at 19200, n, 8, 1 -->"
00D130  2  39 32 30 30  
00D134  2  2C 20 6E 2C  
00D138  2  20 38 2C 20  
00D13C  2  31 20 2D 2D  
00D140  2  3E           
00D141  2  0A 0D        	.byte	LF, CR
00D143  2  00           	.byte	$00
00D144  2               
00D144  2               mm_strt_lcd:
00D144  2  49 6E 74 65  	.asciiz	"Intel Loader"
00D148  2  6C 20 4C 6F  
00D14C  2  61 64 65 72  
00D150  2  00           
00D151  2               
00D151  2               mm_unkn:
00D151  2  0A 0D 0A 0D  	.byte	LF, CR, LF, CR
00D155  2  55 6E 6B 6E  	.byte	"Unknown record type $"
00D159  2  6F 77 6E 20  
00D15D  2  72 65 63 6F  
00D161  2  72 64 20 74  
00D165  2  79 70 65 20  
00D169  2  24           
00D16A  2  00           	.byte	$00
00D16B  2               
00D16B  2               mm_bad:
00D16B  2  0A 0D 0A 0D  	.byte	LF, CR, LF, CR
00D16F  2  42 61 64 20  	.byte	"Bad record checksum!"
00D173  2  72 65 63 6F  
00D177  2  72 64 20 63  
00D17B  2  68 65 63 6B  
00D17F  2  73 75 6D 21  
00D183  2  0A 0D 0A 0D  	.byte	LF, CR, LF, CR
00D187  2  00           	.byte 	$00
00D188  2               
00D188  2               mm_fail:
00D188  2  0A 0D 0A 0D  	.byte	LF, CR, LF, CR
00D18C  2  44 6F 77 6E  	.byte	"Download failed"
00D190  2  6C 6F 61 64  
00D194  2  20 66 61 69  
00D198  2  6C 65 64     
00D19B  2  0A 0D        	.byte	LF, CR
00D19D  2  41 62 6F 72  	.byte	"Aborting ...."
00D1A1  2  74 69 6E 67  
00D1A5  2  20 2E 2E 2E  
00D1A9  2  2E           
00D1AA  2  0A 0D 0A 0D  	.byte	LF, CR, LF, CR
00D1AE  2  00           	.byte 	$00
00D1AF  2               
00D1AF  2               mm_succ:
00D1AF  2  0A 0D 0A 0D  	.byte	LF, CR, LF, CR
00D1B3  2  44 6F 77 6E  	.byte	"Download successful"
00D1B7  2  6C 6F 61 64  
00D1BB  2  20 73 75 63  
00D1BF  2  63 65 73 73  
00D1C3  2  66 75 6C     
00D1C6  2  0A 0D        	.byte	LF, CR
00D1C8  2  50 72 6F 67  	.byte 	"Program located at $00/"
00D1CC  2  72 61 6D 20  
00D1D0  2  6C 6F 63 61  
00D1D4  2  74 65 64 20  
00D1D8  2  61 74 20 24  
00D1DC  2  30 30 2F     
00D1DF  2  00           	.byte	$00
00D1E0  2               
00D1E0  2               mm_cancel:
00D1E0  2  0A 0D 0A 0D  	.byte	LF, CR, LF, CR
00D1E4  2  52 65 63 65  	.byte	"Received <Control-C> or <Escape>", LF, CR
00D1E8  2  69 76 65 64  
00D1EC  2  20 3C 43 6F  
00D1F0  2  6E 74 72 6F  
00D1F4  2  6C 2D 43 3E  
00D1F8  2  20 6F 72 20  
00D1FC  2  3C 45 73 63  
00D200  2  61 70 65 3E  
00D204  2  0A 0D        
00D206  2  54 72 61 6E  	.byte	"Transfer aborted...", LF, CR
00D20A  2  73 66 65 72  
00D20E  2  20 61 62 6F  
00D212  2  72 74 65 64  
00D216  2  2E 2E 2E 0A  
00D21A  2  0D           
00D21B  2  0A 0D        	.byte	LF, CR
00D21D  2  00           	.byte	$00
00D21E  2               
00D21E  2               ;---------------------------------------
00D21E  2               ; Used to calculate memory footprint of the module
00D21E  2               ;---------------------------------------
00D21E  2               INTEL_END	= *			; Must be declared before any
00D21E  2               					; calculations
00D21E  2               INTEL_SIZE	= INTEL_END - HEXINTEL
00D21E  2               	.out .concat("Intel hex uploader                $", .sprintf("%04x", HEXINTEL), "      $", .sprintf("%04x", INTEL_END), "    $", .sprintf("%04x", INTEL_SIZE), "  (", .sprintf("%05d", INTEL_SIZE), ")")
00D21E  2               ;	.out .concat("---- Size of INTEL Hex uploader:                 $", .sprintf("%04x", INTEL_SIZE), " (", .sprintf("%5d", INTEL_SIZE), ")")
00D21E  2               
00D21E  1               
00D21E  1               ; Supermon 816
00D21E  1               _incl_monitor:
00D21E  1  00 00 00 00  	.res		SYSMONITOR - *, $00
00D222  1  00 00 00 00  
00D226  1  00 00 00 00  
00D22A  1  00 00 00 00  
00D22E  1  00 00 00 00  
00D232  1  00 00 00 00  
00D236  1  00 00 00 00  
00D23A  1  00 00 00 00  
00D23E  1  00 00 00 00  
00D242  1  00 00 00 00  
00D246  1  00 00 00 00  
00D24A  1  00 00 00 00  
00D24E  1  00 00 00 00  
00D252  1  00 00 00 00  
00D256  1  00 00 00 00  
00D25A  1  00 00 00 00  
00D25E  1  00 00 00 00  
00D262  1  00 00 00 00  
00D266  1  00 00 00 00  
00D26A  1  00 00 00 00  
00D26E  1  00 00 00 00  
00D272  1  00 00 00 00  
00D276  1  00 00 00 00  
00D27A  1  00 00 00 00  
00D27E  1  00 00 00 00  
00D282  1  00 00 00 00  
00D286  1  00 00 00 00  
00D28A  1  00 00 00 00  
00D28E  1  00 00 00 00  
00D292  1  00 00 00 00  
00D296  1  00 00 00 00  
00D29A  1  00 00 00 00  
00D29E  1  00 00 00 00  
00D2A2  1  00 00 00 00  
00D2A6  1  00 00 00 00  
00D2AA  1  00 00 00 00  
00D2AE  1  00 00 00 00  
00D2B2  1  00 00 00 00  
00D2B6  1  00 00 00 00  
00D2BA  1  00 00 00 00  
00D2BE  1  00 00 00 00  
00D2C2  1  00 00 00 00  
00D2C6  1  00 00 00 00  
00D2CA  1  00 00 00 00  
00D2CE  1  00 00 00 00  
00D2D2  1  00 00 00 00  
00D2D6  1  00 00 00 00  
00D2DA  1  00 00 00 00  
00D2DE  1  00 00 00 00  
00D2E2  1  00 00 00 00  
00D2E6  1  00 00 00 00  
00D2EA  1  00 00 00 00  
00D2EE  1  00 00 00 00  
00D2F2  1  00 00 00 00  
00D2F6  1  00 00 00 00  
00D2FA  1  00 00 00 00  
00D2FE  1  00 00 00 00  
00D302  1  00 00 00 00  
00D306  1  00 00 00 00  
00D30A  1  00 00 00 00  
00D30E  1  00 00 00 00  
00D312  1  00 00 00 00  
00D316  1  00 00 00 00  
00D31A  1  00 00 00     
00D800  1               	.include	"supermon816/monitor.asm"
00D800  2               ;==============================================================================
00D800  2               ;  A D R I A
00D800  2               ;  A modular computer
00D800  2               ;
00D800  2               ;  SUPERMON 816 implemtation
00D800  2               ;
00D800  2               ;==============================================================================
00D800  2               ;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
00D800  2               ;*                                                                                 *
00D800  2               ;*      SUPERMON 816 MACHINE LANGUAGE MONITOR FOR THE W65C816S MICROPROCESSOR      *
00D800  2               ;* ------------------------------------------------------------------------------- *
00D800  2               ;*      Copyright ©1991-2014 by BCS Technology Limited.  All rights reserved.      *
00D800  2               ;*                                                                                 *
00D800  2               ;* Permission is hereby granted to use, copy, modify and distribute this software, *
00D800  2               ;* provided this copyright notice remains in the source code and  proper  attribu- *
00D800  2               ;* tion is given.  Redistribution, regardless of form, must be at no charge to the *
00D800  2               ;* end  user.  This code or any part thereof, including any derivation, MAY NOT be *
00D800  2               ;* incorporated into any package intended for sale,  unless written permission has *
00D800  2               ;* been given by the copyright holder.                                             *
00D800  2               ;*                                                                                 *
00D800  2               ;* THERE IS NO WARRANTY OF ANY KIND WITH THIS SOFTWARE.  The user assumes all risk *
00D800  2               ;* in connection with the incorporation of this software into any system.          *
00D800  2               ;* ------------------------------------------------------------------------------- *
00D800  2               ;* Supermon 816 is a salute to Jim Butterfield, who passed away on June 29, 2007.  *
00D800  2               ;*                                                                                 *
00D800  2               ;* Jim, who was the unofficial  spokesman for  Commodore  International during the *
00D800  2               ;* heyday of the company's 8 bit supremacy, scratch-developed the Supermon machine *
00D800  2               ;* language monitor for the PET & CBM computers.   When the best-selling Commodore *
00D800  2               ;* 64 was introduced, Jim adapted his software to the new machine & gave the adap- *
00D800  2               ;* tation the name Supermon 64.   Commodore  subsequently  integrated a customized *
00D800  2               ;* version of Supermon 64 into the C-128 to act as the resident M/L monitor.       *
00D800  2               ;*                                                                                 *
00D800  2               ;* Although Supermon 816 is not an adaptation of Supermon 64,  it was  decided  to *
00D800  2               ;* keep the Supermon name alive, since Supermon 816's general operation & user in- *
00D800  2               ;* terface is similar to that of Supermon 64.   Supermon 816 is 100 percent native *
00D800  2               ;* mode 65C816 code & was developed from a blank canvas.                           *
00D800  2               ;* ------------------------------------------------------------------------------- *
00D800  2               ;* Supermon 816 is a full featured monitor and supports the following operations:  *
00D800  2               ;*                                                                                 *
00D800  2               ;*     A - Assemble code                                                           *
00D800  2               ;*     C - Compare memory regions                                                  *
00D800  2               ;*     D - Disassemble code                                                        *
00D800  2               ;*     F - Fill memory region (cannot span banks)                                  *
00D800  2               ;*     G - Execute code (stops at BRK)                                             *
00D800  2               ;*     H - Search (hunt) memory region                                             *
00D800  2               ;*     J - Execute code as a subroutine (stops at BRK or RTS)                      *
00D800  2               ;*     M - Dump & display memory range                                             *
00D800  2               ;*     R - Dump & display 65C816 registers                                         *
00D800  2               ;*     T - Copy (transfer) memory region                                           *
00D800  2               ;*     X - Exit Supermon 816 & return to operating environment                     *
00D800  2               ;*     > - Modify up to 32 bytes of memory                                         *
00D800  2               ;*     ; - Modify 65C816 registers                                                 *
00D800  2               ;*                                                                                 *
00D800  2               ;* Supermon 816 accepts binary (%), octal (%), decimal (+) and hexadecimal ($) as  *
00D800  2               ;* input for numeric parameters.  Additionally, the H and > operations accept an   *
00D800  2               ;* ASCII string in place of numeric values by preceding the string with ', e.g.:   *
00D800  2               ;*                                                                                 *
00D800  2               ;*     h 042000 042FFF 'BCS Technology Limited                                     *
00D800  2               ;*                                                                                 *
00D800  2               ;* If no radix symbol is entered hex is assumed.                                   *
00D800  2               ;*                                                                                 *
00D800  2               ;* Numeric conversion is also available.  For example, typing:                     *
00D800  2               ;*                                                                                 *
00D800  2               ;*     +1234567 <CR>                                                               *
00D800  2               ;*                                                                                 *
00D800  2               ;* will display:                                                                   *
00D800  2               ;*                                                                                 *
00D800  2               ;*         $12D687                                                                 *
00D800  2               ;*         +1234567                                                                *
00D800  2               ;*         %04553207                                                               *
00D800  2               ;*         %100101101011010000111                                                  *
00D800  2               ;*                                                                                 *
00D800  2               ;* In the above example, <CR> means the console keyboard's return or enter key.    *
00D800  2               ;*                                                                                 *
00D800  2               ;* All numeric values are internally processed as 32 bit unsigned integers.  Addr- *
00D800  2               ;* esses may be entered as 8, 16 or 24 bit values.  During instruction assembly,   *
00D800  2               ;* immediate mode operands may be forced to 16 bits by preceding the operand with  *
00D800  2               ;* an exclamation point if the instruction can accept a 16 bit operand, e.g.:      *
00D800  2               ;*                                                                                 *
00D800  2               ;*     a 1f2000 lda !#4                                                            *
00D800  2               ;*                                                                                 *
00D800  2               ;* The above will assemble as:                                                     *
00D800  2               ;*                                                                                 *
00D800  2               ;*     A 1F2000  A9 04 00     LDA #$0004                                           *
00D800  2               ;*                                                                                 *
00D800  2               ;* Entering:                                                                       *
00D800  2               ;*                                                                                 *
00D800  2               ;*     a 1f2000 ldx !#+157                                                         *
00D800  2               ;*                                                                                 *
00D800  2               ;* will assemble as:                                                               *
00D800  2               ;*                                                                                 *
00D800  2               ;*     A 1F2000  A2 9D 00     LDX #$009D                                           *
00D800  2               ;*                                                                                 *
00D800  2               ;* Absent the ! in the operand field, the above would have been assembled as:      *
00D800  2               ;*                                                                                 *
00D800  2               ;*     A 1F2000  A2 9D        LDX #$9D                                             *
00D800  2               ;*                                                                                 *
00D800  2               ;* If an immediate mode operand is greater than $FF assembly of a 16 bit operand   *
00D800  2               ;* is implied.                                                                     *
00D800  2               ;* ------------------------------------------------------------------------------- *
00D800  2               ;* A Note on the PEA & PEI Instructions                                            *
00D800  2               ;* ------------------------------------                                            *
00D800  2               ;*                                                                                 *
00D800  2               ;* The Eyes and Lichty programming manual uses the following syntax for the PEA    *
00D800  2               ;* and PEI instructions:                                                           *
00D800  2               ;*                                                                                 *
00D800  2               ;*     PEA <operand>                                                               *
00D800  2               ;*     PEI (<operand>)                                                             *
00D800  2               ;*                                                                                 *
00D800  2               ;* The WDC data sheet that was published at the time of the 65C816's release in    *
00D800  2               ;* 1984 does not indicate a recommended or preferred syntax for any of the above   *
00D800  2               ;* instructions.  PEA pushes its operand to the stack and hence operates like any  *
00D800  2               ;* other immediate mode instruction, in that the operand is the data (however, PEA *
00D800  2               ;* doesn't affect the status register).  Similarly, PEI pushes the 16 bit value    *
00D800  2               ;* stored at <operand> and <operand>+1, and hence operates like any other direct   *
00D800  2               ;* (zero) page instruction, again without affecting the status register.           *
00D800  2               ;*                                                                                 *
00D800  2               ;* BCS Technology Limited is of the opinion that the developer of the ORCA/M as-   *
00D800  2               ;* sembler, which is the assembler referred to in the Eyes and Lichty manual, mis- *
00D800  2               ;* understood how PEA and PEI behave during runtime, and hence chose an incorrect  *
00D800  2               ;* syntax for these two instructions.  This error was subsequently carried forward *
00D800  2               ;* by Eyes and Lichty.                                                             *
00D800  2               ;*                                                                                 *
00D800  2               ;* Supermon 816's assembler uses the following syntax for PEA and PEI:             *
00D800  2               ;*                                                                                 *
00D800  2               ;*     PEA #<operand>                                                              *
00D800  2               ;*     PEI <operand>                                                               *
00D800  2               ;*                                                                                 *
00D800  2               ;* The operand for PEA is treated as a 16 bit value, even if entered as an 8 bit   *
00D800  2               ;* value.  The operand for PEI must be 8 bits.                                     *
00D800  2               ;*                                                                                 *
00D800  2               ;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
00D800  2               ;==============================================================================
00D800  2               ; (Additional assembler/linker directives)
00D800  2               	.listbytes	255
00D800  2               	.p816
00D800  2               
00D800  2               	.macro softvers                 ; software version — change with each
00D800  2               					; revision...
00D800  2               	.byte "1"             		; major
00D800  2               	.byte "."
00D800  2               	.byte "0"             		; minor
00D800  2               	.byte "."
00D800  2               	.byte "3"             		; revision
00D800  2               	.endmacro
00D800  2               
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Revision Table
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Version	Revision Date	Description
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ;  1.0  	09 jun 2020  	A) Original derived from the Supermon 816 by
00D800  2               ;				   BCS Technology Limited
00D800  2               ;				B) Used the firmware for 65C816 ECB SBC by
00D800  2               ;				   RetroBrew Computers as additional reference
00D800  2               ; 				C) Adaption for CA65 (assembler of CC65)
00D800  2               ;  1.0.1	10 nov 2020	A) Added 8-bit multiplication (8-bit or 16-bit
00D800  2               ;				   product)
00D800  2               ;			 	   Added 8-bit division (from 8-bit or 16-bit
00D800  2               ;				   divisor, with 8-bit quotient, dividend and
00D800  2               ;				   remainder)
00D800  2               ;  1.0.2	10 jan 2021	A) Implementation for Adria
00D800  2               ;  1.0.3	18 feb 2021	A) In SPRINT we now save the 16 bit .Y to the
00D800  2               ;				   stack, before actually printing char. When
00D800  2               ;				   returned, we reset the register widths and
00D800  2               ;				   retrieve the .Y
00D800  2               ;
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ;
00D800  2               ;
00D800  2               ;	        COMMENT ABBREVIATIONS
00D800  2               ;	----------------------------------------------------
00D800  2               ;	  BCD   binary-coded decimal
00D800  2               ;	   DP   direct page or page zero
00D800  2               ;	  EOF   end-of-field
00D800  2               ;	  EOI   end-of-input
00D800  2               ;	  LSB   least significant byte/bit
00D800  2               ;	  LSD   least significant digit
00D800  2               ;	  LSN   least significant nybble
00D800  2               ;	  LSW   least significant word
00D800  2               ;	  MPU   microprocessor
00D800  2               ;	  MSB   most significant byte/bit
00D800  2               ;	  MSD   most significant digit
00D800  2               ;	  MSN   most significant nybble
00D800  2               ;	  MSW   most-significant word
00D800  2               ;	  RAM   random access memory
00D800  2               ;	   WS   whitespace, i.e., blanks & horizontal tabs
00D800  2               ;	----------------------------------------------------
00D800  2               ;	A word is defined as 16 bits.
00D800  2               ;
00D800  2               ;	   MPU REGISTER SYMBOLS
00D800  2               ;	--------------------------
00D800  2               ;	   .A   accumulator LSB
00D800  2               ;	   .B   accumulator MSB
00D800  2               ;	   .C   16 bit accumulator
00D800  2               ;	   .X   X-index
00D800  2               ;	   .Y   Y-index
00D800  2               ;	   DB   data bank
00D800  2               ;	   DP   direct page
00D800  2               ;	   PB   program bank
00D800  2               ;	   PC   program counter
00D800  2               ;	   SP   stack pointer
00D800  2               ;	   SR   MPU status
00D800  2               ;	----------------------------
00D800  2               ;
00D800  2               ;	  MPU STATUS REGISTER SYMBOLS
00D800  2               ;	-------------------------------
00D800  2               ;	    C   carry
00D800  2               ;	    D   decimal mode
00D800  2               ;	    I   maskable interrupts
00D800  2               ;	    m   accumulator/memory size
00D800  2               ;	    N   result negative
00D800  2               ;	    V   sign overflow
00D800  2               ;	    x   index registers size
00D800  2               ;	    Z   result zero
00D800  2               ;	-------------------------------
00D800  2               ;
00D800  2               ;==============================================================================
00D800  2               ;
00D800  2               ;SYSTEM INTERFACE DEFINITIONS
00D800  2               ;
00D800  2               ;	------------------------------------------------------------------
00D800  2               ;	This section defines the interface between Supermon 816 & the host
00D800  2               ;	system.   Change these definitions to suit your system, but do not
00D800  2               ;	change any label names.  All definitions must have valid values in
00D800  2               ;	order to assemble Supermon 816.
00D800  2               ;	------------------------------------------------------------------
00D800  2               ;
00D800  2               ;	--------------------------------------------------------
00D800  2               ORIGIN:
00D800  2               	.org	SYSMONITOR
00D800  2               ;
00D800  2               ;	Set _ORIGIN_ to Supermon 816's desired assembly address.
00D800  2               ;	--------------------------------------------------------
00D800  2               ;
00D800  2               ;	------------------------------------------------------------------------
00D800  2               ;vecexit  .EQU $002000              ;exit to environment address...
00D800  2               ;
00D800  2               ;	Set VECEXIT to where Supermon 816 should go when it exits.  Supermon 816
00D800  2               ;	will do a JML (long jump) to this address, which means VECEXIT must be a
00D800  2               ;	24 bit address.
00D800  2               ;	------------------------------------------------------------------------
00D800  2               ;
00D800  2               ;	------------------------------------------------------------------------
00D800  2               ;
00D800  2               ;getcha                  ;get keystroke from console...
00D800  2               ;
00D800  2               ;	GETCHA refers to an operating system API call that returns a keystroke
00D800  2               ;	in the 8 bit accumulator.  Supermon 816  assumes that GETCHA is a non-
00D800  2               ;	blocking subroutine & returns with carry clear to indicate that a key-
00D800  2               ;	stroke is in .A, or with carry set to indicate that no keystroke was
00D800  2               ;	available.  GETCHA will be called with a JSR instruction.
00D800  2               ;
00D800  2               ;	Supermon 816 expects .X & .Y to be preserved upon return from GETCHA.
00D800  2               ;	You may have to modify Supermon 816 at all calls to GETCHA if your "get
00D800  2               ;	keystroke" routine works differently than described.
00D800  2               ;	------------------------------------------------------------------------
00D800  2               ;getcha		=  CHAR_IN
00D800  2               getcha		=  char_scan
00D800  2               
00D800  2               ;------------------------------------------------------------------------
00D800  2               ;putcha   print character on console...
00D800  2               ;
00D800  2               ;	PUTCHA refers to an operating system API call that prints a character to
00D800  2               ;	the console screen.  The character to be printed will be in .A, which
00D800  2               ;	will be set to 8-bit width.  Supermon 816 assumes that PUTCHA will block
00D800  2               ;	until the character can be processed.  PUTCHA will be called with a JSR
00D800  2               ;	instructions.
00D800  2               ;
00D800  2               ;	Supermon 816 expects .X & .Y to be preserved upon return from PUTCHA.
00D800  2               ;	You may have to modify Supermon 816 at all calls to PUTCHA if your "put
00D800  2               ;	character" routine works differently than described.
00D800  2               ;
00D800  2               putcha 		= char_out
00D800  2               ;
00D800  2               ;	------------------------------------------------------------------------
00D800  2               ;
00D800  2               ;	------------------------------------------------------------------------
00D800  2               vecbrki  	= VECTOR_BRK           ;BRK handler indirect vector...
00D800  2               ;
00D800  2               ;	Supermon 816 will modify this vector so that execution of a BRK instruc-
00D800  2               ;	tion is intercepted & the registers  are  captured.   Your BRK front end
00D800  2               ;	should jump through this vector after pushing the registers as follows:
00D800  2               ;
00D800  2               ;	         phb                   ;save DB
00D800  2               ;	         phd                   ;save DP
00D800  2               ;	         rep #%00110000        ;16 bit registers
00D800  2               ;	         pha
00D800  2               ;	         phx
00D800  2               ;	         phy
00D800  2               ;	         jmp (vecbrki)         ;indirect vector
00D800  2               ;
00D800  2               ;	When a G or J command is issued, the above sequence will be reversed be-
00D800  2               ;	fore a jump is made to the code to be executed.  Upon exit from Supermon
00D800  2               ;	816, the original address at VECBRKI will be restored.
00D800  2               ;
00D800  2               ;	If your BRK front end doesn't conform to the above you will have to mod-
00D800  2               ;	ify Supermon 816 to accommodate the differences.  The most likely needed
00D800  2               ;	changes will be in the order in which registers are pushed to the stack.
00D800  2               ;	------------------------------------------------------------------------
00D800  2               ;
00D800  2               ;	------------------------------------------------------------------------
00D800  2               hwstack  	= $7fff                ;top of hardware stack...
00D800  2               ;
00D800  2               ;	Supermon 816 initializes the stack pointer to this address when the cold
00D800  2               ;	start at MONCOLD is called to enter the monitor.  The stack pointer will
00D800  2               ;	be undisturbed when entry into Supermon 816 is through JMONBRK (see jump
00D800  2               ;	table definitions).
00D800  2               ;	------------------------------------------------------------------------
00D800  2               ;
00D800  2               ;	------------------------------------------------------------------------
00D800  2               zeropage 	= $80                  ;Supermon 816's direct page...
00D800  2               ;
00D800  2               ;	Supermon 816 uses direct page starting at this address.  Be sure that no
00D800  2               ;	conflict occurs with other software.
00D800  2               ;	------------------------------------------------------------------------
00D800  2               ;
00D800  2               ;	------------------------------------------------------------------------
00D800  2               stopkey  	= $03                  ;display abort key...
00D800  2               ;
00D800  2               ;	Supermon 816 will poll for a "stop key" during display operations, such
00D800  2               ;	as code disassembly & memory dumps, so as to abort further processing &
00D800  2               ;	return to the command prompt.  STOPKEY must be defined with the ASCII
00D800  2               ;	value that the "stop key" will emit when typed.  The polling is via a
00D800  2               ;	call to GETCHA (described above).  The default STOPKEY definition of $03
00D800  2               ;	is for ASCII <ETX> or [Ctrl-C].
00D800  2               ;	------------------------------------------------------------------------
00D800  2               ;
00D800  2               ibuffer  	= $000200               ;input buffer &...
00D800  2               auxbuf   	= ibuffer+s_ibuf+s_byte ;auxiliary buffer...
00D800  2               ;
00D800  2               ;	------------------------------------------------------------------------
00D800  2               ;	Supermon 816 will use the above definitions for input buffers.  These
00D800  2               ;	buffers may be located anywhere in RAM that is convenient.  The buffers
00D800  2               ;	are stateless, which means that unless Supermon 816 has control of your
00D800  2               ;	system, they may be overwritten without consequence.
00D800  2               ;	------------------------------------------------------------------------
00D800  2               ;
00D800  2               ;===============================================================================
00D800  2               ; Originally the Supermon 816 source holds macros for the (additional) 65816
00D800  2               ; opcodes, but CA65 already supports them
00D800  2               ;===============================================================================
00D800  2               ; Also all macros have moved to global.asm
00D800  2               ;===============================================================================
00D800  2               ; Data type sizes
00D800  2               ;------------------------------------------------------------------------------
00D800  2               s_byte		= 1			; Byte
00D800  2               s_word		= 2			; Word (16 bits)
00D800  2               s_xword		= 3			; Extended word (24 bits)
00D800  2               s_dword		= 4			; Double word (32 bits)
00D800  2               s_rampage	= $0100			; 65xx RAM page size
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Data type sizes in bits
00D800  2               ;------------------------------------------------------------------------------
00D800  2               s_bibyte	= 8			; Byte
00D800  2               s_binibble	= 4			; Nibble/Nybble
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; 65C816 Native mode status register definitions
00D800  2               ;------------------------------------------------------------------------------
00D800  2               s_mpudbrx	= s_byte		; Databank size
00D800  2               s_mpudpx	= s_word		; Direct Page size
00D800  2               s_mpupbrx	= s_byte		; Program Bank size
00D800  2               s_mpupcx	= s_word		; Program Counter size
00D800  2               s_mpuspx	= s_word		; Stack Pointer size
00D800  2               s_mpusrx	= s_byte		; Status Register size
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Status register flags
00D800  2               ;------------------------------------------------------------------------------
00D800  2               sr_Carry	= %00000001		; C
00D800  2               sr_Zero		= sr_Carry <<1		; Z
00D800  2               sr_IRQ		= sr_Zero  <<1		; I
00D800  2               sr_dbm		= sr_IRQ   <<1		; D
00D800  2               sr_ixw		= sr_dbm   <<1		; x
00D800  2               sr_amw		= sr_ixw   <<1		; m
00D800  2               sr_ovl		= sr_amw   <<1		; V
00D800  2               sr_neg		= sr_ovl   <<1		; N
00D800  2               ;	NVmxDIZC
00D800  2               ;	xxxxxxxx
00D800  2               ;	||||||||
00D800  2               ;	|||||||+---> 1 = carry set/generated
00D800  2               ;	||||||+----> 1 = result = zero
00D800  2               ;	|||||+-----> 1 = IRQs ignored
00D800  2               ;	||||+------> 0 = binary arithmetic mode
00D800  2               ;	||||         1 = decimal arithmetic mode
00D800  2               ;	|||+-------> 0 = 16 bit index
00D800  2               ;	|||          1 = 8 bit index
00D800  2               ;	||+--------> 0 = 16 bit .A & memory
00D800  2               ;	||           1 = 8 bit .A & memory
00D800  2               ;	|+---------> 1 = sign overflow
00D800  2               ;	+----------> 1 = result = negative
00D800  2               ;
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; "Size-of" constants
00D800  2               ;------------------------------------------------------------------------------
00D800  2               s_address	= s_xword		; 24-bit address
00D800  2               s_auxBuffer	= 32			; Auxiliary buffer (32 bytes)
00D800  2               s_ibuf		= 69			; Input buffer (69 bytes)
00D800  2               s_mnemonic	= 3			; MPU ASCII Menumonic size
00D800  2               s_mnepck	= 2			; MPU Encoded mnemonic size
00D800  2               s_mvInstruc	= 3			; MVN/MVP instruction
00D800  2               s_opcode	= s_byte		; MPU opcode
00D800  2               s_oper		= s_xword		; Operand
00D800  2               s_pfac		= s_dword		; Primary math accumulator
00D800  2               s_sfac		= s_dword+s_word	; Secondary math accumulators
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; "Number-of" constants
00D800  2               ;------------------------------------------------------------------------------
00D800  2               n_dBytes	= 21			; Default disassembly bytes (21)
00D800  2               n_dump		= 16			; Bytes per memory dump line (16)
00D800  2               n_mBytes	= s_rampage-1		; Default memory dump bytes
00D800  2               n_hccols	= 10			; Compare/hunt display columns (10)
00D800  2               n_opcols	= 3 * s_oper		; Disassembly operand columns
00D800  2               n_opsLSR	= 4			; LSRs to extract instruction size
00D800  2               n_shfEncode	= 5			; Shifts to encode/decode mnemonic
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Numeric conversion constants
00D800  2               ;------------------------------------------------------------------------------
00D800  2               a_hexdec	= 'A'-'9'-2		; Hex to decimal differences
00D800  2               c_bin		= '%'			; Binary prefix
00D800  2               c_dec		= '+'			; Decimal prefix
00D800  2               c_hex		= '$'			; Hexadecimal prefix
00D800  2               c_oct		= '@'			; Octal prefix
00D800  2               k_hex		= 'f'			; Hex ASCII conversion
00D800  2               m_bits		= s_pfac * s_bibyte	; Operand bit size
00D800  2               m_cbits		= s_sfac * s_bibyte	; Workspace bit size
00D800  2               bcdumask	= %00001111		; Isolate BCD units mask
00D800  2               btoamask	= %00110000		; Binary to ASCII mask
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Assembler/Disassembler constants
00D800  2               ;------------------------------------------------------------------------------
00D800  2               a_mnecvt	= '?'			; Encoded mnemonic conversion base
00D800  2               aimmaska	= %00011111		; .A immediate opcode test #1
00D800  2               aimmaskb	= %00001001		; .A immediate opcode test #2
00D800  2               asmprfx		= 'A'			; Assemble code prefix
00D800  2               ascprmct	= 9			; Assembler prompt "size-of"
00D800  2               disprfx		= '.'			; Disassemble code prefix
00D800  2               flimmask	= %11000000		; Force long immediate flag
00D800  2               opc_cpxi	= $e0			; CPX # opcode
00D800  2               opc_cpyi	= $c0			; CPY # opcode
00D800  2               opc_ldxi	= $a2			; LDX # opcode
00D800  2               opc_ldyi	= $a0			; LDY # opcode
00D800  2               opc_mvn		= $54			; MVN opcode
00D800  2               opc_mvp		= $44			; MVP opcode
00D800  2               opc_rep		= $c2			; REP opcode
00D800  2               opc_sep		= $e2			; SEP opcode
00D800  2               pfxmxmask	= sr_amw | sr_ixw	; MPU m & x flag bits mask
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Assembler prompt buffer offsets
00D800  2               ;------------------------------------------------------------------------------
00D800  2               apadrbkh	= s_word		; Instruction address bank MSN
00D800  2               apadrbkl	= apadrbkh + s_byte	; Instruction address bank LSN
00D800  2               apadrmbh	= apadrbkl + s_byte	; Instruction address MSB MSN
00D800  2               apadrmbl	= apadrmbh + s_byte	; instruction address MSB LSN
00D800  2               apadrlbh	= apadrmbl + s_byte	; instruction address LSB MSN
00D800  2               apadrlbl	= apadrlbh + s_byte	; Instruction address LSB MSN
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Addressing mode preamble symbols
00D800  2               ;------------------------------------------------------------------------------
00D800  2               amp_flim	= '!'			; Force long immediate
00D800  2               amp_imm		= '#'			; Immediate
00D800  2               amp_ind		= '('			; Indirect
00D800  2               amp_indl	= '['			; Indirect Long
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Addressing mode symbolic translation indices
00D800  2               ;------------------------------------------------------------------------------
00D800  2               am_nam		= %0000			; No symbol
00D800  2               am_imm		= %0001			; #
00D800  2               am_adrx		= %0010			; <addr>, X
00D800  2               am_adry		= %0011			; <addr>, Y
00D800  2               am_ind		= %0100			; (<addr>)
00D800  2               am_indl		= %0101			; [<dp>]
00D800  2               am_indly	= %0110			; [<dp>], Y
00D800  2               am_indx		= %0111			; (<addr>, X)
00D800  2               am_indy		= %1000			; (<dp>), Y
00D800  2               am_stk		= %1001			; <offset>, S
00D800  2               am_stky		= %1010			; (<offset>, S), Y
00D800  2               am_move		= %1011			; <srcbank>, <destbank>
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Operand size translation indices
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ops0		= %0000 << 4		; No operand
00D800  2               ops1		= %0001 << 4		; 8 Bit operand
00D800  2               ops2		= %0010 << 4		; 16 Bit operand
00D800  2               ops3		= %0011 << 4		; 24 Bit operand
00D800  2               bop1		= %0101 << 4		; 8 Bit relative branch
00D800  2               bop2		= %0110 << 4		; 16 Bit relative branch
00D800  2               vops		= %1001 << 4		; 8 or 16 Bit operand
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; operand size and addressing mode extraction masks
00D800  2               ;------------------------------------------------------------------------------
00D800  2               amodmask	= %00001111		; Addressing mode index
00D800  2               opsmask		= %00110000		; Operand size
00D800  2               vopsmask	= %11000000		; BOPS & VOPS flag bits
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Instruction mnemonic encoding
00D800  2               ;------------------------------------------------------------------------------
00D800  2               mne_adc		= $2144			; ADC
00D800  2               mne_and		= $2bc4			; AND
00D800  2               mne_asl		= $6d04			; ASL
00D800  2               mne_bcc		= $2106			; BCC
00D800  2               mne_bcs		= $a106			; BCS
00D800  2               mne_beq		= $9186			; BCC
00D800  2               mne_bit		= $aa86			; BIT
00D800  2               mne_bmi		= $5386			; BMI
00D800  2               mne_bne		= $33c6			; BNE
00D800  2               mne_bpl		= $6c46			; BPL
00D800  2               mne_bra		= $14c6			; BRA
00D800  2               mne_brk		= $64c6			; BRK
00D800  2               mne_brl		= $6cc6			; BRL
00D800  2               mne_bvc		= $25c6			; BVC
00D800  2               mne_bvs		= $a5c6			; BVS
00D800  2               mne_clc		= $2348			; CLC
00D800  2               mne_cld		= $2b48			; CLD
00D800  2               mne_cli		= $5348			; CLI
00D800  2               mne_clv		= $bb48			; CLV
00D800  2               mne_cmp		= $8b88			; CMP
00D800  2               mne_cop		= $8c08			; COP
00D800  2               mne_cpx		= $cc48			; CPX
00D800  2               mne_cpy		= $d448			; CPY
00D800  2               mne_dec		= $218a			; DEC
00D800  2               mne_dex		= $c98a			; DEX
00D800  2               mne_dey		= $d18a			; DEY
00D800  2               mne_eor		= $9c0c			; EOR
00D800  2               mne_inc		= $23d4			; INC
00D800  2               mne_inx		= $cbd4			; INX
00D800  2               mne_iny		= $d3d4			; INY
00D800  2               mne_jml		= $6b96			; JML
00D800  2               mne_jmp		= $8b96			; JMP
00D800  2               mne_jsl		= $6d16			; JSL
00D800  2               mne_jsr		= $9d16			; JSR
00D800  2               mne_lda		= $115a			; LDA
00D800  2               mne_ldx		= $c95a			; LDX
00D800  2               mne_ldy		= $d15a			; LDY
00D800  2               mne_lsr		= $9d1a			; LSR
00D800  2               mne_mvn		= $7ddc			; MVN
00D800  2               mne_mvp		= $8ddc			; MVP
00D800  2               mne_nop		= $8c1e			; NOP
00D800  2               mne_ora		= $14e0			; ORA
00D800  2               mne_pea		= $11a2			; PEA
00D800  2               mne_pei		= $51a2			; PEI
00D800  2               mne_per		= $99a2			; PER
00D800  2               mne_pha		= $1262			; PHA
00D800  2               mne_phb		= $1a62			; PHB
00D800  2               mne_phd		= $2a62			; PHD
00D800  2               mne_phk		= $6262			; PHK
00D800  2               mne_php		= $8a62			; PHP
00D800  2               mne_phx		= $ca62			; PHX
00D800  2               mne_phy		= $d262			; PHY
00D800  2               mne_pla		= $1362			; PLA
00D800  2               mne_plb		= $1b62			; PLB
00D800  2               mne_pld		= $2b62			; PLD
00D800  2               mne_plp		= $8b62			; PLP
00D800  2               mne_plx		= $cb62			; PLX
00D800  2               mne_ply		= $d362			; PLY
00D800  2               mne_rep		= $89a6			; REP
00D800  2               mne_rol		= $6c26			; ROL
00D800  2               mne_ror		= $9c26			; ROR
00D800  2               mne_rti		= $5566			; RTI
00D800  2               mne_rtl		= $6d66			; RTL
00D800  2               mne_rts		= $a566			; RTS
00D800  2               mne_sbc		= $20e8			; SBC
00D800  2               mne_sec		= $21a8			; SEC
00D800  2               mne_sed		= $29a8			; SED
00D800  2               mne_sei		= $51a8			; SEI
00D800  2               mne_sep		= $89a8			; SEP
00D800  2               mne_sta		= $1568			; STA
00D800  2               mne_stp		= $8d68			; STP
00D800  2               mne_stx		= $cd68			; STX
00D800  2               mne_sty		= $d568			; STY
00D800  2               mne_stz		= $dd68			; STZ
00D800  2               mne_tax		= $c8aa			; TAX
00D800  2               mne_tay		= $d0aa			; TAY
00D800  2               mne_tcd		= $292a			; TCD
00D800  2               mne_tcs		= $a12a			; TCS
00D800  2               mne_tdc		= $216a			; TDC
00D800  2               mne_trb		= $1cea			; TRB
00D800  2               mne_tsb		= $1d2a			; TSB
00D800  2               mne_tsc		= $252a			; TSC
00D800  2               mne_tsx		= $cd2a			; TSX
00D800  2               mne_txa		= $166a			; TXA
00D800  2               mne_txs		= $a66a			; TXS
00D800  2               mne_txy		= $d66a			; TXY
00D800  2               mne_tya		= $166a			; TYA
00D800  2               mne_tyx		= $ceaa			; TYX
00D800  2               mne_wai		= $50b0			; WAI
00D800  2               mne_wdm		= $7170			; WDM
00D800  2               mne_xba		= $10f2			; XBA
00D800  2               mne_xce		= $3132			; XCE
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Encoded instruction mnemonic indices
00D800  2               ;------------------------------------------------------------------------------
00D800  2               mne_adcx	= 16			; ADC
00D800  2               mne_andx	= 29			; AND
00D800  2               mne_aslx	= 44			; ASL
00D800  2               mne_bccx	= 15			; BCC
00D800  2               mne_bcsx	= 65			; BCS
00D800  2               mne_beqx	= 59			; BCC
00D800  2               mne_bitx	= 70			; BIT
00D800  2               mne_bmix	= 36			; BMI
00D800  2               mne_bnex	= 31			; BNE
00D800  2               mne_bplx	= 42			; BPL
00D800  2               mne_brax	= 5			; BRA
00D800  2               mne_brkx	= 39			; BRK
00D800  2               mne_brlx	= 43			; BRL
00D800  2               mne_bvcx	= 23			; BVC
00D800  2               mne_bvsx	= 68			; BVS
00D800  2               mne_clcx	= 20			; CLC
00D800  2               mne_cldx	= 27			; CLD
00D800  2               mne_clix	= 35			; CLI
00D800  2               mne_clvx	= 71			; CLV
00D800  2               mne_cmpx	= 53			; CMP
00D800  2               mne_copx	= 55			; COP
00D800  2               mne_cpxx	= 78			; CPX
00D800  2               mne_cpyx	= 88			; CPY
00D800  2               mne_decx	= 18			; DEC
00D800  2               mne_dexx	= 74			; DEX
00D800  2               mne_deyx	= 84			; DEY
00D800  2               mne_eorx	= 61			; EOR
00D800  2               mne_incx	= 21			; INC
00D800  2               mne_inxx	= 77			; INX
00D800  2               mne_inyx	= 87			; INY
00D800  2               mne_jmlx	= 40			; JML
00D800  2               mne_jmpx	= 54			; JMP
00D800  2               mne_jslx	= 45			; JSL
00D800  2               mne_jsrx	= 63			; JSR
00D800  2               mne_ldax	= 1			; LDA
00D800  2               mne_ldxx	= 73			; LDX
00D800  2               mne_ldyx	= 83			; LDY
00D800  2               mne_lsrx	= 64			; LSR
00D800  2               mne_mvnx	= 48			; MVN
00D800  2               mne_mvpx	= 58			; MVP
00D800  2               mne_nopx	= 56			; NOP
00D800  2               mne_orax	= 6			; ORA
00D800  2               mne_peax	= 2			; PEA
00D800  2               mne_peix	= 33			; PEI
00D800  2               mne_perx	= 60			; PER
00D800  2               mne_phax	= 3			; PHA
00D800  2               mne_phbx	= 10			; PHB
00D800  2               mne_phdx	= 26			; PHD
00D800  2               mne_phkx	= 38			; PHK
00D800  2               mne_phpx	= 51			; PHP
00D800  2               mne_phxx	= 75			; PHX
00D800  2               mne_phyx	= 85			; PHY
00D800  2               mne_plax	= 4			; PLA
00D800  2               mne_plbx	= 11			; PLB
00D800  2               mne_pldx	= 28			; PLD
00D800  2               mne_plpx	= 52			; PLP
00D800  2               mne_plxx	= 76			; PLX
00D800  2               mne_plyx	= 86			; PLY
00D800  2               mne_repx	= 49			; REP
00D800  2               mne_rolx	= 41			; ROL
00D800  2               mne_rorx	= 62			; ROR
00D800  2               mne_rtix	= 37			; RTI
00D800  2               mne_rtlx	= 46			; RTL
00D800  2               mne_rtsx	= 67			; RTS
00D800  2               mne_sbcx	= 14			; SBC
00D800  2               mne_secx	= 19			; SEC
00D800  2               mne_sedx	= 25			; SED
00D800  2               mne_seix	= 34			; SEI
00D800  2               mne_sepx	= 50			; SEP
00D800  2               mne_stax	= 7			; STA
00D800  2               mne_stpx	= 57			; STP
00D800  2               mne_stxx	= 80			; STX
00D800  2               mne_styx	= 89			; STY
00D800  2               mne_stzx	= 91			; STZ
00D800  2               mne_taxx	= 72			; TAX
00D800  2               mne_tayx	= 82			; TAY
00D800  2               mne_tcdx	= 24			; TCD
00D800  2               mne_tcsx	= 66			; TCS
00D800  2               mne_tdcx	= 17			; TDC
00D800  2               mne_trbx	= 12			; TRB
00D800  2               mne_tsbx	= 13			; TSB
00D800  2               mne_tscx	= 22			; TSC
00D800  2               mne_tsxx	= 79			; TSX
00D800  2               mne_txax	= 8			; TXA
00D800  2               mne_txsx	= 69			; TXS
00D800  2               mne_txyx	= 90			; XXY
00D800  2               mne_tyax	= 9			; TYA
00D800  2               mne_tyxx	= 81			; TYX
00D800  2               mne_waix	= 21			; WAI
00D800  2               mne_wdmx	= 47			; WDM
00D800  2               mne_xbax	= 0			; XBA
00D800  2               mne_xcex	= 30			; XCE
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Miscellaneous constants
00D800  2               ;------------------------------------------------------------------------------
00D800  2               halfTab		= 4			; 1/2 tabulation spacing
00D800  2               memPrefix	= '>'			; Memory dump prefix
00D800  2               memSepChar	= ':'			; Memory dump separator
00D800  2               memSubChar	= '.'			; Memory dump non-print character
00D800  2               srInit		= %00110000		; SR initialization value
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Direct page usage/storage
00D800  2               ;------------------------------------------------------------------------------
00D800  2               reg_pbx		= zeropage		; $80 - PB (Program Bank register)
00D800  2               reg_pcx		= reg_pbx + s_mpupbrx	; $81 - PC (Program Counter)
00D800  2               reg_srx		= reg_pcx + s_mpupcx	; $83 - SR (MPU status)
00D800  2               reg_ax		= reg_srx + s_mpusrx	; $84 - .C (.B (MSB) .A (LSB) register(s))
00D800  2               reg_xx		= reg_ax  + s_word	; $86 - .X (.X register)
00D800  2               reg_yx		= reg_xx  + s_word	; $88 - .Y (.Y register)
00D800  2               reg_spx		= reg_yx  + s_word	; $8a - SP (Stack pointer)
00D800  2               reg_dpx		= reg_spx + s_mpuspx	; $8c - DP (Direct Page)
00D800  2               reg_dbx		= reg_dpx + s_mpudpx	; $8e - DB (Data Bank register)
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; General workspace
00D800  2               ;------------------------------------------------------------------------------
00D800  2               addra		= reg_dbx + s_mpudbrx	; $8f - Address #1
00D800  2               addrb		= addra   + s_address	; $92 - Address #2
00D800  2               faca		= addrb   + s_address	; $95 - Primary accumulator
00D800  2               facax		= faca    + s_pfac	; $99 - Extended primary accumulator
00D800  2               facb		= facax   + s_pfac	; $9d - Seconday accumulator
00D800  2               facc		= facb    + s_sfac	; $a1 - Tertiary accumulator
00D800  2               operand		= facc    + s_sfac	; $a5 - Instruction operand
00D800  2               auxbufindex	= operand + s_oper	; $a8 - Auxiliary buffer index
00D800  2               ibufidx		= auxbufindex + s_byte	; $a9 - Input buffer index
00D800  2               bitsdig		= ibufidx + s_byte	; $aa - Bits per numeral
00D800  2               numeral		= bitsdig + s_byte	; $ab - Numeral buffer
00D800  2               radix		= numeral + s_byte	; $ac - Radix index
00D800  2               admodidx	= radix   + s_byte	; $ad - Addressing mode index
00D800  2               charcnt		= admodidx  + s_byte	; $ae - Character count
00D800  2               instsize	= charcnt + s_word	; $b0 - Instruction size
00D800  2               mnepck		= instsize  + s_word	; $b2 - Encoded mnemonic
00D800  2               opcode		= mnepck  + s_mnepck	; $b4 - Current opcode
00D800  2               status		= opcode  + s_byte	; $b5 - I/O status flag
00D800  2               xrtemp		= status  + s_byte	; $b6 - Temporary .X storage (16-bit)
00D800  2               eopsize		= xrtemp  + s_byte	; $b8 - Entered operand size
00D800  2               flimflag	= eopsize + s_byte	; $b9 - Forced long immediate
00D800  2               vecbrkia	= flimflag  + s_byte	; $ba - System indirect BRK vector
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; During assembly, FLIMFLAG indicates the operand size used with an immediate
00D800  2               ; mode instruction, thus causing the following disassembly to display the
00D800  2               ; assembled operand size. During disassembly, FLIMFLAG will mirror the effect
00D800  2               ; of the most recent REP or SEP instruction.
00D800  2               ;------------------------------------------------------------------------------
00D800  2               iopsize		= vecbrkia + s_word	; $bc - Operand size
00D800  2               range		= iopsize + s_byte	; $bd - Allowable radix range
00D800  2               vopsflag	= range   + s_byte	; $be - VOPS & ROPS mode bits
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Copy/fill workspace (overlap with some of above)
00D800  2               ;------------------------------------------------------------------------------
00D800  2               mcftwork	= faca			; $95 - Start of copy/fill code
00D800  2               mcftopc		= mcftwork  + s_byte	; $96 - Instruction opcode
00D800  2               mcftbnk		= mcftopc   + s_byte	; $97 - Banks
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ; Math temporary storage
00D800  2               ;------------------------------------------------------------------------------
00D800  2               add1L		= vopsflag  + s_byte
00D800  2               add1H		= add1L     + s_byte
00D800  2               add2L		= add1L     + s_word
00D800  2               add2H		= add2L     + s_byte
00D800  2               sum1L		= add2L     + s_word
00D800  2               sum1H		= sum1L     + s_byte
00D800  2               ;
00D800  2               ;------------------------------------------------------------------------------
00D800  2               ;   S U P E R M O N   8 1 6   J U M P   T A B L E
00D800  2               ;------------------------------------------------------------------------------
00D800  2               	.org	SYSMONITOR
00D800  2               JMON:
00D800  2  80 02        	bra 	mon			; Cold start entry
00D802  2               JMONBRK:
00D802  2  80 3A        	bra 	monbrk			; Software interrupt intercept
00D804  2               
00D804  2               ;------------------------------------------------------------------------------
00D804  2               ; Supermon 816 Cold start
00D804  2               ;------------------------------------------------------------------------------
00D804  2               mon:
00D804  2  C2 20        	longa				; Set 16-bit .A
00D806  2               
00D806  2  AD DC 02     	lda	vecbrki			; Get current BRK vector
00D809  2  C9 3E D8     	cmp	#monbrk			; Pointing at monitor?
00D80C  2               ;	bne	@continue
00D80C  2               ;	jmp	monreg			; Yes, ignore cold start
00D80C  2  F0 63        	beq	monreg			; yes, ignore cold start
00D80E  2               
00D80E  2               @continue:
00D80E  2  85 BD        	sta	vecbrkia		; Save vector for exit
00D810  2               
00D810  2  A9 3E D8     	lda	#monbrk			; Supermon should intercept BRK
00D813  2  8D DC 02     	sta	vecbrki			; handler
00D816  2               
00D816  2  E2 30        	shortr				; Set 8-bit registers
00D818  2               
00D818  2  A2 41        	ldx	#vopsflag - reg_pbx
00D81A  2               @a:
00D81A  2  74 80        	stz	reg_pbx, X		; Clear DP storage
00D81C  2  CA           	dex
00D81D  2  10 FB        	bpl	@a
00D81F  2               ;------------------------------------------------------------------------------
00D81F  2               ; Initialize register shadows
00D81F  2               ;------------------------------------------------------------------------------
00D81F  2  A9 30        	lda	#srInit
00D821  2  85 83        	sta	reg_srx			; SR (Status Register)
00D823  2               
00D823  2  C2 20        	longa				; 16-bit .A
00D825  2               
00D825  2  A9 FF 7F     	lda	#hwstack		; Top of hardware stack
00D828  2  1B           	tcs				; Set up SP (Stack Pointer)
00D829  2  7B           	tdc				; Get DP (Direct Page) pointer
00D82A  2  85 8C        	sta	reg_dpx			; ... and save
00D82C  2  A9 00 00     	lda	#$0000
00D82F  2               
00D82F  2  E2 20        	shorta				; 8-Bit .A
00D831  2               
00D831  2  4B           	phk				; Push Program Bank to stack
00D832  2  68           	pla				; ... and save it
00D833  2  85 80        	sta	reg_pbx
00D835  2  8B           	phb				; Push Data Bank to stack
00D836  2  68           	pla				; ... and save it
00D837  2  85 8E        	sta	reg_dbx
00D839  2               ;------------------------------------------------------------------------------
00D839  2               ; Print startup banner
00D839  2               ;------------------------------------------------------------------------------
00D839  2  F4 C7 E7     	pea	mm_entry		; "...ready..."
00D83C  2  80 22        	bra	moncom
00D83E  2               
00D83E  2               ;------------------------------------------------------------------------------
00D83E  2               ; monbrk - Software Interrupt Intercept
00D83E  2               ;
00D83E  2               ;  This is the entry point taken when a BRK instruction is executed.  It is
00D83E  2               ;  assumed that the BRK  handler has pushed the registers to the stack that
00D83E  2               ;  are not automatically pushed by the MPU in response to BRK.
00D83E  2               ;------------------------------------------------------------------------------
00D83E  2               monbrk:
00D83E  2               ;	cld				; Make sure decimal mode is offset
00D83E  2               ;	clc				; Go to native mode, just to make sure
00D83E  2               ;	xce
00D83E  2               ;	phb				; Save DB
00D83E  2               ;	phd				; Save DP
00D83E  2               ;
00D83E  2               ;	longr				; 16-Bit registers
00D83E  2               
00D83E  2  58           	cli				; Re-enable interrupts
00D83F  2  7A           	ply
00D840  2  FA           	plx
00D841  2  68           	pla
00D842  2               
00D842  2  C2 30        	longr
00D844  2               
00D844  2  85 84        	sta	reg_ax			; Save .C (.B and .A)
00D846  2  86 86        	stx	reg_xx			; Save .X
00D848  2  84 88        	sty	reg_yx			; Save .Y
00D84A  2               
00D84A  2  E2 10        	shorti				; 8-Bit .X and .Y
00D84C  2               
00D84C  2  68           	pla				; Save DP (16-bits)
00D84D  2  85 8C        	sta	reg_dpx
00D84F  2  FA           	plx				; Save DB (8-bits)
00D850  2  86 8E        	stx	reg_dbx
00D852  2  FA           	plx				; Save SR (Processor Status)
00D853  2  86 83        	stx	reg_srx
00D855  2  68           	pla				; Save PC (Program Counter)
00D856  2  85 81        	sta	reg_pcx
00D858  2               ;	plx				; Save PB
00D858  2               ;	stx	reg_pbx
00D858  2               
00D858  2               ;	lda	#hwstack		; Set top of hardware stack
00D858  2               ;	tcs				; Set SP (Stack Pointer)
00D858  2               ;	lda	#$0000			; Set DP
00D858  2               ;	tcd
00D858  2               ;	ldx	#$00			; Set DB (Data Bank)
00D858  2               ;	phx
00D858  2               ;	plb
00D858  2  E2 20        	shorta
00D85A  2  68           	pla
00D85B  2  85 80        	sta	reg_pbx			; Save PB
00D85D  2  F4 BF E7     	pea	mm_brk			; *BRK
00D860  2               
00D860  2               ;------------------------------------------------------------------------------
00D860  2               ; moncom: Common Entry Pointer
00D860  2               ;
00D860  2               ; === DO NOT CALL THIS ENTRY POINT ===
00D860  2               ;------------------------------------------------------------------------------
00D860  2               moncom:
00D860  2  20 D9 DF     	jsr	sprint			; Print heading
00D863  2               
00D863  2  C2 20        	longa				; Make sure we have a 16-bit .A
00D865  2               
00D865  2  3B           	tsc				; get current SP (Stack Pointer)
00D866  2  85 8A        	sta	reg_spx
00D868  2  C2 FF        	rep	#%11111111		; Clear SR (Processor Status)
00D86A  2  EA           	nop				; Added two NOPs after REP
00D86B  2  EA           	nop
00D86C  2  E2 30        	sep	#srInit			; Set default Processor flags
00D86E  2  EA           	nop				; Added two NOPs after SEP
00D86F  2  EA           	nop
00D870  2  38           	sec				; Needed for next branch
00D871  2               
00D871  2               ;------------------------------------------------------------------------------
00D871  2               ; monreg: Display MPU Registers
00D871  2               ;
00D871  2               ; Syntax: R
00D871  2               ;------------------------------------------------------------------------------
00D871  2               monreg:
00D871  2  B0 03        	bcs	@a			; Okay to proceed
00D873  2  4C FF D8     	jmp	monerr			; Error if called with a parameter
00D876  2               
00D876  2               @a:
00D876  2  F4 0A E8     	pea	mm_regs
00D879  2  20 D9 DF     	jsr	sprint			; Display heading
00D87C  2               ;------------------------------------------------------------------------------
00D87C  2               ; Display Program bank and Program Counter
00D87C  2               ;------------------------------------------------------------------------------
00D87C  2  A5 80        	lda	reg_pbx			; First process PB
00D87E  2  20 AD DF     	jsr	dpyhex			; Display as hex ASCII
00D881  2  20 D4 DF     	jsr	printspc		; Print interfield-space
00D884  2               
00D884  2  C2 20        	longa				; Make sure we have a 16-bit .A
00D886  2               
00D886  2  A5 81        	lda	reg_pcx			; Next show the PC (Program Counter)
00D888  2               
00D888  2  E2 20        	shorta				; Return to 8-bit .A
00D88A  2               
00D88A  2  20 9D DF     	jsr	dpyhexw			; Go print as 2 byte hex ASCII
00D88D  2  A2 02        	ldx	#$02			; Print 2 spaces ...
00D88F  2  20 B7 DF     	jsr	multspc			; ...for inter-field spacing
00D892  2               ;------------------------------------------------------------------------------
00D892  2               ; Display SR (Processor Status) bitwise
00D892  2               ;------------------------------------------------------------------------------
00D892  2  A6 83        	ldx	reg_srx
00D894  2  A0 08        	ldy	#s_bibyte		; Number of bits in a byte (duh!)
00D896  2               @b:
00D896  2  8A           	txa				; Remaining SR bits
00D897  2  0A           	asl				; Get one of them
00D898  2  AA           	tax				; Save remainder
00D899  2  A9 30        	lda	#'0'			; A clear bit, but ...
00D89B  2  69 00        	adc	#0			; If carry is set, we get a '1'
00D89D  2  20 0C FD     	jsr	putcha			; Print the byte
00D8A0  2  88           	dey				; Current bit done...
00D8A1  2  D0 F3        	bne	@b			; Do we have any more?
00D8A3  2               ;------------------------------------------------------------------------------
00D8A3  2               ; Display .C, .X, .Y, SP and DP
00D8A3  2               ;------------------------------------------------------------------------------
00D8A3  2               @c:
00D8A3  2  20 D4 DF     	jsr	printspc
00D8A6  2               
00D8A6  2  C2 20        	longa				; 16-Bit .A
00D8A8  2               
00D8A8  2  B9 84 00     	lda	reg_ax, y		; Get register value
00D8AB  2               
00D8AB  2  E2 20        	shorta				; 8-bit .A
00D8AD  2               
00D8AD  2  20 9D DF     	jsr	dpyhexw			; Convert and print
00D8B0  2  C8           	iny
00D8B1  2  C8           	iny
00D8B2  2  C0 0A        	cpy	#reg_dbx-reg_ax		; Are we done processing?
00D8B4  2  90 ED        	bcc	@c			; Nope, get next
00D8B6  2               ;------------------------------------------------------------------------------
00D8B6  2               ; Show DB
00D8B6  2               ;------------------------------------------------------------------------------
00D8B6  2  20 D4 DF     	jsr	printspc		; One more space
00D8B9  2  A5 8E        	lda	reg_dbx			; Get DB
00D8BB  2  20 AD DF     	jsr	dpyhex			; Display as hex ASCII
00D8BE  2               
00D8BE  2               ;------------------------------------------------------------------------------
00D8BE  2               ; monce: Command Executive
00D8BE  2               ;------------------------------------------------------------------------------
00D8BE  2               monce:
00D8BE  2  E2 20        	shorta				; 8-Bit .A
00D8C0  2               
00D8C0  2  A9 00        	lda	#$00			; Default buffer index
00D8C2  2               ;
00D8C2  2               moncea:					; Alternate entry point
00D8C2  2  48           	pha
00D8C3  2               
00D8C3  2               ; Migrating to gLCD
00D8C3  2               ;	jsr	lcd_clear
00D8C3  2               ;	pea	mm_monce
00D8C3  2               ;	jsr	lcd_sprint
00D8C3  2               
00D8C3  2  68           	pla
00D8C4  2               
00D8C4  2  E2 30        	shortr				; 8-bit .A, .X and .Y
00D8C6  2               
00D8C6  2  85 AD        	sta	ibufidx			; (Re)set buffer index
00D8C8  2  F4 06 E8     	pea	mm_prmpt
00D8CB  2  20 D9 DF     	jsr	sprint			; Display input prompt
00D8CE  2  20 F0 E3     	jsr	input			; Wait for some input
00D8D1  2               
00D8D1  2               @a:
00D8D1  2  20 40 E4     	jsr	getcharc		; Read from buffer
00D8D4  2  F0 E8        	beq	monce			; Reached a terminator, just loop
00D8D6  2               
00D8D6  2  C9 20        	cmp	#SPACE			; Strip off any leading spaces
00D8D8  2  F0 F7        	beq	@a
00D8DA  2               
00D8DA  2  A2 0D        	ldx	#n_mpctab - 1		; Number of primary commands
00D8DC  2               
00D8DC  2               @b:
00D8DC  2  DD 6C E4     	cmp	mpctab, X		; Search primary command list
00D8DF  2  D0 0E        	bne	@c
00D8E1  2               
00D8E1  2  8A           	txa				; Get index number
00D8E2  2  0A           	asl				; Double for offset
00D8E3  2  AA           	tax
00D8E4  2               
00D8E4  2  C2 20        	longa				; 16-bit .A
00D8E6  2               
00D8E6  2  BD 7A E4     	lda	mpcextab, X		; Command address - 1
00D8E9  2               
00D8E9  2  48           	pha				; Throw on stack
00D8EA  2               
00D8EA  2  E2 20        	shorta				; 8-bit .A
00D8EC  2               
00D8EC  2  4C 94 E2     	jmp	getparm			; Evaluate parameters and ...
00D8EF  2               					; ... execute command
00D8EF  2               
00D8EF  2               @c:
00D8EF  2  CA           	dex
00D8F0  2  10 EA        	bpl	@b			; Continue searching primary commands
00D8F2  2  A2 03        	ldx	#n_radix - 1		; Number of radices
00D8F4  2               
00D8F4  2               @d:
00D8F4  2  DD AA E4     	cmp	radxtab, X		; Search conversion command list
00D8F7  2  D0 03        	bne	@e
00D8F9  2               
00D8F9  2  4C 53 DD     	jmp	monenv			; Convert and display parameter
00D8FC  2               @e:
00D8FC  2  CA           	dex
00D8FD  2  10 F5        	bpl	@d
00D8FF  2               
00D8FF  2               ;------------------------------------------------------------------------------
00D8FF  2               ; monerr: Common Error handler
00D8FF  2               ;------------------------------------------------------------------------------
00D8FF  2               monerr:
00D8FF  2               ; Migrating to gLCD
00D8FF  2               ;	jsr	lcd_clear
00D8FF  2               ;	pea	mm_monerr
00D8FF  2               ;	jsr	lcd_sprint
00D8FF  2               
00D8FF  2  E2 10        	shorti				; 8-Bit indexes
00D901  2               
00D901  2               monerraa:
00D901  2  20 84 DF     	jsr	dpyerr			; Indicate an error and ...
00D904  2  80 B8        	bra	monce			; ... return to main input loop
00D906  2               
00D906  2               ;------------------------------------------------------------------------------
00D906  2               ; monasc: Assemble Code
00D906  2               ;
00D906  2               ;	syntax: A <addr> <mnemonic> [<argument>]
00D906  2               ;
00D906  2               ;	After a line of code has been successfully assembled it will be disass-
00D906  2               ;	embled & displayed,  & the monitor will prompt with the next address to
00D906  2               ;	which code may be assembled.
00D906  2               ;------------------------------------------------------------------------------
00D906  2               monasc:
00D906  2  90 03        	bcc	@b			; Assemble address entered
00D908  2               @a:
00D908  2  4C FF D8     	jmp	monerr			; Terminate with error
00D90B  2               ;------------------------------------------------------------------------------
00D90B  2               ; Evaluate assembly address
00D90B  2               ;------------------------------------------------------------------------------
00D90B  2               @b:
00D90B  2               ; Migrating to gLCD
00D90B  2               ;	jsr	lcd_clear
00D90B  2               ;	pea	mm_monasc
00D90B  2               ;	jsr	lcd_sprint
00D90B  2               
00D90B  2  20 84 E2     	jsr	facasize		; Check address
00D90E  2  C9 04        	cmp	#s_dword		; Range?
00D910  2  B0 F6        	bcs	@a			; Out of range -> error
00D912  2               
00D912  2  20 60 E2     	jsr	facaddra		; Store assembly address
00D915  2               
00D915  2               ;------------------------------------------------------------------------------
00D915  2               ; Initialize workspace
00D915  2               ;------------------------------------------------------------------------------
00D915  2  A2 1F        	ldx	#s_auxBuffer - s_byte
00D917  2               @c:
00D917  2  9E 46 02     	stz	auxbuf, X		; Clear addressing mode buffer
00D91A  2  CA           	dex
00D91B  2  D0 FA        	bne	@c
00D91D  2               
00D91D  2  A9 20        	lda	#SPACE
00D91F  2  8D 46 02     	sta	auxbuf			; Preamble placeholder
00D922  2  20 E4 E1     	jsr	clroper			; Clear operand
00D925  2  64 AC        	stz	auxbufindex		; Reset addressing mode index
00D927  2  64 BC        	stz	flimflag		; Clear forced log immediate
00D929  2  64 B6        	stz	mnepck			; Clear encoded ...
00D92B  2  64 B7        	stz	mnepck + s_byte		; ... mnemonic workspace
00D92D  2  64 C1        	stz	vopsflag		; Clear 8/16 or relative flag
00D92F  2               ;------------------------------------------------------------------------------
00D92F  2               ; Encode mnemonic
00D92F  2               ;------------------------------------------------------------------------------
00D92F  2  A0 03        	ldy	#s_mnemonic		; Expected mnemonic size
00D931  2               @d:
00D931  2  20 E1 E3     	jsr	getcharw		; Get from buffer w/o whitespace
00D934  2  D0 0A        	bne	@f			; Did we get any?
00D936  2               
00D936  2  C0 03        	cpy	#s_mnemonic		; Did we get anything at all?
00D938  2  90 03        	bcc	@e			; Yes
00D93A  2               
00D93A  2  4C BE D8     	jmp	monce			; No, abort further assembly
00D93D  2               
00D93D  2               @e:
00D93D  2  4C DD DA     	jmp	monasc10		; incomplete mnemonic -> error
00D940  2               
00D940  2               @f:
00D940  2  38           	sec
00D941  2  E9 3F        	sbc	#a_mnecvt		; ASCII to binary factor
00D943  2  A2 05        	ldx	#n_shfEncode		; Shifts required to encode
00D945  2               
00D945  2               @g:
00D945  2  4A           	lsr				; Shift out a bit ...
00D946  2  66 B7        	ror	mnepck + s_byte		; ... into ...
00D948  2  66 B6        	ror	mnepck			; ... an encoded mnemonic
00D94A  2  CA           	dex
00D94B  2  D0 F8        	bne	@g			; Next bit
00D94D  2               
00D94D  2  88           	dey
00D94E  2  D0 E1        	bne	@d			; Get next character
00D950  2               ;------------------------------------------------------------------------------
00D950  2               ; Test for copy instruction
00D950  2               ;
00D950  2               ;	The MVN & MVP instructions accept two operands & hence have an irregular
00D950  2               ;	syntax.  Therefore, special handling is necessary to assemble either of
00D950  2               ;	these instructions.
00D950  2               ;
00D950  2               ;	The official WDC syntax has the programmer entering a pair of 24 bit ad-
00D950  2               ;	dresses as operands, with the assembler isolating bits 16-23 to	use as
00D950  2               ;	operands.  This formality has been dispensed with in this monitor & the
00D950  2               ;	operands are expected to be 8 bit bank values.
00D950  2               ;------------------------------------------------------------------------------
00D950  2  C2 20        	longa				; 16-Bit .A
00D952  2               
00D952  2  A5 B6        	lda	mnepck			; Retrieve packed mnemonic
00D954  2  A2 54        	ldx	#opc_mvn		; MVN opcode
00D956  2  C9 DC 7D     	cmp	#mne_mvn		; Is it MVN?
00D959  2  F0 07        	beq	monasc01		; Yes
00D95B  2               
00D95B  2  A2 44        	ldx	#opc_mvp		; MVP opcode
00D95D  2  C9 DC 8D     	cmp	#mne_mvp		; Is it a MVP, then?
00D960  2  D0 30        	bne	monasc02		; No?
00D962  2               
00D962  2               ;------------------------------------------------------------------------------
00D962  2               ; Assembly copy instruction
00D962  2               ;------------------------------------------------------------------------------
00D962  2               monasc01:
00D962  2  86 B8        	stx	opcode			; Store relevant opcode
00D964  2               
00D964  2  E2 20        	shorta				; 8-Bit .A
00D966  2               
00D966  2  20 F2 E2     	jsr	instdata		; Get instruction data
00D969  2  86 BB        	stx	eopsize			; Effective operand size
00D96B  2  E8           	inx
00D96C  2  86 B4        	stx	instsize		; Instruction size
00D96E  2  A2 01        	ldx	#s_oper - s_word	; operand index
00D970  2  86 BA        	stx	xrtemp			; Set it
00D972  2               
00D972  2               @a:
00D972  2  20 F8 DF     	jsr	ascbin			; Evaluate bank number
00D975  2  B0 50        	bcs	monasc04		; Conversion error
00D977  2  F0 4E        	beq	monasc04		; Returned nothing -> error
00D979  2               
00D979  2  20 84 E2     	jsr	facasize		; Bank must be ...
00D97C  2  C9 02        	cmp	#s_word			; ... 8 Bits
00D97E  2  B0 47        	bcs	monasc04		; If it isn't -> error
00D980  2               
00D980  2  A5 95        	lda	faca			; Retrieve bank
00D982  2  A6 BA        	ldx	xrtemp			; Get operand index
00D984  2  95 A9        	sta	operand, X		; Store it
00D986  2  C6 BA        	dec	xrtemp			; Index = index - 1
00D988  2  10 E8        	bpl	@a			; Get destination bank
00D98A  2               
00D98A  2  20 7D E3     	jsr	getcharr		; There should be no more input
00D98D  2  D0 38        	bne	monasc04		; If there is -> error
00D98F  2               
00D98F  2  4C 8D DA     	jmp	monasc08		; Finish MVN/MVP assembly
00D992  2               
00D992  2               ;------------------------------------------------------------------------------
00D992  2               ; Continue normal assembly
00D992  2               ;------------------------------------------------------------------------------
00D992  2               monasc02:
00D992  2  E2 20        	shorta				; Back to 8-bit .A
00D994  2               
00D994  2               monasc03:
00D994  2  20 E1 E3     	jsr	getcharw		; Get next character
00D997  2  F0 3D        	beq	monasc06		; EOI, no argument
00D999  2               
00D999  2  C9 21        	cmp	#amp_flim		; Test for forced log immediate
00D99B  2  D0 0A        	bne	@a			; No forced long immediate
00D99D  2               
00D99D  2  A5 BC        	lda	flimflag		; FLIM already set?
00D99F  2  D0 26        	bne	monasc04		; Yes -> error
00D9A1  2               
00D9A1  2  A9 C0        	lda	#flimmask
00D9A3  2  85 BC        	sta	flimflag		; Set flag and ...
00D9A5  2  80 ED        	bra	monasc03		; Get next character
00D9A7  2               
00D9A7  2               @a:
00D9A7  2  C9 23        	cmp	#amp_imm		; Immidiate mode?
00D9A9  2  F0 08        	beq	@b			; Yes
00D9AB  2               
00D9AB  2  C9 28        	cmp	#amp_ind		; Indirect mode?
00D9AD  2  F0 04        	beq	@b			; Yes
00D9AF  2               
00D9AF  2  C9 5B        	cmp	#amp_indl		; Indirect long mode?
00D9B1  2  D0 07        	bne	@c			; No
00D9B3  2               
00D9B3  2               @b:
00D9B3  2  8D 46 02     	sta	auxbuf			; Set addressing mode preamble
00D9B6  2  E6 AC        	inc 	auxbufindex		; Bump aux buffer index and ...
00D9B8  2  80 02        	bra	@d			; ... evaluate operand
00D9BA  2               
00D9BA  2               @c:
00D9BA  2  C6 AD        	dec	ibufidx			; Position back to character
00D9BC  2               
00D9BC  2               @d:
00D9BC  2  20 F8 DF     	jsr	ascbin			; Evaluate operand
00D9BF  2  D0 09        	bne	monasc05		; Evaluated...
00D9C1  2               
00D9C1  2  B0 04        	bcs	monasc04		; Conversion failed -> error
00D9C3  2               
00D9C3  2  A5 AC        	lda	auxbufindex		; No operand... Any preamble?
00D9C5  2  F0 0F        	beq	monasc06		; No, syntax is okay so far ...
00D9C7  2               
00D9C7  2               monasc04:
00D9C7  2  4C DD DA     	jmp	monasc10		; Abort w/ error
00D9CA  2               
00D9CA  2               monasc05:
00D9CA  2  20 84 E2     	jsr	facasize		; Size operand
00D9CD  2  C9 04        	cmp	#s_dword		; maximum is 8-bits
00D9CF  2  B0 F6        	bcs	monasc04		; Too big -> error
00D9D1  2               
00D9D1  2  85 BB        	sta	eopsize			; Save operand size
00D9D3  2  20 78 E2     	jsr	facaoper		; Store operand
00D9D6  2               
00D9D6  2               monasc06:
00D9D6  2  C6 AD        	dec	ibufidx			; Back to last character
00D9D8  2  A6 AC        	ldx	auxbufindex		; mode buffer index
00D9DA  2  D0 01        	bne	@a			; Preamble in buffer
00D9DC  2               
00D9DC  2  E8           	inx				; Step past preamble position
00D9DD  2               
00D9DD  2               @a:
00D9DD  2  20 40 E4     	jsr	getcharc		; Get a char w/ forced UC
00D9E0  2  F0 0A        	beq	@c			; EOI (End-Of-Input)
00D9E2  2               
00D9E2  2  E0 20        	cpx	#s_auxBuffer		; mode buffer full?
00D9E4  2  B0 E1        	bcs	monasc04		; Yes, too much input -> error
00D9E6  2               
00D9E6  2               @b:
00D9E6  2  9D 46 02     	sta	auxbuf, X		; Store for comparison
00D9E9  2  E8           	inx
00D9EA  2  D0 F1        	bne	@a
00D9EC  2               
00D9EC  2               ;------------------------------------------------------------------------------
00D9EC  2               ; Evaluate mnemonic
00D9EC  2               ;------------------------------------------------------------------------------
00D9EC  2               @c:
00D9EC  2  A2 5B        	ldx	#n_mnemon - 1		; Starting mnemonic index
00D9EE  2               
00D9EE  2               monasc07:
00D9EE  2  8A           	txa				; Convert index ...
00D9EF  2  0A           	asl				; ... to offset
00D9F0  2  A8           	tay				; Now mnemonic table index
00D9F1  2               
00D9F1  2  C2 20        	longa				; 16-bit .A for 16-bit compare
00D9F3  2               
00D9F3  2  B9 B7 E4     	lda	mnetab, Y		; Get mnemonic from table
00D9F6  2  C5 B6        	cmp	mnepck			; Compare to entered mnemonic
00D9F8  2               
00D9F8  2  E2 20        	shorta				; Back to 8-bit .A
00D9FA  2               
00D9FA  2  F0 05        	beq	@b			; Match
00D9FC  2               
00D9FC  2               @a:
00D9FC  2  CA           	dex				; Try next mnemonic
00D9FD  2  30 C8        	bmi	monasc04		; Unknown mnemonic -> error
00D9FF  2               
00D9FF  2  80 ED        	bra	monasc07		; Kep on going ...
00DA01  2               
00DA01  2               @b:
00DA01  2  86 B6        	stx	mnepck			; Save mnemonic index
00DA03  2  8A           	txa
00DA04  2  A2 00        	ldx	#$00			; Trial opcode
00DA06  2               
00DA06  2               @c:
00DA06  2  DD 6F E5     	cmp	mnetabidx, X		; Search index table ...
00DA09  2  F0 05        	beq	@e			; ... for a match
00DA0B  2               
00DA0B  2               @d:
00DA0B  2  E8           	inx				; Keep on going until ...
00DA0C  2  D0 F8        	bne	@c			; ... we searched the entire table
00DA0E  2               
00DA0E  2  80 B7        	bra	monasc04		; We shouldn't get here :(
00DA10  2               
00DA10  2               ;------------------------------------------------------------------------------
00DA10  2               ;	If the mnemonic index table search fails then there is a coding error
00DA10  2               ;	somewhere, as every entry in the mnemonic table is supposed to have a
00DA10  2               ;	matching cardinal index.
00DA10  2               ;------------------------------------------------------------------------------
00DA10  2               
00DA10  2               
00DA10  2               ;------------------------------------------------------------------------------
00DA10  2               ; Evaluate addressing mode
00DA10  2               ;------------------------------------------------------------------------------
00DA10  2               @e:
00DA10  2  86 B8        	stx	opcode			; Save trial opcode
00DA12  2  20 F2 E2     	jsr	instdata		; Get related instruction data
00DA15  2  85 C1        	sta	vopsflag		; Save 8/16 or relative flag
00DA17  2  86 BF        	stx	iopsize			; Save operand size
00DA19  2  E8           	inx
00DA1A  2  86 B4        	stx	instsize		; Save instruction size
00DA1C  2  A6 B8        	ldx	opcode			; Recover trial opcode
00DA1E  2  98           	tya				; Addressing mode
00DA1F  2  0A           	asl				; Create table index
00DA20  2  A8           	tay
00DA21  2               
00DA21  2  C2 20        	longa				; 16-Bit .A
00DA23  2               
00DA23  2  B9 73 E7     	lda	ms_lutab, Y		; Mode lookup table
00DA26  2  85 92        	sta	addrb			; Set pointer
00DA28  2               
00DA28  2  E2 20        	shorta				; 8-Bit .A
00DA2A  2               
00DA2A  2  A0 00        	ldy	#$00
00DA2C  2               
00DA2C  2               @f:
00DA2C  2  B1 92        	lda	(addrb), Y		; Table addressing mode
00DA2E  2  D9 46 02     	cmp	auxbuf, Y		; Compare with entered addressing mode
00DA31  2  F0 04        	beq	@h			; Looks okay, so far
00DA33  2               
00DA33  2               @g:
00DA33  2  A5 B6        	lda	mnepck			; Reload mnemonic index
00DA35  2  80 D4        	bra	@d			; Wrong opcode for addressing mode
00DA37  2               
00DA37  2               @h:
00DA37  2  09 00        	ora	#$00			; Is the last character the terminator?
00DA39  2  F0 03        	beq	@i			; Yes, evaluate operand
00DA3B  2               
00DA3B  2  C8           	iny
00DA3C  2  80 EE        	bra	@f			; Keep testing
00DA3E  2               
00DA3E  2               ;------------------------------------------------------------------------------
00DA3E  2               ; Evaluate operand
00DA3E  2               ;------------------------------------------------------------------------------
00DA3E  2               @i:
00DA3E  2  A5 BB        	lda	eopsize			; Retrieve entered operand size
00DA40  2  D0 06        	bne	@j			; Non-zero
00DA42  2               
00DA42  2  05 BF        	ora	iopsize			; Instruction operand size
00DA44  2  D0 ED        	bne	@g			; Wrong opcode -> keep trying
00DA46  2               
00DA46  2  80 45        	bra	monasc08		; Assembly instruction
00DA48  2               
00DA48  2               @j:
00DA48  2  24 C1        	bit	vopsflag		; Is it a branch?
00DA4A  2  70 3A        	bvs	@p			; Yes -> evaluate
00DA4C  2               
00DA4C  2  A5 BF        	lda	iopsize			; Instruction operand size
00DA4E  2  24 C1        	bit	vopsflag		; Variable size operand allowed?
00DA50  2  30 15        	bmi	@m			; Yes ...
00DA52  2               
00DA52  2  24 BC        	bit	flimflag		; Was forced immediate set?
00DA54  2  10 03        	bpl	@k			; No
00DA56  2               
00DA56  2  4C DD DA     	jmp	monasc10		; Yes -> error
00DA59  2               
00DA59  2               @k:
00DA59  2  C5 BB        	cmp	eopsize			; Compare to entered operand size
00DA5B  2  90 D6        	bcc	@g			; Operand too big
00DA5D  2               
00DA5D  2  85 BB        	sta	eopsize			; New operand size
00DA5F  2  80 2C        	bra	monasc08		; Assemble, otherwise ...
00DA61  2               
00DA61  2               @l:
00DA61  2  C5 BB        	cmp	eopsize			; Exact size match required
00DA63  2  D0 CE        	bne	@g			; Mismatch -> wrong opcode
00DA65  2               
00DA65  2  80 26        	bra	monasc08		; Assemble
00DA67  2               
00DA67  2               ;------------------------------------------------------------------------------
00DA67  2               ; Process variable size immediate mode operand
00DA67  2               ;------------------------------------------------------------------------------
00DA67  2               @m:
00DA67  2  A6 BB        	ldx	eopsize			; Entered operand size
00DA69  2  E0 02        	cpx	#s_word			; Check size -> 16 bits?
00DA6B  2  B0 70        	bcs	monasc10		; Too big -> error
00DA6D  2               
00DA6D  2  24 BC        	bit	flimflag		; Forced long immediate?
00DA6F  2  10 06        	bpl	@n			; No
00DA71  2               
00DA71  2  A2 02        	ldx	#s_word			; Promote operand size to ...
00DA73  2  86 BB        	stx	eopsize			; ... 16 bits
00DA75  2  80 08        	bra	@o
00DA77  2               
00DA77  2               @n:
00DA77  2  E0 02        	cpx	#s_word			; 16-Bits?
00DA79  2  D0 04        	bne	@o			; Nope....
00DA7B  2               
00DA7B  2  A0 C0        	ldy	#flimmask		; Yes, so force long
00DA7D  2  84 BC        	sty	flimflag		; Immediate disassembly
00DA7F  2               
00DA7F  2               @o:
00DA7F  2  1A           	ina				; New instruction operand size
00DA80  2  C5 BB        	cmp	eopsize			; Compare against eoprand size
00DA82  2  90 AF        	bcc	@g			; Mismatch, cannot assemble
00DA84  2               
00DA84  2  80 07        	bra	monasc08		; Okay, assemble
00DA86  2               
00DA86  2               ;------------------------------------------------------------------------------
00DA86  2               ; Process relative branch
00DA86  2               ;------------------------------------------------------------------------------
00DA86  2               @p:
00DA86  2  20 3E E3     	jsr	targoff			; Compute branch offset
00DA89  2  B0 52        	bcs	monasc10		; Branche out of range -> error
00DA8B  2               
00DA8B  2  85 BB        	sta	eopsize			; Effectice operand size
00DA8D  2               
00DA8D  2               ;------------------------------------------------------------------------------
00DA8D  2               ; Assemble instruction
00DA8D  2               ;------------------------------------------------------------------------------
00DA8D  2               monasc08:
00DA8D  2  A5 B8        	lda	opcode			; Get opcode
00DA8F  2  87 8F        	sta	[addra]			; Store at assembly address
00DA91  2  A6 BB        	ldx	eopsize			; Any operand to process?
00DA93  2  F0 01        	beq	@a			; No
00DA95  2               
00DA95  2  9B           	txy				; Also store offset
00DA96  2               
00DA96  2               @a:
00DA96  2  CA           	dex
00DA97  2  B5 A9        	lda	operand, X		; Get operand byte and ...
00DA99  2  97 8F        	sta	[addra], Y		; ... store in memory
00DA9B  2  88           	dey
00DA9C  2  D0 F8        	bne	@a			; Next ...
00DA9E  2               
00DA9E  2               @b:
00DA9E  2  A9 0D        	lda	#CR
00DAA0  2  20 0C FD     	jsr	putcha			; Return to left margin
00DAA3  2  A9 41        	lda	#asmprfx		; Assembly prefix
00DAA5  2  20 3B DE     	jsr	dpycodaa		; Disassemble and display
00DAA8  2               
00DAA8  2               ;------------------------------------------------------------------------------
00DAA8  2               ; Prompt for next instruction
00DAA8  2               ;------------------------------------------------------------------------------
00DAA8  2               monasc09:
00DAA8  2  A9 20        	lda	#SPACE
00DAAA  2  A2 08        	ldx	#ascprmct - 1
00DAAC  2               
00DAAC  2               @a:
00DAAC  2  9D 00 02     	sta	ibuffer, X		; Prepare buffer for ...
00DAAF  2  CA           	dex				; ... next instruction
00DAB0  2  10 FA        	bpl	@a
00DAB2  2               
00DAB2  2  A9 41        	lda	#asmprfx		; Assemble code ...
00DAB4  2  8D 00 02     	sta	ibuffer			; prompt prefix
00DAB7  2  A5 91        	lda	addra + s_word		; Next instruction address bank
00DAB9  2  20 4F E1     	jsr	binhex			; Convert to ASCII
00DABC  2  8D 02 02     	sta	ibuffer + apadrbkh	; Store bank MSN in buffer
00DABF  2  8E 03 02     	stx	ibuffer + apadrbkl	; Store bank LSN in buffer
00DAC2  2  A5 90        	lda	addra + s_byte		; Next instruction address MSB
00DAC4  2  20 4F E1     	jsr	binhex			; Convert to ASCII
00DAC7  2  8D 04 02     	sta	ibuffer + apadrmbh	; Store address MSB MSN in buffer
00DACA  2  8E 05 02     	stx	ibuffer + apadrmbl	; Store address MSB LSN in buffer
00DACD  2  A5 8F        	lda	addra			; Next instruction address LSB
00DACF  2  20 4F E1     	jsr	binhex			; Convert to ASCII
00DAD2  2  8D 06 02     	sta	ibuffer + apadrlbh	; Store address LSB MSN in buffer
00DAD5  2  8E 07 02     	stx	ibuffer + apadrlbl	; Store address LSB LSB in buffer
00DAD8  2  A9 09        	lda	#ascprmct		; Effective input count
00DADA  2  4C C2 D8     	jmp	moncea			; Re-enter input loop
00DADD  2               
00DADD  2               ;------------------------------------------------------------------------------
00DADD  2               ; Process assembly error
00DADD  2               ;------------------------------------------------------------------------------
00DADD  2               monasc10:
00DADD  2  20 84 DF     	jsr	dpyerr			; indicate error and ...
00DAE0  2  80 C6        	bra	monasc09		; ... prompt w/ same assembly address
00DAE2  2               
00DAE2  2               ;------------------------------------------------------------------------------
00DAE2  2               ; mondsc: Disassemble Code
00DAE2  2               ;
00DAE2  2               ;	syntax: D [<addr1> [<addr2>]]
00DAE2  2               ;------------------------------------------------------------------------------
00DAE2  2               mondsc:
00DAE2  2               ; Migrating to gLCD
00DAE2  2               ;	jsr	lcd_clear
00DAE2  2               ;	pea	mm_mondsc
00DAE2  2               ;	jsr	lcd_sprint
00DAE2  2               
00DAE2  2  E2 30        	shortr
00DAE4  2  B0 11        	bcs	@a			; No parameters
00DAE6  2               
00DAE6  2  64 BC        	stz	flimflag		; Reset 8-bit mode
00DAE8  2  20 84 E2     	jsr	facasize		; Check starting ...
00DAEB  2  C9 04        	cmp	#s_dword			; ... address
00DAED  2  B0 46        	bcs	@e			; Out of range -> error
00DAEF  2               
00DAEF  2  20 60 E2     	jsr	facaddra		; Copy starting address
00DAF2  2  20 94 E2     	jsr	getparm			; Get ending address
00DAF5  2  90 17        	bcc	@b			; We got it!
00DAF7  2               
00DAF7  2               @a:
00DAF7  2  20 62 E1     	jsr	clrfaca			; Clear .A
00DAFA  2               
00DAFA  2  C2 20        	longa				; 16-bit .A
00DAFC  2               
00DAFC  2  18           	clc
00DAFD  2  A5 8F        	lda	addra			; Get start address
00DAFF  2  69 FF 00     	adc	#n_mBytes		; Default number of bytes
00DB02  2  85 95        	sta	faca			; Effective ending address
00DB04  2               
00DB04  2  E2 20        	shorta				; Returning to 8-bit .A
00DB06  2               
00DB06  2  A5 91        	lda	addra + s_word		; Get starting bank
00DB08  2  69 00        	adc	#$00			; Mind bank boundary crossing
00DB0A  2  85 95        	sta	faca			; Effective ending bank
00DB0C  2  B0 27        	bcs	@e			; End address > $FF/FFFF -> error
00DB0E  2               
00DB0E  2               @b:
00DB0E  2  20 84 E2     	jsr	facasize		; Check ending address range
00DB11  2  C9 04        	cmp	#s_dword		; 2 Bytes
00DB13  2  B0 20        	bcs	@e			; Out of range -> error
00DB15  2               
00DB15  2  20 6C E2     	jsr	facaddrb		; Copy ending address
00DB18  2  20 94 E2     	jsr	getparm			; Check for excess input
00DB1B  2  90 18        	bcc	@e			; error
00DB1D  2               
00DB1D  2  20 D0 E1     	jsr	calccnt			; Calculate # bytes to dump
00DB20  2  90 13        	bcc	@e			; end < start -> error
00DB22  2               
00DB22  2               @c:
00DB22  2  20 50 E4     	jsr	teststop		; See if display stop requested
00DB25  2  B0 0B        	bcs	@d			; Stoppped
00DB27  2               
00DB27  2  20 C4 DF     	jsr	newline			; Next line
00DB2A  2  20 37 DE     	jsr	dpycod			; Display
00DB2D  2  20 16 E2     	jsr	decdcnt			; Decrement byte count
00DB30  2  90 F0        	bcc	@c			; Until we are done ...
00DB32  2               
00DB32  2               @d:
00DB32  2  4C BE D8     	jmp	monce			; back to main loop
00DB35  2               
00DB35  2               @e:
00DB35  2  4C FF D8     	jmp	monerr			; Address range error
00DB38  2               
00DB38  2               ;------------------------------------------------------------------------------
00DB38  2               ; monjmp: Execute Code
00DB38  2               ;
00DB38  2               ;	syntax: G [<dp>]
00DB38  2               ;
00DB38  2               ;	If no address is specified, the current values in the PB & PC
00DB38  2               ;	shadow registers are used.
00DB38  2               ;------------------------------------------------------------------------------
00DB38  2               monjmp:
00DB38  2               ; Migrating to gLCD
00DB38  2               ;	jsr	lcd_clear
00DB38  2               ;	pea	mm_monjmp
00DB38  2               ;	jsr	lcd_sprint
00DB38  2               
00DB38  2  20 27 E3     	jsr	setxaddr		; Set execution address
00DB3B  2  B0 29        	bcs	monjmpab		; Out of range -> error
00DB3D  2               
00DB3D  2  20 94 E2     	jsr	getparm			; Check for excess input
00DB40  2  90 24        	bcc	monjmpab		; Too much input -> error
00DB42  2               
00DB42  2  C2 20        	longa				; 16-Bit .A
00DB44  2               
00DB44  2  A5 8A        	lda	reg_spx
00DB46  2  1B           	tcs				; Restore SP
00DB47  2               
00DB47  2               monjmpaa:
00DB47  2  E2 20        	shorta				; 8-Bit .A
00DB49  2               
00DB49  2  A5 80        	lda	reg_pbx
00DB4B  2  48           	pha				; Restore PB
00DB4C  2               
00DB4C  2  C2 20        	longa				; 16-Bit .A
00DB4E  2               
00DB4E  2  A5 81        	lda	reg_pcx
00DB50  2  48           	pha				; Restore PC
00DB51  2               
00DB51  2  E2 20        	shorta				; 8-Bit .A
00DB53  2               
00DB53  2  A5 83        	lda	reg_srx
00DB55  2  48           	pha				; Restore SR
00DB56  2  A5 8E        	lda	reg_dbx
00DB58  2  48           	pha
00DB59  2  AB           	plb				; Restore PB
00DB5A  2               
00DB5A  2  C2 30        	longr				; 16-Bit registers .A, .X and .Y
00DB5C  2               
00DB5C  2  A5 8C        	lda	reg_dpx
00DB5E  2  5B           	tcd				; Restore DP
00DB5F  2  A5 84        	lda	reg_ax			; Restore .C
00DB61  2  A6 86        	ldx	reg_xx			; Restore .X
00DB63  2  A4 88        	ldy	reg_yx			; Restore .Y
00DB65  2  40           	rti				; Execute code
00DB66  2               
00DB66  2               monjmpab:
00DB66  2  4C FF D8     	jmp	monerr			; Error
00DB69  2               
00DB69  2               ;------------------------------------------------------------------------------
00DB69  2               ; monjsr: Execute Code as Subroutine
00DB69  2               ;
00DB69  2               ;	syntax: J [<dp>]
00DB69  2               ;
00DB69  2               ;	If no address is specified the current values in the PB & PC
00DB69  2               ;	shadow registers are used.   An RTS at the end of the called
00DB69  2               ;	subroutine will return control to the monitor  provided  the
00DB69  2               ;	stack remains in balance.
00DB69  2               ;------------------------------------------------------------------------------
00DB69  2               monjsr:
00DB69  2  48           	pha
00DB6A  2  DA           	phx
00DB6B  2               
00DB6B  2               ; Migrating to gLCD
00DB6B  2               ;	jsr	lcd_clear
00DB6B  2               ;	pea	mm_monjsr
00DB6B  2               ;	jsr	lcd_sprint
00DB6B  2               
00DB6B  2  FA           	plx
00DB6C  2  68           	pla
00DB6D  2               
00DB6D  2  20 27 E3     	jsr	setxaddr		; Set execution address
00DB70  2  B0 F4        	bcs	monjmpab		; Out of range -> error
00DB72  2               
00DB72  2  20 94 E2     	jsr	getparm			; Check for excess input
00DB75  2  90 EF        	bcc	monjmpab		; Too much input -> error
00DB77  2               
00DB77  2  C2 20        	longa				; 16-Bit .A
00DB79  2               
00DB79  2  A5 8A        	lda	reg_spx
00DB7B  2  1B           	tcs				; Restore SP and ...
00DB7C  2  20 47 DB     	jsr	monjmpaa		; ... call subroutine
00DB7F  2  08           	php				; Push SR
00DB80  2               
00DB80  2  C2 30        	longr				; 16-Bit registers .A, .X and .Y
00DB82  2               
00DB82  2  85 84        	sta	reg_ax			; Save ...
00DB84  2  86 86        	stx	reg_xx			; ... register ...
00DB86  2  84 88        	sty	reg_yx			; ... returns
00DB88  2               
00DB88  2  E2 10        	shorti				; 8-Bit .X and .Y
00DB8A  2               
00DB8A  2  FA           	plx				; Get and save ...
00DB8B  2  86 83        	stx	reg_srx			; ... return SR
00DB8D  2  3B           	tsc				; Get and save ...
00DB8E  2  85 8A        	sta	reg_spx			; ... return SP
00DB90  2  7B           	tdc				; Get and save ...
00DB91  2  85 8C        	sta	reg_dpx			; ... DP pointer
00DB93  2               
00DB93  2  E2 20        	shorta				; 8-Bit .A
00DB95  2               
00DB95  2  4B           	phk				; Get and ...
00DB96  2  68           	pla				; ... save ...
00DB97  2  85 80        	sta	reg_pbx			; ... return PB
00DB99  2  8B           	phb				; Get and ...
00DB9A  2  68           	pla				; ... save ...
00DB9B  2  85 8E        	sta	reg_dbx			; ... return DB
00DB9D  2  F4 40 E8     	pea	mm_rts			; "*RET"
00DBA0  2  4C 60 D8     	jmp	moncom			; Return to monitor
00DBA3  2               
00DBA3  2               ;------------------------------------------------------------------------------
00DBA3  2               ; monchm: Change and/or Dump Memory
00DBA3  2               ;
00DBA3  2               ;	syntax: > [<addr> <operand> [<operand>]...]
00DBA3  2               ;
00DBA3  2               ;	> <addr> without operands will dump 16 bytes
00DBA3  2               ;	of memory, starting at <addr>.
00DBA3  2               ;------------------------------------------------------------------------------
00DBA3  2               monchm:
00DBA3  2  B0 23        	bcs	@c			; No address given -> quit
00DBA5  2               
00DBA5  2               ; Migrating to gLCD
00DBA5  2               ;	jsr	lcd_clear
00DBA5  2               ;	pea	mm_monchm
00DBA5  2               ;	jsr	lcd_sprint
00DBA5  2               
00DBA5  2  20 84 E2     	jsr	facasize		; Size address
00DBA8  2  C9 04        	cmp	#s_dword
00DBAA  2  B0 1F        	bcs	@d			; Address out of range -> error
00DBAC  2               
00DBAC  2  20 60 E2     	jsr	facaddra		; Get starting address
00DBAF  2  20 91 E3     	jsr	getpat			; Evaluate change pattern
00DBB2  2  90 04        	bcc	@a			; Entered
00DBB4  2               
00DBB4  2  10 0C        	bpl	@b			; Not entered
00DBB6  2               
00DBB6  2  80 13        	bra	@d			; Evaluation error
00DBB8  2               
00DBB8  2               @a:
00DBB8  2  88           	dey				; Next byte
00DBB9  2  30 07        	bmi	@b			; Done
00DBBB  2               
00DBBB  2  B9 46 02     	lda	auxbuf, Y		; Write pattern ...
00DBBE  2  97 8F        	sta	[addra], Y		; ... to memory
00DBC0  2  80 F6        	bra	@a			; Next
00DBC2  2               
00DBC2  2               @b:
00DBC2  2  20 C4 DF     	jsr	newline			; Next line
00DBC5  2  20 4B DF     	jsr	dpymem			; Regurgitate changes
00DBC8  2               
00DBC8  2               @c:
00DBC8  2  4C BE D8     	jmp	monce			; Back to command loop
00DBCB  2               
00DBCB  2               @d:
00DBCB  2  4C FF D8     	jmp	monerr			; Goto error handler
00DBCE  2               
00DBCE  2               
00DBCE  2               ;------------------------------------------------------------------------------
00DBCE  2               ; moncmp: Compare Memory
00DBCE  2               ;
00DBCE  2               ;	syntax: C <start> <end> <ref>
00DBCE  2               ;------------------------------------------------------------------------------
00DBCE  2               moncmp:
00DBCE  2  B0 26        	bcs	@c			; Start not given -> quit
00DBD0  2               
00DBD0  2  20 3A E2     	jsr	enddest			; get end and reference addresses
00DBD3  2  B0 24        	bcs	@d			; Range or other error
00DBD5  2               
00DBD5  2  64 BA        	stz	xrtemp			; Column counter
00DBD7  2               
00DBD7  2               @a:
00DBD7  2  20 50 E4     	jsr	teststop		; Check for stop
00DBDA  2  B0 1A        	bcs	@c			; Abort
00DBDC  2               
00DBDC  2  B7 8F        	lda	[addra], Y		; Get from reference location
00DBDE  2  C7 A9        	cmp	[operand]		; test against compare location
00DBE0  2  F0 03        	beq	@b			; Match, don't display address
00DBE2  2               
00DBE2  2  20 1F DE     	jsr	dpycaddr		; Display current location
00DBE5  2               
00DBE5  2               @b:
00DBE5  2  20 BC E2     	jsr	nxtaddra		; Next address location
00DBE8  2  B0 0C        	bcs	@c			; Done
00DBEA  2               
00DBEA  2  C2 20        	longa				; 16-bit .A
00DBEC  2               
00DBEC  2  E6 A9        	inc 	operand			; Bump bits 15-0
00DBEE  2               
00DBEE  2  E2 20        	shorta				; 8-bit .A
00DBF0  2               
00DBF0  2  D0 E5        	bne	@a
00DBF2  2               
00DBF2  2  E6 AB        	inc	operand + s_word	; Bump bits 23-16 (bank)
00DBF4  2  80 E1        	bra	@a
00DBF6  2               
00DBF6  2               @c:
00DBF6  2  4C BE D8     	jmp	monce			; Return to command loop
00DBF9  2               
00DBF9  2               @d:
00DBF9  2  4C FF D8     	jmp	monerr
00DBFC  2               
00DBFC  2               ;------------------------------------------------------------------------------
00DBFC  2               ; moncpy: Copy (Transfer) Memory
00DBFC  2               ;
00DBFC  2               ;	syntax: T <start> <end> <target>
00DBFC  2               ;------------------------------------------------------------------------------
00DBFC  2               moncpy:
00DBFC  2  B0 49        	bcs	@d			; Start not given -> quit
00DBFE  2               
00DBFE  2  20 3A E2     	jsr	enddest			; Get and set target address
00DC01  2  B0 47        	bcs	@e			; Range or other error
00DC03  2               
00DC03  2  C2 20        	longa				; 16-bit .A
00DC05  2               
00DC05  2  38           	sec
00DC06  2  A5 92        	lda	addrb			; Ending address
00DC08  2  E5 8F        	sbc	addra			; Starting address
00DC0A  2  B0 3E        	bcs	@e			; Start > End -> error
00DC0C  2               
00DC0C  2  85 9D        	sta	facb			; Bytes to copy
00DC0E  2               
00DC0E  2  E2 20        	shorta				; 8-Bit .A
00DC10  2               
00DC10  2  C2 10        	longi				; 16-bit .X and .Y
00DC12  2               
00DC12  2  A5 AB        	lda	operand + s_word	; Target bank
00DC14  2  A4 A9        	ldy	operand			; Target address
00DC16  2  C5 91        	cmp	addra + s_word		; Source bank
00DC18  2               
00DC18  2  C2 20        	longa				; 16-Bit .A
00DC1A  2               
00DC1A  2  D0 1C        	bne	@b			; Can use forward copy
00DC1C  2               
00DC1C  2  C4 8F        	cpy	addra			; Source address
00DC1E  2  90 18        	bcc	@b			; Can use forward copy
00DC20  2               
00DC20  2  D0 02        	bne	@a			; Must use reverse copy
00DC22  2               
00DC22  2  80 26        	bra	@e			; Copy in-place -> error
00DC24  2               
00DC24  2               @a:
00DC24  2  A5 9D        	lda	facb			; Get bytes to copy
00DC26  2  48           	pha				; Protect
00DC27  2  20 38 E4     	jsr	lodbnk			; Load banks
00DC2A  2  20 F7 E1     	jsr	cprvsup			; Do reverse copy setup
00DC2D  2  68           	pla				; Get bytes to copy
00DC2E  2  AA           	tax				; Save a copy
00DC2F  2  18           	clc
00DC30  2  65 A9        	adc	operand			; Change target to ...
00DC32  2  A8           	tay				; ... target end
00DC33  2  8A           	txa				; Recover bytes to copy
00DC34  2  A6 92        	ldx	addrb			; Source end
00DC36  2  80 0C        	bra	@c
00DC38  2               
00DC38  2               @b:
00DC38  2  A5 9D        	lda	facb			; Get bytes to copy
00DC3A  2  48           	pha				; Protect
00DC3B  2  20 38 E4     	jsr	lodbnk			; Load banks
00DC3E  2  20 F0 E1     	jsr	cpfwsup			; Do forward copy setup
00DC41  2  68           	pla				; Recover bytes to copy
00DC42  2  A6 8F        	ldx	addra			; Source start
00DC44  2               
00DC44  2               @c:
00DC44  2  4C 95 00     	jmp	mcftwork		; Copy memory
00DC47  2               @d:
00DC47  2  4C BE D8     	jmp	monce			; Return to command loop
00DC4A  2               
00DC4A  2               @e:
00DC4A  2  4C FF D8     	jmp	monerr			; Error
00DC4D  2               
00DC4D  2               ;------------------------------------------------------------------------------
00DC4D  2               ; mondmp: Display Memory Range
00DC4D  2               ;
00DC4D  2               ;	syntax: M [<addr1> [<addr2>]]
00DC4D  2               ;------------------------------------------------------------------------------
00DC4D  2               mondmp:
00DC4D  2  E2 30        	shortr
00DC4F  2  B0 0F        	bcs	@a			; No parameters
00DC51  2               
00DC51  2  20 84 E2     	jsr	facasize		; Check address ...
00DC54  2  C9 04        	cmp	#s_dword		; ... range
00DC56  2  B0 46        	bcs	@e			; Out of range -> error
00DC58  2               
00DC58  2  20 60 E2     	jsr	facaddra		; Copy starting address
00DC5B  2  20 94 E2     	jsr	getparm			; Get ending address
00DC5E  2  90 17        	bcc	@b			; Got it
00DC60  2               
00DC60  2               @a:
00DC60  2  20 62 E1     	jsr	clrfaca			; Clear accumulator
00DC63  2               
00DC63  2  C2 20        	longa				; 16-bit .A
00DC65  2               
00DC65  2  18           	clc
00DC66  2  A5 8F        	lda	addra			; Starting address
00DC68  2  69 FF 00     	adc	#n_mBytes		; Default bytes
00DC6B  2  85 95        	sta	faca			; Effective ending address
00DC6D  2               
00DC6D  2  E2 20        	shorta				; 8-Bit .A
00DC6F  2               
00DC6F  2  A5 91        	lda	addra + s_word		; Starting bank
00DC71  2  69 00        	adc	#$00
00DC73  2  85 97        	sta	faca + s_word		; Effective ending bank
00DC75  2  B0 27        	bcs	@e			; Ending address > $FF/FFFF -> error
00DC77  2               
00DC77  2               @b:
00DC77  2  20 84 E2     	jsr	facasize		; Check ending address ...
00DC7A  2  C9 04        	cmp	#s_dword		; ... range
00DC7C  2  B0 20        	bcs	@e			; Out of range -> error
00DC7E  2               
00DC7E  2  20 6C E2     	jsr 	facaddrb		; Copy ending address
00DC81  2  20 94 E2     	jsr	getparm			; Check for excess input
00DC84  2  90 18        	bcc	@e			; Error
00DC86  2               
00DC86  2  20 D0 E1     	jsr	calccnt			; Calculate bytes to dump
00DC89  2  90 13        	bcc	@e			; end < start -> error
00DC8B  2               
00DC8B  2               @c:
00DC8B  2  20 50 E4     	jsr	teststop		; Test for user initiated break
00DC8E  2  B0 0B        	bcs	@d			; User pressed <Ctrl-C>
00DC90  2               
00DC90  2  20 C4 DF     	jsr	newline			; Next line
00DC93  2  20 4B DF     	jsr	dpymem			; Display
00DC96  2  20 16 E2     	jsr	decdcnt			; Decrement byte count
00DC99  2  90 F0        	bcc	@c			; not done, yet ...
00DC9B  2               
00DC9B  2               @d:
00DC9B  2  4C BE D8     	jmp	monce			; Go to main loop
00DC9E  2               
00DC9E  2               @e:
00DC9E  2  4C FF D8     	jmp	monerr			; Handle error
00DCA1  2               
00DCA1  2               
00DCA1  2               ;------------------------------------------------------------------------------
00DCA1  2               ; monfil: Fill Memory
00DCA1  2               ;
00DCA1  2               ;	syntax: F <start> <end> <fill>
00DCA1  2               ;
00DCA1  2               ;	<start> & <end> must be in the same bank.
00DCA1  2               ;------------------------------------------------------------------------------
00DCA1  2               monfil:
00DCA1  2  E2 30        	shortr
00DCA3  2  B0 5E        	bcs	@a			; Start not given -> quit
00DCA5  2               
00DCA5  2  20 84 E2     	jsr	facasize		; Check size
00DCA8  2  C9 04        	cmp	#s_dword		; 2 bytes?
00DCAA  2  B0 5A        	bcs	@b			; Out of range -> error
00DCAC  2               
00DCAC  2  20 60 E2     	jsr	facaddra		; Store start address
00DCAF  2  20 94 E2     	jsr	getparm			; Evaluate end address
00DCB2  2  B0 52        	bcs	@b			; Not entered -> error
00DCB4  2               
00DCB4  2  20 84 E2     	jsr	facasize		; Check size
00DCB7  2  C9 04        	cmp	#s_dword		; 2 bytes?
00DCB9  2  B0 4B        	bcs	@b			; Out of range -> error
00DCBB  2               
00DCBB  2  A5 97        	lda	faca + s_word		; End bank
00DCBD  2  C5 91        	cmp	addra + s_word		; Compare with start bank
00DCBF  2  D0 45        	bne	@b			; Not the same -> error
00DCC1  2               
00DCC1  2  20 6C E2     	jsr	facaddrb		; Store end address
00DCC4  2               
00DCC4  2  C2 20        	longa				; 16-Bit .A
00DCC6  2               
00DCC6  2  38           	sec
00DCC7  2  A5 92        	lda	addrb			; Get end address
00DCC9  2  E5 8F        	sbc	addra			; Subtract start address
00DCCB  2               					; (addrb - addra = number of bytes)
00DCCB  2  90 39        	bcc	@b			; Start > end  -> error
00DCCD  2               
00DCCD  2  85 9D        	sta	facb			; Bytes to copy/fill
00DCCF  2               
00DCCF  2  E2 20        	shorta				; 8-Bit .A
00DCD1  2               
00DCD1  2  20 94 E2     	jsr	getparm			; Evaluate fill byte
00DCD4  2  B0 30        	bcs	@b			; not entered -> error
00DCD6  2               
00DCD6  2  20 84 E2     	jsr	facasize		; Fill byte should be ...
00DCD9  2  C9 02        	cmp	#s_word			; ... 8 bits
00DCDB  2  B0 29        	bcs	@b			; It isn't -> error
00DCDD  2               
00DCDD  2  20 78 E2     	jsr	facaoper		; Store fill byte
00DCE0  2  20 94 E2     	jsr	getparm			; There should be no more parameters
00DCE3  2  90 21        	bcc	@b			; Seems there are more -> error
00DCE5  2               
00DCE5  2  A5 A9        	lda	operand			; Get fill byte
00DCE7  2  87 8F        	sta	[addra]			; Store at first address location
00DCE9  2               
00DCE9  2  C2 30        	longr				; 16-bit .A, .X and .Y
00DCEB  2               
00DCEB  2  A5 9D        	lda	facb			; Get byte count
00DCED  2  F0 14        	beq	@a			; Only one location, done...
00DCEF  2               
00DCEF  2  3A           	dea				; Zero align and ...
00DCF0  2  48           	pha				; ... protect
00DCF1  2               
00DCF1  2  E2 20        	shorta				; 8-Bit .A
00DCF3  2               
00DCF3  2  A5 91        	lda	addra + s_word		; Get start bank
00DCF5  2  EB           	xba
00DCF6  2  A5 94        	lda	addrb + s_word		; Get end bank
00DCF8  2  20 F0 E1     	jsr	cpfwsup			; Perform forward copy setup
00DCFB  2  68           	pla				; Recover fill count
00DCFC  2  A6 8F        	ldx	addra			; Fill-from start address
00DCFE  2  9B           	txy
00DCFF  2  C8           	iny				; Fill-to starting location
00DD00  2  4C 95 00     	jmp	mcftwork		; Fill memory
00DD03  2               
00DD03  2               @a:
00DD03  2  4C BE D8     	jmp	monce			; Goto command executive
00DD06  2               
00DD06  2               @b:
00DD06  2  4C FF D8     	jmp	monerr			; Goto error handler
00DD09  2               
00DD09  2               ;------------------------------------------------------------------------------
00DD09  2               ; monhnt: Search (Hunt) Memory
00DD09  2               ;
00DD09  2               ;	syntax: H <addr1> <addr2> <pattern>
00DD09  2               ;------------------------------------------------------------------------------
00DD09  2               monhnt:
00DD09  2  E2 30        	shortr
00DD0B  2  B0 40        	bcs	@e			; No start address given -> abort
00DD0D  2               
00DD0D  2  20 84 E2     	jsr	facasize		; Get size of starting address
00DD10  2  C9 04        	cmp	#s_dword		; Is it 16 bit wide?
00DD12  2  B0 3C        	bcs	@f			; Address is out of range -> error
00DD14  2               
00DD14  2  20 60 E2     	jsr	facaddra		; Store starting address
00DD17  2  20 94 E2     	jsr	getparm			; Evaluate ending address
00DD1A  2  B0 34        	bcs	@f			; No address -> error
00DD1C  2               
00DD1C  2  20 84 E2     	jsr	facasize		; Get size of ending address
00DD1F  2  C9 04        	cmp	#s_dword		; Is it also 16 bits wide?
00DD21  2  B0 2D        	bcs	@f			; Address is out of range -> error
00DD23  2               
00DD23  2  20 6C E2     	jsr	facaddrb		; Store ending address
00DD26  2  20 D0 E1     	jsr	calccnt			; Calculate byte range
00DD29  2  B0 25        	bcs	@f			; Ending < starting address -> error
00DD2B  2               
00DD2B  2  20 91 E3     	jsr	getpat			; Evaluate search pattern
00DD2E  2  B0 20        	bcs	@f			; Unparsable pattern -> error
00DD30  2               
00DD30  2  64 BA        	stz	xrtemp			; Clear column counter
00DD32  2               
00DD32  2               @a:
00DD32  2  20 50 E4     	jsr	teststop		; Check for stop (<Ctrl-C>
00DD35  2  B0 16        	bcs	@e			; Abort... Abort... Abort...
00DD37  2               
00DD37  2  A4 AC        	ldy	auxbufindex		; At which index in buffer is pattern
00DD39  2               
00DD39  2               @b:
00DD39  2  88           	dey
00DD3A  2  30 09        	bmi	@c			; Pattern matches
00DD3C  2               
00DD3C  2  B7 8F        	lda	[addra], Y		; Get from memory
00DD3E  2  D9 46 02     	cmp	auxbuf, Y		; test against pattern
00DD41  2  D0 05        	bne	@d			; Not found -> next location
00DD43  2               
00DD43  2  F0 F4        	beq	@b			; Match, keep testing
00DD45  2               
00DD45  2               @c:
00DD45  2  20 1F DE     	jsr	dpycaddr		; Display current address
00DD48  2               
00DD48  2               @d:
00DD48  2  20 BC E2     	jsr	nxtaddra		; Get next address
00DD4B  2  90 E5        	bcc	@a			; Not done, yet...
00DD4D  2               
00DD4D  2               @e:
00DD4D  2  4C BE D8     	jmp	monce			; Return to a prompt
00DD50  2               
00DD50  2               @f:
00DD50  2  4C FF D8     	jmp	monerr			; Go to error handler
00DD53  2               
00DD53  2               ;------------------------------------------------------------------------------
00DD53  2               ; monenv: Convert Numeric Value
00DD53  2               ;
00DD53  2               ;	syntax: <radix><value>
00DD53  2               ;------------------------------------------------------------------------------
00DD53  2               monenv:
00DD53  2  E2 30        	shortr
00DD55  2  20 92 E2     	jsr	getparmr		; Re-read and evaluate parameter(s)
00DD58  2  B0 26        	bcs	@b			; Nothing entered
00DD5A  2               
00DD5A  2  A2 00        	ldx	#$00			; Radix index
00DD5C  2  A0 04        	ldy	#n_radix		; Number of available radices
00DD5E  2               
00DD5E  2               @a:
00DD5E  2  5A           	phy				; Save counter
00DD5F  2  DA           	phx				; Save radix index
00DD60  2  20 C4 DF     	jsr	newline			; Next line ...
00DD63  2  20 45 DF     	jsr	clearlin		; ... and clear line
00DD66  2  A9 20        	lda	#SPACE			; We are going to print <Space>s
00DD68  2  A2 04        	ldx	#halfTab		; Index 1/2 tab
00DD6A  2  20 B7 DF     	jsr	multspc			; Print the <Space>s
00DD6D  2  FA           	plx				; Get radix index back, but ...
00DD6E  2  DA           	phx				; ... put it backa
00DD6F  2  BD AA E4     	lda	radxtab, X		; Get radix
00DD72  2  20 B9 E0     	jsr	binasc			; Convert to ASCII
00DD75  2  5A           	phy				; String address MSB
00DD76  2  DA           	phx				; String address LSB
00DD77  2  20 D9 DF     	jsr	sprint			; Print
00DD7A  2  FA           	plx				; Get index, again
00DD7B  2  7A           	ply				; Get counter
00DD7C  2  E8           	inx
00DD7D  2  88           	dey				; All radices handled?
00DD7E  2  D0 DE        	bne	@a			; No ...
00DD80  2               
00DD80  2               @b:
00DD80  2  4C BE D8     	jmp	monce			; Get back to prompt
00DD83  2               
00DD83  2               ;------------------------------------------------------------------------------
00DD83  2               ; monchr: Change Registers
00DD83  2               ;
00DD83  2               ;	syntax: ; [PB [PC [.S [.C [.X [.Y [SP [DP [DB]]]]]]]]]
00DD83  2               ;
00DD83  2               ;	; with no parameters is the same as the R command.
00DD83  2               ;------------------------------------------------------------------------------
00DD83  2               monchr:
00DD83  2  E2 30        	shortr
00DD85  2  B0 33        	bcs	@d			; No paramaters given, dump registers
00DD87  2               					; and return
00DD87  2               
00DD87  2  A0 00        	ldy	#$00			; Registr counter
00DD89  2  84 A3        	sty	facc			; Initialize register index
00DD8B  2               
00DD8B  2               @a:
00DD8B  2  20 84 E2     	jsr	facasize		; Get parameter size
00DD8E  2  D9 AE E4     	cmp	rcvltab, Y		; Check against size table
00DD91  2  B0 2A        	bcs	@e			; Out of range -> error
00DD93  2               
00DD93  2  B9 AE E4     	lda	rcvltab, Y		; Determine number of bytes ...
00DD96  2  C9 03        	cmp	#s_word + 1		; ... to store
00DD98  2  66 A4        	ror	facc + s_byte		; Condition flag
00DD9A  2  10 02        	bpl	@b			; We are asking for an 8-bit register
00DD9C  2               
00DD9C  2  C2 20        	longa				; 16-Bit .A
00DD9E  2               
00DD9E  2               					; As we are asking for a 16-bit register
00DD9E  2               
00DD9E  2               @b:
00DD9E  2  A6 A3        	ldx	facc			; Get register index
00DDA0  2  A5 95        	lda	faca			; Get parameter(s)
00DDA2  2  95 80        	sta	reg_pbx, X		; Put in shadow storage
00DDA4  2               
00DDA4  2  E2 20        	shorta				; 8-Bit .A requested
00DDA6  2               
00DDA6  2  06 A4        	asl	facc + s_byte		; Mode flagg to carry
00DDA8  2  8A           	txa				; Register index
00DDA9  2  69 01        	adc	#s_byte			; At least 1 byte stored
00DDAB  2  85 A3        	sta	facc			; Save new index
00DDAD  2  20 94 E2     	jsr	getparm			; Get a parameter
00DDB0  2  B0 08        	bcs	@d			; Enf Of Input
00DDB2  2               
00DDB2  2  C8           	iny				; Bump register count
00DDB3  2  C0 09        	cpy	#n_regchv		; All registers processed?
00DDB5  2  D0 D4        	bne	@a			; NOpe, keep on going ...
00DDB7  2               
00DDB7  2               @c:
00DDB7  2  20 D0 DF     	jsr	alert			; Excessive input
00DDBA  2               
00DDBA  2               @d:
00DDBA  2  4C 71 D8     	jmp	monreg			; Display registers and changes
00DDBD  2               
00DDBD  2               @e:
00DDBD  2  4C FF D8     	jmp	monerr
00DDC0  2               
00DDC0  2               ;------------------------------------------------------------------------------
00DDC0  2               ;   C U R R E N T L Y   N O T   I M P L E M E N T E D
00DDC0  2               ;
00DDC0  2               ; monxit: Exit To Operating Environment
00DDC0  2               ;
00DDC0  2               ;	Syntax: X
00DDC0  2               ;
00DDC0  2               ;   C U R R E N T L Y   N O T   I M P L E M E N T E D
00DDC0  2               ;------------------------------------------------------------------------------
00DDC0  2               ;monxit:
00DDC0  2               ;	bcc	@b			; No parameter(s) allowed
00DDC0  2               ;
00DDC0  2               ;	rep	#$20			; 16-bit .A
00DDC0  2               ;	.a16
00DDC0  2               ;	lda	vecbrki			; BRK indirect vector
00DDC0  2               ;	cmp	#monbrk			; Did we intercept it?
00DDC0  2               ;	bne	@a			; Nope, do not change it
00DDC0  2               ;
00DDC0  2               ;	lda	vecbrkia		; Get original vector
00DDC0  2               ;	sta	vecbrki			; Restore it
00DDC0  2               ;	stz	vecbrkia		; Invalidate old vector
00DDC0  2               ;
00DDC0  2               ;@a:
00DDC0  2               ;	sep	#$10			; 8-bit .X and .Y
00DDC0  2               ;	.i8
00DDC0  2               ;	jml	vecexit			; Long jump to exit
00DDC0  2               ;
00DDC0  2               ;@b:
00DDC0  2               ;	jmp	monerr			; Go to error handler
00DDC0  2               ;
00DDC0  2               ;------------------------------------------------------------------------------
00DDC0  2               ;------------------------------------------------------------------------------
00DDC0  2               ;
00DDC0  2               ; # # #               S T A R T   O F   S U B R O U T I N E S             # # #
00DDC0  2               ;------------------------------------------------------------------------------
00DDC0  2               ; mul8_8_16
00DDC0  2               ;
00DDC0  2               ; Multiply two 8 bit values with 16 bit result
00DDC0  2               ; [add1L] * [add2L] = [sum1H][sum1L]
00DDC0  2               ;
00DDC0  2               ; (routines found at http://6502org.wikidot.com/software-math-intmul
00DDC0  2               ;------------------------------------------------------------------------------
00DDC0  2               mul8_8_16:
00DDC0  2  A2 08        	ldx	#$08			; Process 8 bits
00DDC2  2  A9 00        	lda	#$00
00DDC4  2  46 C2        	lsr	add1L			; 8-bit factor 1
00DDC6  2               @l1:
00DDC6  2  90 03        	bcc	@l2
00DDC8  2  18           	clc
00DDC9  2  65 C4        	adc	add2L			; 8-bit factor 2
00DDCB  2               @l2:
00DDCB  2  6A           	ror
00DDCC  2  66 C2        	ror	add1L
00DDCE  2  CA           	dex
00DDCF  2  D0 F5        	bne	@l1
00DDD1  2  85 C7        	sta	sum1H			; High byte of result
00DDD3  2  A5 C2        	lda	add1L			; Low byte of result
00DDD5  2  85 C6        	sta	sum1L
00DDD7  2  60           	rts
00DDD8  2               
00DDD8  2               ;------------------------------------------------------------------------------
00DDD8  2               ; mul8_8_8
00DDD8  2               ;
00DDD8  2               ; Multiply two 8 bit values with 8 bit result
00DDD8  2               ; [add1L] * [add2L] = [sum1L]
00DDD8  2               ;
00DDD8  2               ; (routines found at http://6502org.wikidot.com/software-math-intmul
00DDD8  2               ;------------------------------------------------------------------------------
00DDD8  2               mul8_8_8:
00DDD8  2  A2 08        	ldx	#$08			; Process 8 bits
00DDDA  2  A9 00        	lda 	#$00
00DDDC  2               @l1:
00DDDC  2  0A           	asl
00DDDD  2  06 C2        	asl	add1L			; Factor 1
00DDDF  2  90 03        	bcc	@l2
00DDE1  2  18           	clc
00DDE2  2  65 C4        	adc	add2L			; Fsctor 2
00DDE4  2               @l2:
00DDE4  2  CA           	dex
00DDE5  2  D0 F5        	bne	@l1
00DDE7  2  85 C6        	sta	sum1L			; Product
00DDE9  2  60           	rts
00DDEA  2               ;------------------------------------------------------------------------------
00DDEA  2               ; div16_8_8
00DDEA  2               ;
00DDEA  2               ; Divide 16-bit valuem 8-bit quotient, 8-bit remainder
00DDEA  2               ; [add1H][add1L] / [add2L] = [sum1L] mod [sum1H]
00DDEA  2               ;
00DDEA  2               ; (routines found at http://6502org.wikidot.com/software-math-intdiv
00DDEA  2               ;------------------------------------------------------------------------------
00DDEA  2               div16_8_8:
00DDEA  2  A5 C3        	lda	add1H			; MSB of 16-bit numerator
00DDEC  2  A2 08        	ldx	#$08
00DDEE  2  06 C2        	asl	add1L			; LSB of numerator
00DDF0  2               @l1:
00DDF0  2  2A           	rol
00DDF1  2  B0 04        	bcs	@l2
00DDF3  2  C5 C4        	cmp	add2L
00DDF5  2  90 03        	bcc	@l3
00DDF7  2               @l2:
00DDF7  2  E5 C4        	sbc	add2L
00DDF9  2  38           	sec				; We need to set Carry when BCS @l2
00DDFA  2               					; above was taken
00DDFA  2               @l3:
00DDFA  2  26 C2        	rol	add1L
00DDFC  2  CA           	dex
00DDFD  2  D0 F1        	bne	@l1
00DDFF  2  85 C7        	sta	sum1H			; Remainder
00DE01  2  A5 C2        	lda	add1L			; 8-bit quotient
00DE03  2  85 C6        	sta	sum1L
00DE05  2  60           	rts
00DE06  2               
00DE06  2               ;------------------------------------------------------------------------------
00DE06  2               ; div8_8_8
00DE06  2               ;
00DE06  2               ; Divide 8-bit value, 8-bit quotient, 8-bit remainder
00DE06  2               ; [add1L] / [add2L] = [sum1L] mod [sum1H]
00DE06  2               ;
00DE06  2               ; (routines found at http://6502org.wikidot.com/software-math-intdiv
00DE06  2               ;------------------------------------------------------------------------------
00DE06  2               div8_8_8:
00DE06  2  A9 00        	lda	#$00
00DE08  2  A2 08        	ldx	#$08
00DE0A  2  06 C2        	asl	add1L
00DE0C  2               @l1:
00DE0C  2  2A           	rol
00DE0D  2  C5 C4        	cmp	add2L
00DE0F  2  90 02        	bcc	@l2
00DE11  2  E5 C4        	sbc	add2L
00DE13  2               @l2:
00DE13  2  26 C2        	rol	add1L
00DE15  2  CA           	dex
00DE16  2  D0 F4        	bne	@l1
00DE18  2  85 C7        	sta	sum1H			; Remainder
00DE1A  2  A5 C2        	lda	add1L
00DE1C  2  85 C6        	sta	sum1L			; Quotient
00DE1E  2  60           	rts
00DE1F  2               
00DE1F  2               ;------------------------------------------------------------------------------
00DE1F  2               ; dpycaddr: Display Current Address in Columns
00DE1F  2               ;------------------------------------------------------------------------------
00DE1F  2               dpycaddr:
00DE1F  2  A6 BA        	ldx	xrtemp			; Column count
00DE21  2  D0 05        	bne	@a			; Not at right side
00DE23  2               
00DE23  2  20 C4 DF     	jsr	newline			; Next row
00DE26  2  A2 0A        	ldx	#n_hccols		; Maximum number of columns
00DE28  2               
00DE28  2               @a:
00DE28  2  E0 0A        	cpx	#n_hccols		; Compare to maximum number of columns
00DE2A  2  F0 05        	beq	@b			; Are we at left margin?
00DE2C  2               
00DE2C  2  A9 09        	lda	#HT			; <Tab>
00DE2E  2  20 0C FD     	jsr	putcha			; Print  <Tab>
00DE31  2               
00DE31  2               @b:
00DE31  2  CA           	dex				; One less column
00DE32  2  86 BA        	stx	xrtemp			; Save column counter
00DE34  2  4C 90 DF     	jmp	prntladr		; Print reference address
00DE37  2               
00DE37  2               ;------------------------------------------------------------------------------
00DE37  2               ; dpycod: Disassemble and Display Code
00DE37  2               ;
00DE37  2               ;	This function disassembles & displays the machine code at  the  location
00DE37  2               ;	pointed to by ADDRA.  Upon return, ADDRA will point to the opcode of the
00DE37  2               ;	next instruction.   The entry point at DPYCODAA  should be called with a
00DE37  2               ;	disassembly prefix character loaded in .A.   If entered  at  DPYCOD, the
00DE37  2               ;	default character will be display at the beginning of each  disassembled
00DE37  2               ;	instruction.
00DE37  2               ;
00DE37  2               ;	The disassembly of immediate mode instructions that can take an 8 or  16
00DE37  2               ;	bit operand is affected by the bit pattern that is  stored  in  FLIMFLAG
00DE37  2               ;	upon entry to this function:
00DE37  2               ;
00DE37  2               ;	    FLIMFLAG: xx000000
00DE37  2               ;	              ||
00DE37  2               ;	              |+---------> 0:  8 bit .X or .Y operand
00DE37  2               ;	              |            1: 16 bit .X or .Y operand
00DE37  2               ;	              +----------> 0:  8 bit .A or BIT # operand
00DE37  2               ;	                           1: 16 bit .A or BIT # operand
00DE37  2               ;
00DE37  2               ;	FLIMFLAG is conditioned according to the operand of  the  most  recently
00DE37  2               ;	disassembled REP or SEP instruction.   Hence repetitive  calls  to  this
00DE37  2               ;	subroutine will usually result in the correct disassembly of 16 bit imm-
00DE37  2               ;	ediate mode instructions.
00DE37  2               ;------------------------------------------------------------------------------
00DE37  2               dpycod:
00DE37  2  E2 30        	shortr
00DE39  2  A9 2E        	lda	#disprfx		; Default prefix
00DE3B  2               ;------------------------------------------------------------------------------
00DE3B  2               ; Alternate prefix display entry point
00DE3B  2               ;------------------------------------------------------------------------------
00DE3B  2               dpycodaa:
00DE3B  2  20 0C FD     	jsr	putcha			; Print prefix
00DE3E  2  20 D4 DF     	jsr	printspc		; Print <Space>
00DE41  2  20 90 DF     	jsr	prntladr		; Print long address
00DE44  2  20 D4 DF     	jsr	printspc		; Print another <Space>
00DE47  2  20 D1 E2     	jsr	getbyte			; Get opcode
00DE4A  2  85 B8        	sta	opcode			; Save ...
00DE4C  2  20 C9 DF     	jsr	printbyt		; ... display as hex
00DE4F  2               ;------------------------------------------------------------------------------
00DE4F  2               ; Decode mnemonic and addressing mode
00DE4F  2               ;------------------------------------------------------------------------------
00DE4F  2  A6 B8        	ldx	opcode			; Current mnemonic
00DE51  2  BD 6F E5     	lda	mnetabidx, X		; Get mnemonic index
00DE54  2  0A           	asl				; Double for ...
00DE55  2  A8           	tay				; ... mnemonic tabel offset
00DE56  2               
00DE56  2  C2 20        	longa				; 16-bit .A
00DE58  2               
00DE58  2  B9 B7 E4     	lda	mnetab, Y		; Copy encoded mnemonic to ...
00DE5B  2  85 B6        	sta	mnepck			; ... working storage
00DE5D  2               
00DE5D  2  E2 20        	shorta				; Back to 8-bit .A
00DE5F  2               
00DE5F  2  20 F2 E2     	jsr	instdata		; Extract mode and size data
00DE62  2  85 C1        	sta	vopsflag		; Save mode flags
00DE64  2  84 B1        	sty	admodidx		; Save mode index
00DE66  2  0A           	asl				; Variable immediate instruction?
00DE67  2  90 1F        	bcc	dpycod01
00DE69  2               ;------------------------------------------------------------------------------
00DE69  2               ; Determine immediate mode operand size
00DE69  2               ;------------------------------------------------------------------------------
00DE69  2  A5 B8        	lda	opcode			; Current opcode
00DE6B  2  24 BC        	bit	flimflag		; Operand display mode
00DE6D  2  10 08        	bpl	@a			; 8-bit .A & BIT immediate mode
00DE6F  2               
00DE6F  2  29 1F        	and	#aimmaska		; Determine if ...
00DE71  2  C9 09        	cmp	#aimmaskb		; .A or BIT immediate
00DE73  2  F0 10        	beq	@c			; Display 16-bit operand
00DE75  2               
00DE75  2  A5 B8        	lda	opcode			; Not .A or BIT immediate
00DE77  2               
00DE77  2               @a:
00DE77  2  50 0F        	bvc	dpycod01		; 8-Bit .X/.Y immediate mode
00DE79  2  A0 03        	ldy	#n_vopidx - 1		; Opcodes to test
00DE7B  2               
00DE7B  2               @b:
00DE7B  2  D9 6F E7     	cmp	vopidx, Y		; looking for LDX #, CPY #, etc...
00DE7E  2  F0 07        	beq	@d			; Disassemle a 16-bit operand
00DE80  2               
00DE80  2  88           	dey
00DE81  2  10 F8        	bpl	@b			; Keep trying
00DE83  2               
00DE83  2  80 03        	bra	dpycod01		; Not .X or .Y immediate
00DE85  2               
00DE85  2               @c:
00DE85  2  A5 B8        	lda	opcode			; Reload opcode
00DE87  2               
00DE87  2               @d:
00DE87  2  E8           	inx				; 16-Bit operand
00DE88  2               ;------------------------------------------------------------------------------
00DE88  2               ; Get and Display Operand Bytes
00DE88  2               ;------------------------------------------------------------------------------
00DE88  2               dpycod01:
00DE88  2  86 BF        	stx	iopsize			; Operand size ...
00DE8A  2  E8           	inx				; ... plus opcode becomes ...
00DE8B  2  86 B4        	stx	instsize		; ... instruction size
00DE8D  2  86 B2        	stx	charcnt			; Total bytes to process
00DE8F  2  A9 0B        	lda	#n_opcols + 2		; Total operand columns plus WS
00DE91  2  85 BA        	sta	xrtemp			; Initialize counter
00DE93  2  20 E4 E1     	jsr	clroper			; Clear operand
00DE96  2  A4 BF        	ldy	iopsize			; Operand size
00DE98  2  F0 16        	beq	@b			; No operand
00DE9A  2               
00DE9A  2  A2 00        	ldx	#$00			; Operand index
00DE9C  2               
00DE9C  2               @a:
00DE9C  2  20 D1 E2     	jsr	getbyte			; Get operand byte
00DE9F  2  95 A9        	sta	operand, X		; Save
00DEA1  2  DA           	phx				; Protect operand index
00DEA2  2  20 C9 DF     	jsr	printbyt		; Print operand byte
00DEA5  2  C6 BA        	dec	xrtemp			; 3 Columns used, 2 for ...
00DEA7  2  C6 BA        	dec 	xrtemp			; operand nibbles and ...
00DEA9  2  C6 BA        	dec 	xrtemp			; 1 for whitespace
00DEAB  2  FA           	plx				; Get operand index
00DEAC  2  E8           	inx				; Bump it
00DEAD  2  88           	dey
00DEAE  2  D0 EC        	bne	@a			; Next one...
00DEB0  2               
00DEB0  2               @b:
00DEB0  2  A6 BA        	ldx	xrtemp			; Operand columns remaining
00DEB2  2  20 B7 DF     	jsr	multspc			; Space to mnemonic field
00DEB5  2               ;------------------------------------------------------------------------------
00DEB5  2               ; Display mnemonic
00DEB5  2               ;------------------------------------------------------------------------------
00DEB5  2  A0 03        	ldy	#s_mnemonic		; Size of ASCII mnemonic
00DEB7  2               
00DEB7  2               @c:
00DEB7  2  A9 00        	lda	#$00			; Initialize character
00DEB9  2  A2 05        	ldx	#n_shfEncode		; Shifts to execute
00DEBB  2               @d:
00DEBB  2  06 B6        	asl	mnepck			; Shift encoded mnemonic
00DEBD  2  26 B7        	rol	mnepck + s_byte
00DEBF  2  2A           	rol
00DEC0  2  CA           	dex
00DEC1  2  D0 F8        	bne	@d
00DEC3  2               
00DEC3  2  69 3F        	adc	#a_mnecvt		; Convert to ASCII and ...
00DEC5  2  48           	pha				; Push to stack
00DEC6  2  88           	dey
00DEC7  2  D0 EE        	bne	@c			; Continue with mnemonic
00DEC9  2               
00DEC9  2  A0 03        	ldy	#s_mnemonic
00DECB  2               
00DECB  2               @e:
00DECB  2  68           	pla				; Get mnemonic byte
00DECC  2  20 0C FD     	jsr	putcha			; Print it
00DECF  2  88           	dey
00DED0  2  D0 F9        	bne	@e
00DED2  2               ;------------------------------------------------------------------------------
00DED2  2               ; Display operand
00DED2  2               ;------------------------------------------------------------------------------
00DED2  2  A5 BF        	lda	iopsize			; Operand size
00DED4  2  F0 6F        	beq	clearlin		; Zero, disassembly finished
00DED6  2               
00DED6  2  20 D4 DF     	jsr	printspc		; <Space> to operand field
00DED9  2  24 C1        	bit	vopsflag		; Check mode flags
00DEDB  2  50 08        	bvc	dpycod02		; not a branch
00DEDD  2  20 08 E3     	jsr	offtarg			; Compute branch target
00DEE0  2  A6 B4        	ldx	instsize		; Effective instruction size
00DEE2  2  CA           	dex
00DEE3  2  86 BF        	stx	iopsize			; Effective operand size
00DEE5  2               
00DEE5  2               dpycod02:
00DEE5  2  64 C1        	stz	vopsflag		; Clear
00DEE7  2  A5 B1        	lda	admodidx		; Instruction addressing mode
00DEE9  2  C9 0B        	cmp	#am_move		; Block move instruction?
00DEEB  2  D0 02        	bne	@a			; No...
00DEED  2               
00DEED  2  66 C1        	ror	vopsflag		; Yes
00DEEF  2               
00DEEF  2               @a:
00DEEF  2  0A           	asl				; Convert addressing mode to ...
00DEF0  2  AA           	tax				; ... symbology table index
00DEF1  2               
00DEF1  2  C2 20        	longa				; 16-Bit .A
00DEF3  2               
00DEF3  2  BD 73 E7     	lda	ms_lutab, X		; Addressing symbol pointer
00DEF6  2  48           	pha
00DEF7  2               
00DEF7  2  E2 20        	shorta				; 8-Bit .A
00DEF9  2               
00DEF9  2  A0 00        	ldy	#$00
00DEFB  2  B3 01        	lda	(1 ,S), Y		; Get 1st character
00DEFD  2  C9 20        	cmp	#SPACE
00DEFF  2  F0 03        	beq	@b			; No addressing mode preamble
00DF01  2               
00DF01  2  20 0C FD     	jsr	putcha			; Print preamble
00DF04  2               
00DF04  2               @b:
00DF04  2  A9 24        	lda	#c_hex
00DF06  2  20 0C FD     	jsr	putcha			; Operand displayed as hex
00DF09  2  A4 BF        	ldy	iopsize			; Operand size = index
00DF0B  2               
00DF0B  2               @c:
00DF0B  2  88           	dey
00DF0C  2  30 16        	bmi	@d			; Done with operand
00DF0E  2               
00DF0E  2  B9 A9 00     	lda	operand, Y		; Get operand byte
00DF11  2  20 AD DF     	jsr	dpyhex			; Print operand byte
00DF14  2  24 C1        	bit	vopsflag		; Block move?
00DF16  2  10 F3        	bpl	@c			; No
00DF18  2               
00DF18  2  64 C1        	stz	vopsflag		; Reset
00DF1A  2  5A           	phy				; Protect operand index
00DF1B  2  F4 AC E7     	pea	ms_move
00DF1E  2  20 D9 DF     	jsr	sprint			; Display MVN/MVP operand reperator
00DF21  2  7A           	ply				; Recover operand index
00DF22  2  80 E7        	bra	@c			; Continue
00DF24  2               
00DF24  2               @d:
00DF24  2  FA           	plx				; Symbology LSB
00DF25  2  7A           	ply				; Symbology MSB
00DF26  2  E8           	inx				; move past preamble
00DF27  2  D0 01        	bne	@e
00DF29  2               
00DF29  2  C8           	iny
00DF2A  2               
00DF2A  2               @e:
00DF2A  2  5A           	phy
00DF2B  2  DA           	phx
00DF2C  2  20 D9 DF     	jsr	sprint			; Print preamble, if any
00DF2F  2               ;------------------------------------------------------------------------------
00DF2F  2               ; Condition immediate mode display format
00DF2F  2               ;------------------------------------------------------------------------------
00DF2F  2               dpycod03:
00DF2F  2  A5 A9        	lda	operand			; Operand LSB
00DF31  2  29 30        	and	#pfxmxmask		; Isolate m & x bits
00DF33  2  0A           	asl				; Shift to match ...
00DF34  2  0A           	asl				; FLIMFLAG aligment
00DF35  2  A6 B8        	ldx	opcode			; Current instruction
00DF37  2  E0 C2        	cpx	#opc_rep		; Was it REP?
00DF39  2  D0 04        	bne	@a			; No
00DF3B  2               
00DF3B  2  04 BC        	tsb	flimflag		; Set flag bits as required
00DF3D  2  80 06        	bra	clearlin
00DF3F  2               
00DF3F  2               @a:
00DF3F  2  E0 E2        	cpx	#opc_sep		; Was it SEP
00DF41  2  D0 02        	bne	clearlin		; No, just exit
00DF43  2               
00DF43  2  14 BC        	trb	flimflag		; Clear flag bits as required
00DF45  2               
00DF45  2               ;------------------------------------------------------------------------------
00DF45  2               ; clearlin: Clear Display Line
00DF45  2               ;------------------------------------------------------------------------------
00DF45  2               clearlin:
00DF45  2  60           	rts
00DF46  2               
00DF46  2               ;------------------------------------------------------------------------------
00DF46  2               ; dpyibuf: Display Monitor Input Buffer Contents
00DF46  2               ;------------------------------------------------------------------------------
00DF46  2               dpyibuf:
00DF46  2  F4 00 02     	pea	ibuffer
00DF49  2  80 3C        	bra	dpyerraa
00DF4B  2               
00DF4B  2               ;------------------------------------------------------------------------------
00DF4B  2               ; dpymem: Display Memory
00DF4B  2               ;
00DF4B  2               ;	This function displays 16 bytes of memory as hex values & as
00DF4B  2               ;	ASCII equivalents.  The starting address for the display is
00DF4B  2               ;	in ADDRA & is expected to be a 24 bit address.  Upon return,
00DF4B  2               ;	ADDRA will point to the start of the next 16 bytes.
00DF4B  2               ;------------------------------------------------------------------------------
00DF4B  2               dpymem:
00DF4B  2  E2 30        	shortr				; 8-Bit .A, .X and .Y
00DF4D  2               
00DF4D  2  64 B2        	stz	charcnt			; Reset
00DF4F  2  A9 3E        	lda	#memPrefix
00DF51  2  20 0C FD     	jsr	putcha			; Display prefix
00DF54  2  20 90 DF     	jsr	prntladr		; Print 24-bit address
00DF57  2  A2 00        	ldx	#$00			; String buffer index
00DF59  2  A0 10        	ldy	#n_dump			; # Bytes per line
00DF5B  2               
00DF5B  2               @a:
00DF5B  2  20 D1 E2     	jsr	getbyte			; Get from RAM, also ...
00DF5E  2  48           	pha				; ... save for decoding
00DF5F  2  DA           	phx				; Save string index
00DF60  2  20 C9 DF     	jsr	printbyt		; Display as hex ASCII
00DF63  2  E6 B2        	inc	charcnt			; Bytes displayed +1
00DF65  2  FA           	plx				; Recover string index and ...
00DF66  2  68           	pla				; ... byte
00DF67  2  C9 20        	cmp	#SPACE			; Printable?
00DF69  2  90 04        	bcc	@b			; No ...
00DF6B  2               
00DF6B  2  C9 7F        	cmp	#DEL
00DF6D  2  90 02        	bcc	@c			; Is printable
00DF6F  2               
00DF6F  2               @b:
00DF6F  2  A9 2E        	lda	#memSubChar		; Get substitute character
00DF71  2               
00DF71  2               @c:
00DF71  2  9D 00 02     	sta	ibuffer, X		; Save character
00DF74  2  E8           	inx				; Bump index
00DF75  2  88           	dey				; Byte count - 1
00DF76  2  D0 E3        	bne	@a			; Not done, yet ...
00DF78  2               
00DF78  2  9E 00 02     	stz	ibuffer, X		; Terminate ASCII string
00DF7B  2  A9 3A        	lda	#memSepChar
00DF7D  2  20 0C FD     	jsr	putcha			; Seperate ASCII from bytes
00DF80  2  20 46 DF     	jsr	dpyibuf			; Display ASCII equivalents
00DF83  2  60           	rts
00DF84  2               ;------------------------------------------------------------------------------
00DF84  2               ; dpyerr: Display Error Signal
00DF84  2               ;------------------------------------------------------------------------------
00DF84  2               dpyerr:
00DF84  2  F4 00 E8     	pea	mm_err			; "*ERR*"
00DF87  2               
00DF87  2               dpyerraa:
00DF87  2  20 D9 DF     	jsr	sprint
00DF8A  2  60           	rts
00DF8B  2               
00DF8B  2               ;------------------------------------------------------------------------------
00DF8B  2               ; gendbs: Generate Destructive <Backspace>
00DF8B  2               ;------------------------------------------------------------------------------
00DF8B  2               gendbs:
00DF8B  2  F4 BA E7     	pea	dc_bs			; Destructive <Backspace>
00DF8E  2  80 F7        	bra	dpyerraa
00DF90  2               
00DF90  2               ;------------------------------------------------------------------------------
00DF90  2               ; prntladr: Print 24-bit Current Address
00DF90  2               ;------------------------------------------------------------------------------
00DF90  2               prntladr:
00DF90  2  08           	php				; Protect register sizes
00DF91  2               
00DF91  2  E2 20        	shorta				; 8-Bit .A
00DF93  2               
00DF93  2  A5 91        	lda	addra + s_word		; Get blank byte and ...
00DF95  2  20 AD DF     	jsr	dpyhex			; ... display it
00DF98  2               
00DF98  2  C2 20        	longa				; 16-Bit .A
00DF9A  2               
00DF9A  2  A5 8F        	lda	addra			; Get 16-bit address
00DF9C  2  28           	plp				; Restore register sizes
00DF9D  2               ;------------------------------------------------------------------------------
00DF9D  2               ; vvvvvv  Flow into vvvvvv
00DF9D  2               
00DF9D  2               ;------------------------------------------------------------------------------
00DF9D  2               ; dpyhexw: Display Binary Word as Hex ASCII
00DF9D  2               ;
00DF9D  2               ;	Preparatory Ops: .C: word to display
00DF9D  2               ;
00DF9D  2               ;	Returned Values: .C: used
00DF9D  2               ;	                 .X: used
00DF9D  2               ;	                 .Y: entry value
00DF9D  2               ;------------------------------------------------------------------------------
00DF9D  2               dpyhexw:
00DF9D  2  08           	php				; Protect register sizes
00DF9E  2               
00DF9E  2  C2 20        	longa				; 16-Bit .A
00DFA0  2               
00DFA0  2  48           	pha				; Protect value
00DFA1  2               
00DFA1  2  E2 20        	shorta				; 8-Bit .A
00DFA3  2               
00DFA3  2  EB           	xba				; Get MSB of address and ...
00DFA4  2  20 AD DF     	jsr	dpyhex			; ... print
00DFA7  2               
00DFA7  2  C2 20        	longa				; 16-bit .A
00DFA9  2               
00DFA9  2  68           	pla				; Recover value
00DFAA  2               
00DFAA  2  E2 20        	shorta				; 8-Bit .A
00DFAC  2               					; Only LSB is now available in .A
00DFAC  2  28           	plp				; Reset register sizes
00DFAD  2               
00DFAD  2               ;------------------------------------------------------------------------------
00DFAD  2               ; dpyhex: Display Binary Byte as Hex ASCII
00DFAD  2               ;
00DFAD  2               ;	Preparatory Ops: .A: byte to display
00DFAD  2               ;
00DFAD  2               ;	Returned Values: .A: used
00DFAD  2               ;	                 .X: used
00DFAD  2               ;	                 .Y: entry value
00DFAD  2               ;------------------------------------------------------------------------------
00DFAD  2               dpyhex:
00DFAD  2  20 4F E1     	jsr	binhex			; Convert to hex ASCII
00DFB0  2  20 0C FD     	jsr	putcha			; Print MSN
00DFB3  2  8A           	txa
00DFB4  2  4C 0C FD     	jmp	putcha			; Print LSN
00DFB7  2               
00DFB7  2               ;------------------------------------------------------------------------------
00DFB7  2               ; multspc: Print Multiple Blanks
00DFB7  2               ;
00DFB7  2               ;	Preparatory Ops : .X: number of blanks to print
00DFB7  2               ;
00DFB7  2               ;	Register Returns: none
00DFB7  2               ;
00DFB7  2               ;	Calling Example : ldx #3
00DFB7  2               ;	                  jsr multspc    ;print 3 spaces
00DFB7  2               ;
00DFB7  2               ;	Notes: This sub will print 1 blank if .X=0.
00DFB7  2               ;------------------------------------------------------------------------------
00DFB7  2               multspc:
00DFB7  2  8A           	txa
00DFB8  2  D0 01        	bne	@a			; Blank count specified
00DFBA  2               
00DFBA  2  E8           	inx				; Default to 1 blank/<Space>
00DFBB  2               
00DFBB  2               @a:
00DFBB  2  A9 20        	lda	#' '
00DFBD  2               
00DFBD  2               @b:
00DFBD  2  20 0C FD     	jsr	putcha
00DFC0  2  CA           	dex
00DFC1  2  D0 FA        	bne	@b
00DFC3  2               
00DFC3  2  60           	rts
00DFC4  2               
00DFC4  2               ;------------------------------------------------------------------------------
00DFC4  2               ; newline: Print Newline (<CR><LF>)
00DFC4  2               ;------------------------------------------------------------------------------
00DFC4  2               newline:
00DFC4  2  F4 BC E7     	pea	dc_lf
00DFC7  2  80 BE        	bra	dpyerraa
00DFC9  2               
00DFC9  2               ;------------------------------------------------------------------------------
00DFC9  2               ; printbyt: Print a Byte With Leading <Space>
00DFC9  2               ;------------------------------------------------------------------------------
00DFC9  2               printbyt:
00DFC9  2  48           	pha				; Protect byte
00DFCA  2  20 D4 DF     	jsr	printspc		; Print leading <Space>
00DFCD  2  68           	pla				; Restore .A and ...
00DFCE  2  80 DD        	bra	dpyhex			; ... print byte
00DFD0  2               
00DFD0  2               ;------------------------------------------------------------------------------
00DFD0  2               ; alert: Alert User With <Bell>
00DFD0  2               ;------------------------------------------------------------------------------
00DFD0  2               alert:
00DFD0  2  A9 07        	lda	#BELL
00DFD2  2  80 02        	bra	printcmn
00DFD4  2               
00DFD4  2               ;------------------------------------------------------------------------------
00DFD4  2               ; printspc: Print a <Space>
00DFD4  2               ;------------------------------------------------------------------------------
00DFD4  2               printspc:
00DFD4  2  A9 20        	lda	#SPACE
00DFD6  2               
00DFD6  2               ;------------------------------------------------------------------------------
00DFD6  2               ; printcmn: A Common Print Routine
00DFD6  2               ;------------------------------------------------------------------------------
00DFD6  2               printcmn:
00DFD6  2  4C 0C FD     	jmp	putcha
00DFD9  2               
00DFD9  2               ;------------------------------------------------------------------------------
00DFD9  2               ; sprint: Print Null-Terminated Character String
00DFD9  2               ;
00DFD9  2               ;	Preparatory Ops : SP+1: string address LSB
00DFD9  2               ;	                  SP+2: string address MSB
00DFD9  2               ;
00DFD9  2               ;	Register Returns: .A: used
00DFD9  2               ;	                  .B: entry value
00DFD9  2               ;	                  .X: used
00DFD9  2               ;	                  .Y: used
00DFD9  2               ;
00DFD9  2               ;	MPU Flags: NVmxDIZC
00DFD9  2               ;	           ||||||||
00DFD9  2               ;	           |||||||+---> 0: okay
00DFD9  2               ;	           |||||||      1: string too long (1)
00DFD9  2               ;	           ||||+++----> not defined
00DFD9  2               ;	           |||+-------> 1
00DFD9  2               ;	           ||+--------> 1
00DFD9  2               ;	           ++---------> not defined
00DFD9  2               ;
00DFD9  2               ;	Example: PER STRING
00DFD9  2               ;	         JSR SPRINT
00DFD9  2               ;	         BCS TOOLONG
00DFD9  2               ;
00DFD9  2               ;	Notes: 1) Maximum permissible string length including the
00DFD9  2               ;	          terminator is 32,767 bytes.
00DFD9  2               ;	       2) All registers are forced to 8 bits.
00DFD9  2               ;	       3) DO NOT JUMP OR BRANCH INTO THIS FUNCTION!
00DFD9  2               ;------------------------------------------------------------------------------
00DFD9  2               sprint:
00DFD9  2  E2 20        	shorta				; 8-Bit .A
00DFDB  2               
00DFDB  2  C2 10        	longi				; 16-Bit .X and .Y
00DFDD  2               
00DFDD  2               ;------------------------------------------------------------------------------
00DFDD  2               _retaddr 	= 1			; Return address
00DFDD  2               _src		= _retaddr + s_word	; String address stack offset
00DFDD  2               ;------------------------------------------------------------------------------
00DFDD  2  A0 00 00     	ldy	#$0000
00DFE0  2  18           	clc				; Initial no error
00DFE1  2               
00DFE1  2               @next:
00DFE1  2  B3 03        	lda	(_src, S), Y		; Get a byte
00DFE3  2  F0 0D        	beq	@done			; If $00, we are done
00DFE5  2               ;
00DFE5  2  5A           	phy				; Save our 16-bit .Y
00DFE6  2               ;
00DFE6  2  20 0C FD     	jsr	putcha			; Print character
00DFE9  2               ;
00DFE9  2  C2 10        	longi				; Force proper register widths
00DFEB  2  E2 20        	shorta
00DFED  2  7A           	ply				; Retrieve .Y (with proper width)
00DFEE  2               ;
00DFEE  2  C8           	iny				; Increment .Y
00DFEF  2  10 F0        	bpl	@next			; Read next char if .Y < ($FFFF + 1)
00DFF1  2               ;
00DFF1  2  38           	sec				; String too long
00DFF2  2               
00DFF2  2               @done:
00DFF2  2  FA           	plx				; Pull RTS address
00DFF3  2  7A           	ply				; Clear string pointer
00DFF4  2  DA           	phx				; Replace RTS
00DFF5  2               
00DFF5  2  E2 10        	shorti				; 8-Bit .X and .Y
00DFF7  2               
00DFF7  2  60           	rts
00DFF8  2               
00DFF8  2               ;------------------------------------------------------------------------------
00DFF8  2               ; ascbin: Convert Null-Terminated ASCII Number String To Binary
00DFF8  2               ;
00DFF8  2               ;	Preparatory Ops: ASCII number string in IBUFFER
00DFF8  2               ;
00DFF8  2               ;	Returned Values: FACA: converted parameter
00DFF8  2               ;	                   .A: used
00DFF8  2               ;	                   .X: used
00DFF8  2               ;	                   .Y: used
00DFF8  2               ;	                   .C: 1 = conversion error
00DFF8  2               ;	                   .Z: 1 = nothing to convert
00DFF8  2               ;
00DFF8  2               ;	Notes: 1) Conversion stops when a non-numeric char-
00DFF8  2               ;	          acter is encountered.
00DFF8  2               ;	       2) Radix symbols are as follows:
00DFF8  2               ;
00DFF8  2               ;	          % binary
00DFF8  2               ;	          @ octal
00DFF8  2               ;	          + decimal
00DFF8  2               ;	          $ hexadecimal
00DFF8  2               ;
00DFF8  2               ;	          Hex is the default if no radix is speci-
00DFF8  2               ;	          fied in the 1st character of the string.
00DFF8  2               ;------------------------------------------------------------------------------
00DFF8  2               ascbin:
00DFF8  2  E2 30        	shortr				; 8-Bit .A, .X and .Y
00DFFA  2               
00DFFA  2  20 62 E1     	jsr	clrfaca			; Clear .A
00DFFD  2  64 B2        	stz	charcnt			; Zero char count
00DFFF  2  64 B0        	stz	radix			; Initialize
00E001  2               ;------------------------------------------------------------------------------
00E001  2               ; Process radix if present
00E001  2               ;------------------------------------------------------------------------------
00E001  2  20 E1 E3     	jsr	getcharw		; Get next non-WS char
00E004  2  D0 02        	bne	@a			; Got something
00E006  2               
00E006  2  18           	clc				; No more input
00E007  2  60           	rts
00E008  2               
00E008  2               @a:
00E008  2  A2 03        	ldx	#n_radix - 1		; Number of radices
00E00A  2               
00E00A  2               @b:
00E00A  2  DD AA E4     	cmp	radxtab, X		; Recognized radix?
00E00D  2  F0 06        	beq	@c			; Yes
00E00F  2               
00E00F  2  CA           	dex
00E010  2  10 F8        	bpl	@b			; Try next
00E012  2               
00E012  2  C6 AD        	dec 	ibufidx			; Reposition to previous character
00E014  2  E8           	inx				; Not recognized, assume hex
00E015  2               
00E015  2               @c:
00E015  2  C9 2B        	cmp	#c_dec			; Decimal radix?
00E017  2  D0 02        	bne	@d			; Nope ...
00E019  2               
00E019  2  66 B0        	ror	radix			; Flag decimal conversion
00E01B  2               
00E01B  2               @d:
00E01B  2  BD 96 E4     	lda	basetab, X		; Number bases table
00E01E  2  85 C0        	sta	range			; Set valid numeral range
00E020  2  BD 9A E4     	lda	bitsdtab, X		; Get bits per digit
00E023  2  85 AE        	sta	bitsdig			; Store
00E025  2               
00E025  2               ;------------------------------------------------------------------------------
00E025  2               ; Process numerals
00E025  2               ;------------------------------------------------------------------------------
00E025  2               ascbin01:
00E025  2  20 7F E3     	jsr	getchar			; Get next character
00E028  2               
00E028  2               ;	bne	@a			; Not End-Of-Input
00E028  2               ;	jmp	ascbin03		; End-Of-Input
00E028  2  F0 70        	beq	ascbin03		; Got End-Of-Input
00E02A  2               
00E02A  2               @a:
00E02A  2  C9 20        	cmp	#' '			; Blank, End-Of-Field (EOF)
00E02C  2  F0 6C        	beq	ascbin03
00E02E  2               
00E02E  2  C9 2C        	cmp	#','			; Comma, End-Of-Field (EOF)
00E030  2  F0 68        	beq	ascbin03
00E032  2               
00E032  2  C9 09        	cmp	#HT			; <Tab>, End-Of-Field (EOF)
00E034  2  F0 64        	beq	ascbin03
00E036  2               
00E036  2  20 BC E1     	jsr	nybtobin		; Change to binary
00E039  2               
00E039  2  B0 60        	bcs	ascbin04		; Not a recognized numeral
00E03B  2               
00E03B  2  C5 C0        	cmp	range			; Check range
00E03D  2  B0 5C        	bcs	ascbin04		; not valid for base
00E03F  2               
00E03F  2  85 AF        	sta	numeral			; Save processed numeral
00E041  2  E6 B2        	inc	charcnt			; Bump numeral count
00E043  2  24 B0        	bit	radix			; Working in base 10
00E045  2               
00E045  2  10 15        	bpl	@c			; No
00E047  2               
00E047  2               ;------------------------------------------------------------------------------
00E047  2               ; Compute N * 2 for Decimal Conversion
00E047  2               ;------------------------------------------------------------------------------
00E047  2  A2 00        	ldx	#$00			; Index into .A
00E049  2  A0 02        	ldy	#s_pfac / 2		; Iterations
00E04B  2               
00E04B  2  C2 20        	longa				; 16-bit .A
00E04D  2               
00E04D  2  18           	clc
00E04E  2               @b:
00E04E  2  B5 95        	lda	faca, X			; N
00E050  2  2A           	rol				; N = N * 2
00E051  2  95 9D        	sta	facb, X
00E053  2  E8           	inx
00E054  2  E8           	inx
00E055  2  88           	dey
00E056  2  D0 F6        	bne	@b
00E058  2               
00E058  2  B0 41        	bcs	ascbin04		; Overflow -> error
00E05A  2               
00E05A  2  E2 20        	shorta				; 8-Bit .A
00E05C  2               
00E05C  2               ;------------------------------------------------------------------------------
00E05C  2               ; Compute N * base for Binary, Octal, Hex
00E05C  2               ; or N * 8 for Decimal
00E05C  2               ;------------------------------------------------------------------------------
00E05C  2               @c:
00E05C  2  A6 AE        	ldx	bitsdig			; Bits per digit
00E05E  2               
00E05E  2  C2 20        	longa				; 16-Bit .A
00E060  2               
00E060  2               @d:
00E060  2  06 95        	asl	faca
00E062  2  26 97        	rol	faca + s_word
00E064  2  B0 35        	bcs	ascbin04		; Overflow -> error
00E066  2               
00E066  2  CA           	dex
00E067  2  D0 F7        	bne	@d			; Next shift
00E069  2               
00E069  2  E2 20        	shorta				; 8-Bit .A
00E06B  2               
00E06B  2  24 B0        	bit	radix			; Check base
00E06D  2  10 13        	bpl	ascbin02		; Not decimal
00E06F  2               ;------------------------------------------------------------------------------
00E06F  2               ; Compute N * 10 for Decimal (N * 8 + N * 2) ...
00E06F  2               ;------------------------------------------------------------------------------
00E06F  2  A0 04        	ldy	#s_pfac
00E071  2               
00E071  2  C2 20        	longa				; 16-Bit .A
00E073  2               
00E073  2               @e:
00E073  2  B5 95        	lda	faca, X			; N * 8
00E075  2  75 9D        	adc	facb, X			; N * 2
00E077  2  95 95        	sta	faca, X			; Now N * 10
00E079  2  E8           	inx
00E07A  2  E8           	inx
00E07B  2  88           	dey
00E07C  2  D0 F5        	bne	@e
00E07E  2               
00E07E  2  B0 1B        	bcs	ascbin04		; Overflow -> error
00E080  2               
00E080  2  E2 20        	shorta				; 8-Bit .A
00E082  2               
00E082  2               ;------------------------------------------------------------------------------
00E082  2               ; Add current numeral to partial result
00E082  2               ;------------------------------------------------------------------------------
00E082  2               ascbin02:
00E082  2  A5 95        	lda	faca			; N
00E084  2  65 AF        	adc	numeral			; N = N + D
00E086  2  85 95        	sta	faca
00E088  2  A2 01        	ldx	#$01
00E08A  2  A0 03        	ldy	#s_pfac - 1
00E08C  2               
00E08C  2               @a:
00E08C  2  B5 95        	lda	faca, X
00E08E  2  69 00        	adc	#$00			; Account for Carry
00E090  2  95 95        	sta	faca, X
00E092  2  E8           	inx
00E093  2  88           	dey
00E094  2  D0 F6        	bne	@a
00E096  2               
00E096  2  90 8D        	bcc 	ascbin01		; Next if no overflow
00E098  2               ;	bcc	ascbin05		; Used to circumvent branch err
00E098  2               
00E098  2  B0 01        	bcs	ascbin04		; Overflow -> error
00E09A  2               ;------------------------------------------------------------------------------
00E09A  2               ; Now, finish up
00E09A  2               ;------------------------------------------------------------------------------
00E09A  2               ascbin03:
00E09A  2  18           	clc				; No error
00E09B  2               
00E09B  2               ascbin04:
00E09B  2  E2 20        	shorta				; 8-Bit .A
00E09D  2               					; Reset if necessary
00E09D  2               
00E09D  2  A5 B2        	lda	charcnt			; Load the character count
00E09F  2  60           	rts				; Done
00E0A0  2               
00E0A0  2               ascbin05:
00E0A0  2  4C 25 E0     	jmp	ascbin01		; Next if no overflow
00E0A3  2               
00E0A3  2               ;------------------------------------------------------------------------------
00E0A3  2               ; bcdasc: Convert BCD digit to ASCII
00E0A3  2               ;
00E0A3  2               ;	Preparatory Ops: .A: BCD digit, $00-$99
00E0A3  2               ;
00E0A3  2               ;	Returned Values: .A: ASCII MSD
00E0A3  2               ;	                 .X: ASCII LSD
00E0A3  2               ;	                 .Y: entry value
00E0A3  2               ;------------------------------------------------------------------------------
00E0A3  2               bcdasc:
00E0A3  2  20 AF E0     	jsr	bintonyb		; Extract nybbles
00E0A6  2  48           	pha				; Save tens
00E0A7  2  8A           	txa
00E0A8  2  09 30        	ora	#btoamask		; Change units to ASCII
00E0AA  2  AA           	tax				; Store
00E0AB  2  68           	pla				; Get tens
00E0AC  2  09 30        	ora	#btoamask		; Change to ASCII
00E0AE  2  60           	rts
00E0AF  2               
00E0AF  2               ;------------------------------------------------------------------------------
00E0AF  2               ; bintonyb: Extract Binary Nybbles
00E0AF  2               ;
00E0AF  2               ;	Preparatory Ops: .A: binary value
00E0AF  2               ;
00E0AF  2               ;	Returned Values: .A: MSN
00E0AF  2               ;	                 .X: LSN
00E0AF  2               ;	                 .Y: entry value
00E0AF  2               ;------------------------------------------------------------------------------
00E0AF  2               bintonyb:
00E0AF  2  48           	pha				; Save
00E0B0  2  29 0F        	and	#bcdumask		; Extract LSN
00E0B2  2  AA           	tax				; Save it
00E0B3  2  68           	pla
00E0B4  2  4A           	lsr				; Extract MSN
00E0B5  2  4A           	lsr
00E0B6  2  4A           	lsr
00E0B7  2  4A           	lsr
00E0B8  2  60           	rts
00E0B9  2               
00E0B9  2               ;------------------------------------------------------------------------------
00E0B9  2               ; binasc: Convert 32-bit Binary to Null-Terminated ASCII Number String
00E0B9  2               ;
00E0B9  2               ;	Preparatory Ops: FACA: 32-bit operand
00E0B9  2               ;	                   .A: radix character, w/bit 7 set to
00E0B9  2               ;	                       suppress radix symbol in the
00E0B9  2               ;	                       conversion string
00E0B9  2               ;
00E0B9  2               ;	Returned Values: ibuffer: conversion string
00E0B9  2               ;	                      .A: string length
00E0B9  2               ;	                      .X: string address LSB
00E0B9  2               ;	                      .Y: string address MSB
00E0B9  2               ;
00E0B9  2               ;	Execution Notes: ibufidx & instsize are overwritten.
00E0B9  2               ;------------------------------------------------------------------------------
00E0B9  2               binasc:
00E0B9  2  E2 30        	shortr
00E0BB  2               
00E0BB  2  64 AD        	stz	ibufidx			; Initialize sting index
00E0BD  2  64 B4        	stz	instsize		; Clear format flag
00E0BF  2               ;------------------------------------------------------------------------------
00E0BF  2               ; Evaluate radix
00E0BF  2               ;------------------------------------------------------------------------------
00E0BF  2  0A           	asl				; Extract format flag and ...
00E0C0  2  66 B4        	ror	instsize		; ... save it
00E0C2  2  4A           	lsr				; Extract radix character
00E0C3  2  A2 03        	ldx	#n_radix - 1		; Total radices
00E0C5  2               
00E0C5  2               @a:
00E0C5  2  DD AA E4     	cmp	radxtab, X		; Recognized radix?
00E0C8  2               
00E0C8  2  F0 04        	beq	@b			; Yes
00E0CA  2               
00E0CA  2  CA           	dex
00E0CB  2  10 F8        	bpl	@a			; Try next
00E0CD  2               
00E0CD  2  E8           	inx				; Assume hex
00E0CE  2               
00E0CE  2               @b:
00E0CE  2  86 B0        	stx	radix			; Save radix index for later
00E0D0  2  24 B4        	bit 	instsize
00E0D2  2  30 08        	bmi	@c			; No radix symbol wanted
00E0D4  2               
00E0D4  2  BD AA E4     	lda	radxtab, X		; Radix table
00E0D7  2  8D 00 02     	sta	ibuffer			; Prepend string
00E0DA  2  E6 AD        	inc	ibufidx			; Bump string index
00E0DC  2               
00E0DC  2               @c:
00E0DC  2  C9 2B        	cmp	#c_dec			; Convert to decimal?
00E0DE  2  D0 07        	bne	@d			; Nope...
00E0E0  2               
00E0E0  2  20 74 E1     	jsr	facabcd			; Convert operand to BCD
00E0E3  2  A9 00        	lda	#$00
00E0E5  2  80 17        	bra	@g			; Skip binary stuff
00E0E7  2               ;------------------------------------------------------------------------------
00E0E7  2               ; Prepare for binary, octal or hex conversion
00E0E7  2               ;------------------------------------------------------------------------------
00E0E7  2               @d:
00E0E7  2  A2 00        	ldx	#$00			; Operand index
00E0E9  2  A0 05        	ldy	#s_sfac - 1		; Workspace index
00E0EB  2               
00E0EB  2               @e:
00E0EB  2  B5 95        	lda	faca, X			; Copy operand to ...
00E0ED  2  99 9D 00     	sta	facb, Y			; ... workspace in ...
00E0F0  2               
00E0F0  2  88           	dey				; ... big endian order
00E0F1  2  E8           	inx
00E0F2  2  E0 04        	cpx	#s_pfac
00E0F4  2  D0 F5        	bne	@e
00E0F6  2               
00E0F6  2  A9 00        	lda	#$00
00E0F8  2  BB           	tyx
00E0F9  2               
00E0F9  2               @f:
00E0F9  2  95 9D        	sta	facb, X			; Pad workspace
00E0FB  2               
00E0FB  2  CA           	dex
00E0FC  2  10 FB        	bpl	@f
00E0FE  2               ;------------------------------------------------------------------------------
00E0FE  2               ; Set up conversion parameters
00E0FE  2               ;------------------------------------------------------------------------------
00E0FE  2               @g:
00E0FE  2  85 A3        	sta	facc			; Initialyze byte counter
00E100  2               
00E100  2  A4 B0        	ldy	radix			; radix index
00E102  2  B9 A6 E4     	lda	numstab, Y		; Numerals in string
00E105  2  85 A4        	sta	facc + s_byte		; Set remaining numeral count
00E107  2               
00E107  2  B9 9E E4     	lda 	bitsntab, Y		; Bits per numeral
00E10A  2  85 A5        	sta	facc + s_word		; Set
00E10C  2               
00E10C  2  B9 A2 E4     	lda	lzsttab, Y		; Leading zero threshold
00E10F  2  85 A6        	sta	facc + s_xword		; Set
00E111  2               
00E111  2               ;------------------------------------------------------------------------------
00E111  2               ; Generate conversion string
00E111  2               ;------------------------------------------------------------------------------
00E111  2               @h:
00E111  2  A9 00        	lda	#$00
00E113  2  A4 A5        	ldy	facc + s_word		; Bits per numeral
00E115  2               
00E115  2               @i:
00E115  2  A2 05        	ldx	#s_sfac - 1		; Workspace size
00E117  2  18           	clc				; Avoid starting carry
00E118  2               
00E118  2               @j:
00E118  2  36 9D        	rol	facb, X			; Shift out a bit ...
00E11A  2  CA           	dex				; from the operand or ...
00E11B  2  10 FB        	bpl	@j			; BCD conversion result
00E11D  2               
00E11D  2  2A           	rol				; Bits to .A
00E11E  2               
00E11E  2  88           	dey
00E11F  2  D0 F4        	bne	@i			; More bits to grab
00E121  2               
00E121  2  A8           	tay				; If numeral isn't zero
00E122  2  D0 0A        	bne	@k			; Skip leading zero tests
00E124  2               
00E124  2  A6 A4        	ldx	facc + s_byte		; Remaining numerals
00E126  2  E4 A6        	cpx	facc + s_xword		; Leading zero threshold
00E128  2  90 04        	bcc	@k			; Below it, must convert
00E12A  2               
00E12A  2  A6 A3        	ldx	facc			; Processed byte count
00E12C  2  F0 11        	beq	@m			; Discard leading zero
00E12E  2               
00E12E  2               @k:
00E12E  2  C9 0A        	cmp	#10			; Check range
00E130  2  90 02        	bcc	@l			; is 0-9
00E132  2               
00E132  2  69 06        	adc	#a_hexdec		; Apply hex adjust
00E134  2               
00E134  2               @l:
00E134  2  69 30        	adc	#'0'			; Change to ASCII
00E136  2               
00E136  2  A4 AD        	ldy 	ibufidx			; String index
00E138  2  99 00 02     	sta	ibuffer, Y		; Save numeral in buffer
00E13B  2  E6 AD        	inc	ibufidx			; Next buffer position
00E13D  2  E6 A3        	inc 	facc			; Bytes = bytes + 1
00E13F  2               
00E13F  2               @m:
00E13F  2  C6 A4        	dec	facc + s_byte		; Numerals = numerals - 1
00E141  2               
00E141  2  D0 CE        	bne	@h			; not done, yet ...
00E143  2               ;------------------------------------------------------------------------------
00E143  2               ; Terminate string and exit
00E143  2               ;------------------------------------------------------------------------------
00E143  2  A6 AD        	ldx	ibufidx			; Printable string length
00E145  2  9E 00 02     	stz	ibuffer, X		; Terminate string
00E148  2  8A           	txa
00E149  2  A2 00        	ldx	#<ibuffer		; Converted string
00E14B  2  A0 02        	ldy	#>ibuffer
00E14D  2  18           	clc				; All okay
00E14E  2  60           	rts
00E14F  2               
00E14F  2               ;------------------------------------------------------------------------------
00E14F  2               ; binhex: Convert Binary to Hex ASCII Characters
00E14F  2               ;
00E14F  2               ;	Preparatory Ops: .A: byte to convert
00E14F  2               ;
00E14F  2               ;	Returned Values: .A: MSN ASCII char
00E14F  2               ;	                 .X: LSN ASCII char
00E14F  2               ;	                 .Y: entry value
00E14F  2               ;------------------------------------------------------------------------------
00E14F  2               binhex:
00E14F  2  20 AF E0     	jsr	bintonyb		; Generate binary values
00E152  2  48           	pha				; Save MSN
00E153  2  8A           	txa
00E154  2  20 59 E1     	jsr	@a			; Generate ASCII LSN
00E157  2  AA           	tax				; Save
00E158  2  68           	pla				; Get original input
00E159  2               ;------------------------------------------------------------------------------
00E159  2               ; Convert nybble to hex ASCII equivalents
00E159  2               ;------------------------------------------------------------------------------
00E159  2  C9 0A        @a:	cmp	#10			; Intentional decimal entry!
00E15B  2  90 02        	bcc	@b			; In decimal range?
00E15D  2               
00E15D  2  69 66        	adc	#k_hex			; Compensate for hex
00E15F  2               
00E15F  2               @b:
00E15F  2  49 30        	eor	#'0'			; Finalize nybble
00E161  2  60           	rts				; Done
00E162  2               
00E162  2               ;------------------------------------------------------------------------------
00E162  2               ; clrfaca: Clear Floating Accumulator .A
00E162  2               ;
00E162  2               ;------------------------------------------------------------------------------
00E162  2               clrfaca:
00E162  2  08           	php				; Store processor status
00E163  2               
00E163  2  C2 20        	longa
00E165  2               
00E165  2  64 95        	stz	faca
00E167  2  64 97        	stz	faca + s_word
00E169  2  28           	plp				; Restore processor status
00E16A  2               
00E16A  2  60           	rts
00E16B  2               
00E16B  2               ;------------------------------------------------------------------------------
00E16B  2               ; clrfacb: Clear Floating Accumulator .B
00E16B  2               ;
00E16B  2               ;------------------------------------------------------------------------------
00E16B  2               clrfacb:
00E16B  2  08           	php				; Store processor status
00E16C  2               
00E16C  2  C2 20        	longa
00E16E  2               
00E16E  2  64 9D        	stz	facb
00E170  2  64 9F        	stz	facb + s_word
00E172  2  28           	plp				; Restore processor status
00E173  2               
00E173  2  60           	rts
00E174  2               
00E174  2               ;------------------------------------------------------------------------------
00E174  2               ; facabcd: Convert FACA into BCD
00E174  2               ;
00E174  2               ;------------------------------------------------------------------------------
00E174  2               facabcd:
00E174  2  A2 03        	ldx	#s_pfac - 1		; Primary accumulator size - 1
00E176  2               
00E176  2               @a:
00E176  2  B5 95        	lda	faca, X			; Value to be converted
00E178  2  48           	pha				; Preserve original
00E179  2  CA           	dex
00E17A  2  10 FA        	bpl	@a			; Next
00E17C  2               
00E17C  2  A2 05        	ldx	#s_sfac - 1		; Workspace size
00E17E  2               
00E17E  2               @b:
00E17E  2  74 9D        	stz	facb, X			; Clear final result storage
00E180  2  74 A3        	stz	facc, X			; Clear scratchpad storage
00E182  2  CA           	dex
00E183  2  10 F9        	bpl	@b			; Next
00E185  2               
00E185  2  E6 A8        	inc	facc + s_sfac - s_byte
00E187  2  F8           	sed				; Set decimal mode
00E188  2  A0 1F        	ldy	#m_bits - 1		; Bits to convert - 1
00E18A  2               
00E18A  2               @c:
00E18A  2  A2 03        	ldx	#s_pfac - 1		; Operand size
00E18C  2  18           	clc				; No carry at start
00E18D  2               
00E18D  2               @d:
00E18D  2  76 95        	ror	faca, X			; Grab LS bit in operand
00E18F  2  CA           	dex
00E190  2  10 FB        	bpl	@d
00E192  2               
00E192  2  90 0D        	bcc	@f			; LS bit clear
00E194  2               
00E194  2  18           	clc
00E195  2  A2 05        	ldx	#s_sfac - 1
00E197  2               
00E197  2               @e:
00E197  2  B5 9D        	lda	facb, X			; Partial result
00E199  2  75 A3        	adc	facc, X			; Scratchpad
00E19B  2  95 9D        	sta	facb, X			; New partial result
00E19D  2  CA           	dex
00E19E  2  10 F7        	bpl	@e
00E1A0  2               
00E1A0  2  18           	clc
00E1A1  2               
00E1A1  2               @f:
00E1A1  2  A2 05        	ldx	#s_sfac - 1
00E1A3  2               
00E1A3  2               @g:
00E1A3  2  B5 A3        	lda	facc, X			; Scratchpad
00E1A5  2  75 A3        	adc	facc, X			; Double and ...
00E1A7  2  95 A3        	sta	facc, X			; ... save
00E1A9  2  CA           	dex
00E1AA  2  10 F7        	bpl	@g
00E1AC  2               
00E1AC  2  88           	dey
00E1AD  2  10 DB        	bpl	@c			; Next operand bit
00E1AF  2               
00E1AF  2  D8           	cld
00E1B0  2  A2 00        	ldx	#0
00E1B2  2  A0 04        	ldy	#s_pfac
00E1B4  2               
00E1B4  2               @h:
00E1B4  2  68           	pla				; Operand
00E1B5  2  95 95        	sta	faca, X			; Restore
00E1B7  2  E8           	inx
00E1B8  2  88           	dey
00E1B9  2  D0 F9        	bne	@h			; Next
00E1BB  2               
00E1BB  2  60           	rts
00E1BC  2               
00E1BC  2               ;------------------------------------------------------------------------------
00E1BC  2               ; nybtobin: Convert ASCII nybble to Binary
00E1BC  2               ;
00E1BC  2               ;------------------------------------------------------------------------------
00E1BC  2               nybtobin:
00E1BC  2  E2 30        	shortr
00E1BE  2  20 43 E4     	jsr	toupper			; Convert to upppercase if necessary
00E1C1  2  38           	sec
00E1C2  2  E9 30        	sbc	#'0'			; Change to binary
00E1C4  2  90 08        	bcc	@b			; Not a numeral -> error
00E1C6  2               
00E1C6  2  C9 0A        	cmp	#10
00E1C8  2  90 03        	bcc	@a			; Numeral is 0-9
00E1CA  2               
00E1CA  2  E9 07        	sbc	#a_hexdec + 1		; 10-15 => A-F
00E1CC  2  18           	clc				; No conversion error
00E1CD  2               
00E1CD  2               @a:
00E1CD  2  60           	rts
00E1CE  2               
00E1CE  2               @b:
00E1CE  2  38           	sec				; Conversion error
00E1CF  2  60           	rts
00E1D0  2               
00E1D0  2               ;------------------------------------------------------------------------------
00E1D0  2               ; calccnt: Compute Byte Count from Address Range
00E1D0  2               ;
00E1D0  2               ;------------------------------------------------------------------------------
00E1D0  2               calccnt:
00E1D0  2  20 6B E1     	jsr	clrfacb			; Clear .B accumulator
00E1D3  2               
00E1D3  2  C2 20        	longa				; 16-bit .A
00E1D5  2               
00E1D5  2  38           	sec
00E1D6  2  A5 92        	lda	addrb			; Ending address
00E1D8  2  E5 8F        	sbc	addra			; Starting address
00E1DA  2  85 9D        	sta	facb			; Byte count
00E1DC  2               
00E1DC  2  E2 20        	shorta				; Back to 8-bit .A
00E1DE  2               
00E1DE  2  A5 94        	lda	addrb + s_word		; Handle banks
00E1E0  2  E5 91        	sbc	addra + s_word
00E1E2  2  85 9F        	sta	facb + s_word
00E1E4  2               
00E1E4  2               ;------------------------------------------------------------------------------
00E1E4  2               ; clroper: Clear Operand
00E1E4  2               ;
00E1E4  2               ;------------------------------------------------------------------------------
00E1E4  2               clroper:
00E1E4  2  DA           	phx
00E1E5  2  A2 02        	ldx	#s_oper - 1
00E1E7  2               
00E1E7  2               @a:
00E1E7  2  74 A9        	stz	operand, X
00E1E9  2  CA           	dex
00E1EA  2  10 FB        	bpl	@a
00E1EC  2               
00E1EC  2  64 BB        	stz	eopsize
00E1EE  2  FA           	plx
00E1EF  2  60           	rts
00E1F0  2               
00E1F0  2               ;------------------------------------------------------------------------------
00E1F0  2               ; cpfwsup: Forward Copy Memory Setup
00E1F0  2               ;
00E1F0  2               ;------------------------------------------------------------------------------
00E1F0  2               cpfwsup:
00E1F0  2  C2 30        	longr				; Full 16-bit registers .A, .X and .Y
00E1F2  2               
00E1F2  2  A2 54 00     	ldx	#opc_mvn		; "Move Next" opcode
00E1F5  2  80 05        	bra	cpsup
00E1F7  2               
00E1F7  2               ;------------------------------------------------------------------------------
00E1F7  2               ; cprvsup: Reverse Copy Memory Setup
00E1F7  2               ;
00E1F7  2               ;------------------------------------------------------------------------------
00E1F7  2               cprvsup:
00E1F7  2  C2 30        	longr				; Full 16-bit registers .A, .X and .Y
00E1F9  2               
00E1F9  2  A2 44 00     	ldx	#opc_mvp		; "Move Previous" opcode
00E1FC  2               
00E1FC  2               ;------------------------------------------------------------------------------
00E1FC  2               ; cpsup: Copy Memory Setup
00E1FC  2               ;
00E1FC  2               ;------------------------------------------------------------------------------
00E1FC  2               cpsup:
00E1FC  2  48           	pha				; Save banks
00E1FD  2  8A           	txa				; Protect ...
00E1FE  2  EB           	xba				; ... opcode
00E1FF  2               
00E1FF  2  E2 20        	shorta				; 8-bit .A
00E201  2               
00E201  2  A2 08 00     	ldx	#cpcodeee - cpcode - 1
00E204  2               
00E204  2               @a:
00E204  2  BF 59 E4 00  	lda	f:cpcode, X		; Transfer code copy ...
00E208  2  95 95        	sta	mcftwork, X		; ... to workspace
00E20A  2  CA           	dex
00E20B  2  10 F7        	bpl	@a			; Until done...
00E20D  2               
00E20D  2  EB           	xba				; Recover opcode
00E20E  2  85 96        	sta	mcftopc			; Set it
00E210  2               
00E210  2  C2 20        	longa				; 16-bit .A
00E212  2               
00E212  2  68           	pla				; Retrieve banks ...
00E213  2  85 97        	sta	mcftbnk			; ... and set them
00E215  2  60           	rts
00E216  2               
00E216  2               ;------------------------------------------------------------------------------
00E216  2               ; decdcnt: Decrement Dump Count
00E216  2               ;
00E216  2               ;	Preparatory Ops: bytes to process in FACB
00E216  2               ;	                 bytes processed in CHARCNT
00E216  2               ;
00E216  2               ;	Returned Values: .A: used
00E216  2               ;	                 .X: entry value
00E216  2               ;	                 .Y: entry value
00E216  2               ;	                 .C: 1 = count = zero
00E216  2               ;------------------------------------------------------------------------------
00E216  2               decdcnt:
00E216  2  E2 20        	shorta				; 8-bit .A
00E218  2               
00E218  2  A9 00        	lda	#$00
00E21A  2  EB           	xba				; Clear .B
00E21B  2  A5 9F        	lda	facb + s_word		; Count  MSW
00E21D  2               
00E21D  2  C2 20        	longa				; 16-bit .A
00E21F  2               
00E21F  2  38           	sec
00E220  2  05 9D        	ora	facb			; Count LSW
00E222  2  F0 13        	beq	@b			; Result = 0, just quit
00E224  2               
00E224  2  A5 9D        	lda	facb
00E226  2  E5 B2        	sbc	charcnt			; Bytes processed
00E228  2  85 9D        	sta	facb
00E22A  2               
00E22A  2  E2 20        	shorta				; 8-Bit .A
00E22C  2               
00E22C  2  A5 9F        	lda	facb + s_word
00E22E  2  E9 00        	sbc	#$00			; Handle borrow/carry
00E230  2  90 04        	bcc	@a			; Underflow
00E232  2               
00E232  2  85 9F        	sta	facb + s_word
00E234  2  18           	clc				; Count > 0
00E235  2  60           	rts
00E236  2               
00E236  2               @a:
00E236  2  38           	sec
00E237  2               
00E237  2               @b:
00E237  2  E2 20        	shorta				; 8-Bit .A
00E239  2               
00E239  2  60           	rts
00E23A  2               
00E23A  2               ;------------------------------------------------------------------------------
00E23A  2               ; enddest: Get 2nd & 3rd Addresses for Compare and Transfer
00E23A  2               ;
00E23A  2               ;------------------------------------------------------------------------------
00E23A  2               enddest:
00E23A  2  20 84 E2     	jsr	facasize		; Check start ...
00E23D  2  C9 04        	cmp	#s_dword		; ... for range
00E23F  2  B0 1E        	bcs	@a			; Out of range -> error
00E241  2               
00E241  2  20 60 E2     	jsr	facaddra		; Store start address
00E244  2  20 94 E2     	jsr	getparm			; Get end address
00E247  2  B0 16        	bcs	@a			; Not entered -> error
00E249  2               
00E249  2  20 84 E2     	jsr	facasize		; Check end ...
00E24C  2  C9 04        	cmp	#s_dword		; ... for range
00E24E  2  B0 0F        	bcs	@a			; Out of range -> error
00E250  2               
00E250  2  20 6C E2     	jsr	facaddrb		; Store end address
00E253  2  20 94 E2     	jsr	getparm			; Get destination
00E256  2  B0 07        	bcs	@a			; Not entered -> error
00E258  2               
00E258  2  20 84 E2     	jsr	facasize		; Check destination ...
00E25B  2  C9 04        	cmp	#s_dword		; ... for range
00E25D  2  90 19        	bcc	facaoper		; Store destination address
00E25F  2               
00E25F  2               @a:
00E25F  2  60           	rts				; Exit w/ error
00E260  2               
00E260  2               ;------------------------------------------------------------------------------
00E260  2               ; facaddra: Copy FACA to ADDRA
00E260  2               ;
00E260  2               ;------------------------------------------------------------------------------
00E260  2               facaddra:
00E260  2  E2 30        	shortr
00E262  2  A2 02        	ldx	#s_xword - 1
00E264  2               
00E264  2               @a:
00E264  2  B5 95        	lda	faca, X
00E266  2  95 8F        	sta	addra, X
00E268  2  CA           	dex
00E269  2  10 F9        	bpl	@a
00E26B  2               
00E26B  2  60           	rts
00E26C  2               
00E26C  2               ;------------------------------------------------------------------------------
00E26C  2               ; facaddrb: Copy FACA to ADDRB
00E26C  2               ;
00E26C  2               ;------------------------------------------------------------------------------
00E26C  2               facaddrb:
00E26C  2  E2 30        	shortr
00E26E  2  A2 02        	ldx	#s_xword - 1
00E270  2               
00E270  2               @a:
00E270  2  B5 95        	lda	faca, X
00E272  2  95 92        	sta	addrb, X
00E274  2  CA           	dex
00E275  2  10 F9        	bpl	@a
00E277  2               
00E277  2  60           	rts
00E278  2               
00E278  2               ;------------------------------------------------------------------------------
00E278  2               ; facaoper: Copy FACA to operand
00E278  2               ;
00E278  2               ;------------------------------------------------------------------------------
00E278  2               facaoper:
00E278  2  E2 30        	shortr
00E27A  2  A2 02        	ldx	#s_oper - 1
00E27C  2               
00E27C  2               @a:
00E27C  2  B5 95        	lda	faca, X
00E27E  2  95 A9        	sta	operand, X
00E280  2  CA           	dex
00E281  2  10 F9        	bpl	@a
00E283  2               
00E283  2  60           	rts
00E284  2               
00E284  2               ;------------------------------------------------------------------------------
00E284  2               ; facasize: Report Operand Size in FACA
00E284  2               ;
00E284  2               ;	Preparatory Ops: operand in FACA
00E284  2               ;
00E284  2               ;	Returned Values: .A: s_byte  (1)
00E284  2               ;	                     s_word  (2)
00E284  2               ;	                     s_xword (3)
00E284  2               ;	                     s_dword (4)
00E284  2               ;
00E284  2               ;	Notes: 1) This function will always report
00E284  2               ;	          a non-zero result.
00E284  2               ;------------------------------------------------------------------------------
00E284  2               facasize:
00E284  2  E2 30        	shortr				; 8-Bit registers .A, .X and .Y
00E286  2               
00E286  2  A2 03        	ldx	#s_dword - 1
00E288  2               
00E288  2               @a:
00E288  2  B5 95        	lda	faca, X			; Get byte
00E28A  2  D0 03        	bne	@b			; Done
00E28C  2               
00E28C  2  CA           	dex
00E28D  2  D0 F9        	bne	@a			; Next
00E28F  2               
00E28F  2               @b:
00E28F  2  E8           	inx				; count = index + 1
00E290  2  8A           	txa
00E291  2  60           	rts
00E292  2               
00E292  2               ;------------------------------------------------------------------------------
00E292  2               ; getparm: Get a Parameter
00E292  2               ;
00E292  2               ;	Preparatory Ops: null-terminated input in IBUFFER
00E292  2               ;
00E292  2               ;	Returned Values: .A: chars in converted parameter
00E292  2               ;	                 .X: used
00E292  2               ;	                 .Y: entry value
00E292  2               ;	                 .C: 1 = no parameter entered
00E292  2               ;------------------------------------------------------------------------------
00E292  2               getparmr:
00E292  2  C6 AD        	dec	ibufidx			; Reread previous character
00E294  2               
00E294  2               getparm:
00E294  2  5A           	phy				; Preserve .Y
00E295  2  20 F8 DF     	jsr	ascbin			; Convert parameter to binary
00E298  2  B0 1C        	bcs	@d			; Conversion error
00E29A  2               
00E29A  2  20 7D E3     	jsr	getcharr		; Reread last character
00E29D  2  D0 08        	bne	@a			; Not end-of-input
00E29F  2               
00E29F  2  C6 AD        	dec	ibufidx			; Reindex to terminator
00E2A1  2  A5 B2        	lda	charcnt			; Get characters processed so far
00E2A3  2  F0 0C        	beq	@c			; None
00E2A5  2               
00E2A5  2  D0 08        	bne	@b			; Some
00E2A7  2               
00E2A7  2               @a:
00E2A7  2  C9 20        	cmp	#' '			; Recognize delimiter
00E2A9  2  F0 04        	beq	@b			; End of parameter
00E2AB  2               
00E2AB  2  C9 2C        	cmp	#','			; Recognized delimiter
00E2AD  2  D0 07        	bne	@d			; Unknown delimiter
00E2AF  2               
00E2AF  2               @b:
00E2AF  2  18           	clc
00E2B0  2  24           	.byte	$24			; Use BIT to skip SEC below
00E2B1  2               
00E2B1  2               @c:
00E2B1  2  38           	sec
00E2B2  2               
00E2B2  2  7A           	ply				; Restore .Y
00E2B3  2  A5 B2        	lda	charcnt			; Get count
00E2B5  2  60           	rts				; Done
00E2B6  2               
00E2B6  2               @d:
00E2B6  2  68           	pla				; Clean up stack
00E2B7  2  68           	pla
00E2B8  2  68           	pla
00E2B9  2  4C FF D8     	jmp	monerr			; Abort w/ error
00E2BC  2               
00E2BC  2               ;------------------------------------------------------------------------------
00E2BC  2               ; nxtaddra: Test and Increment Workign Address 'A'
00E2BC  2               ;
00E2BC  2               ;	Calling syntax: JSR NXTADDRA
00E2BC  2               ;
00E2BC  2               ;	Exit registers: .A: used
00E2BC  2               ;	                .B: used
00E2BC  2               ;	                .X: entry value
00E2BC  2               ;	                .Y: entry value
00E2BC  2               ;	                DB: entry value
00E2BC  2               ;	                DP: entry value
00E2BC  2               ;	                PB: entry value
00E2BC  2               ;	                SR: NVmxDIZC
00E2BC  2               ;	                    ||||||||
00E2BC  2               ;	                    |||||||+---> 0: ADDRA < ADDRB
00E2BC  2               ;	                    |||||||      1: ADDRA >= ADDRB
00E2BC  2               ;	                    ||||||+----> undefined
00E2BC  2               ;	                    |||+++-----> entry value
00E2BC  2               ;	                    ||+--------> 1
00E2BC  2               ;	                    ++---------> undefined
00E2BC  2               ;------------------------------------------------------------------------------
00E2BC  2               nxtaddra:
00E2BC  2  E2 20        	shorta				; 8-Bit .A
00E2BE  2               
00E2BE  2  A5 91        	lda	addra + s_word		; Bits 23-16
00E2C0  2  C5 94        	cmp	addrb + s_word
00E2C2  2  90 0F        	bcc	incaddra		; increment
00E2C4  2               
00E2C4  2  D0 0A        	bne	@a			; Don't increment
00E2C6  2               
00E2C6  2  C2 20        	longa				; 16-bit .A
00E2C8  2               
00E2C8  2  A5 8F        	lda	addra			; Bits 15-0
00E2CA  2  C5 92        	cmp	addrb			; Condition flags
00E2CC  2               
00E2CC  2  E2 20        	shorta				; 8-Bit .A
00E2CE  2               
00E2CE  2  90 03        	bcc	incaddra		; Increment
00E2D0  2               
00E2D0  2               @a:
00E2D0  2  60           	rts
00E2D1  2               
00E2D1  2               ;------------------------------------------------------------------------------
00E2D1  2               ; getbyte: Get a Byte from Memory
00E2D1  2               ;
00E2D1  2               ;------------------------------------------------------------------------------
00E2D1  2               getbyte:
00E2D1  2  A7 8F        	lda	[addra]			; Get a byte
00E2D3  2               
00E2D3  2               ;------------------------------------------------------------------------------
00E2D3  2               ; incaddra: Increment Working Address 'A'
00E2D3  2               ;
00E2D3  2               ;	Calling syntax: JSR INCADDRA
00E2D3  2               ;
00E2D3  2               ;	Exit registers: .A: entry value
00E2D3  2               ;	                .B: entry value
00E2D3  2               ;	                .X: entry value
00E2D3  2               ;	                .Y: entry value
00E2D3  2               ;	                DB: entry value
00E2D3  2               ;	                DP: entry value
00E2D3  2               ;	                PB: entry value
00E2D3  2               ;	                SR: NVmxDIZC
00E2D3  2               ;	                    ||||||||
00E2D3  2               ;	                    ++++++++---> entry value
00E2D3  2               ;------------------------------------------------------------------------------
00E2D3  2               incaddra:
00E2D3  2  08           	php
00E2D4  2               
00E2D4  2  C2 20        	longa				; 16-bit .A
00E2D6  2               
00E2D6  2  E6 8F        	inc	addra			; bump bits 15-0
00E2D8  2  D0 04        	bne	@a
00E2DA  2               
00E2DA  2  E2 20        	shorta
00E2DC  2               
00E2DC  2  E6 91        	inc	addra + s_word		; Bump bits 23-16 (bank)
00E2DE  2               
00E2DE  2               @a:
00E2DE  2  28           	plp
00E2DF  2  60           	rts
00E2E0  2               
00E2E0  2               ;------------------------------------------------------------------------------
00E2E0  2               ; incoper: Increment Operand Address
00E2E0  2               ;
00E2E0  2               ;------------------------------------------------------------------------------
00E2E0  2               incoper:
00E2E0  2  18           	clc
00E2E1  2  08           	php
00E2E2  2               
00E2E2  2  C2 30        	longr				; 16-Bit .A
00E2E4  2               
00E2E4  2  48           	pha
00E2E5  2  E6 A9        	inc	operand			; Handle base address
00E2E7  2  D0 06        	bne	@a
00E2E9  2               
00E2E9  2  E2 20        	shorta				; 8-Bit .A
00E2EB  2               
00E2EB  2  E6 AB        	inc	operand + s_word	; Handle bank
00E2ED  2               
00E2ED  2  C2 20        	longa				; 16-bit .A
00E2EF  2               
00E2EF  2               @a:
00E2EF  2  68           	pla
00E2F0  2  28           	plp
00E2F1  2  60           	rts
00E2F2  2               
00E2F2  2               ;------------------------------------------------------------------------------
00E2F2  2               ; instdata: Get Instruntion Size and Addressing Mode Data
00E2F2  2               ;	Preparatory Ops: .X: 65C816 opcode
00E2F2  2               ;
00E2F2  2               ;	Returned Values: .A: mode flags
00E2F2  2               ;	                 .X: operand size
00E2F2  2               ;	                 .Y: mode index
00E2F2  2               instdata:
00E2F2  2  E2 30        	shortr				; 8-bit registers .A, .X and .Y
00E2F4  2               
00E2F4  2  BD 6F E6     	lda	mnetabam, X		; Addressing mode data
00E2F7  2  48           	pha				; Save mode flag bits
00E2F8  2  48           	pha				; Save data size
00E2F9  2  29 0F        	and	#amodmask		; Extract mode index and ...
00E2FB  2  A8           	tay				; Save
00E2FC  2  68           	pla				; Recover data
00E2FD  2  29 30        	and	#opsmask		; Mask mode field and ...
00E2FF  2  4A           	lsr				; Extract operand size
00E300  2  4A           	lsr
00E301  2  4A           	lsr
00E302  2  4A           	lsr
00E303  2  AA           	tax				; Operand size
00E304  2  68           	pla				; Recover mode flags
00E305  2  29 C0        	and	#vopsmask		; Discard mode and size fields
00E307  2  60           	rts
00E308  2               
00E308  2               ;------------------------------------------------------------------------------
00E308  2               ; offtarg: Convert Branch Offset to Target Address
00E308  2               ;
00E308  2               ;	Preparatory Ops:    ADDRA: base address
00E308  2               ;	                 INSTSIZE: instruction size
00E308  2               ;	                  OPERAND: offset
00E308  2               ;
00E308  2               ;	Returned Values:  OPERAND: target address (L/H)
00E308  2               ;	                       .A: used
00E308  2               ;	                       .X: entry value
00E308  2               ;                              .Y: entry value
00E308  2               offtarg:
00E308  2  C2 20        	longa				; 16-Bit .A
00E30A  2               
00E30A  2  A5 8F        	lda	addra			; Base address
00E30C  2               
00E30C  2  E2 20        	shorta				; 8-Bit .A
00E30E  2               
00E30E  2  46 B4        	lsr	instsize		; Bit 0 will be set if ...
00E310  2  B0 07        	bcs	@a			; ... a long branch
00E312  2               
00E312  2  24 A9        	bit	operand			; Short forward or backward?
00E314  2  10 03        	bpl	@a			; Forward
00E316  2               
00E316  2  EB           	xba				; Expose address MSB
00E317  2  3A           	dea				; Back a page
00E318  2  EB           	xba				; Expose address LSB
00E319  2               
00E319  2               @a:
00E319  2  C2 20        	longa				; 16-Bit .A
00E31B  2               
00E31B  2  18           	clc
00E31C  2  65 A9        	adc	operand			; Calculate target address
00E31E  2  85 A9        	sta	operand			; New operand
00E320  2  E2 20        	shorta				; 8-Bit .A
00E322  2               
00E322  2  A9 03        	lda	#s_xword
00E324  2  85 B4        	sta	instsize		; Effectice instruction size
00E326  2  60           	rts
00E327  2               
00E327  2               ;------------------------------------------------------------------------------
00E327  2               ; setxaddr: Set Execution Address
00E327  2               ;
00E327  2               ;------------------------------------------------------------------------------
00E327  2               setxaddr:
00E327  2  B0 13        	bcs	@a			; No address given
00E329  2               
00E329  2  20 84 E2     	jsr	facasize		; Check address ...
00E32C  2  C9 04        	cmp	#s_dword		; ... range
00E32E  2  B0 0D        	bcs	@b			; Out of range
00E330  2               
00E330  2  C2 20        	longa				; 16-bit .A
00E332  2               
00E332  2  A5 95        	lda	faca			; Execution address
00E334  2  85 81        	sta	reg_pcx			; Set new .PC (Program counter) value
00E336  2               
00E336  2  E2 20        	shorta				; 8-Bit .A
00E338  2               
00E338  2  A5 97        	lda	faca + s_word
00E33A  2  85 80        	sta	reg_pbx			; Set new .PB (Program Bank) value
00E33C  2               
00E33C  2               @a:
00E33C  2  18           	clc				; No error
00E33D  2               
00E33D  2               @b:
00E33D  2  60           	rts
00E33E  2               
00E33E  2               ;------------------------------------------------------------------------------
00E33E  2               ; targoff: Convert Branch Target Address to Branch Offet
00E33E  2               ;
00E33E  2               ;	Preparatory Ops:   ADDRA: instruction address
00E33E  2               ;	                 OPERAND: target address
00E33E  2               ;
00E33E  2               ;	Returned Values: OPERAND: computed offset
00E33E  2               ;	                      .A: effective operand size
00E33E  2               ;	                      .X: entry value
00E33E  2               ;                             .Y: entry value
00E33E  2               ;	                      .C: 1 = branch out of range
00E33E  2               ;
00E33E  2               ;	Execution notes: ADDRB is set to the branch base
00E33E  2               ;	                 address.
00E33E  2               ;------------------------------------------------------------------------------
00E33E  2               targoff:
00E33E  2  64 B5        	stz	instsize + s_byte	; Always zero
00E340  2  A5 B4        	lda	instsize		; Instruction size will tell ...
00E342  2  4A           	lsr				; ... if long or short branch
00E343  2               ;------------------------------------------------------------------------------
00E343  2               _btype		= facc + 5		; Branch type flag
00E343  2               ;------------------------------------------------------------------------------
00E343  2  66 A8        	ror	_btype		; Set branch type
00E345  2               
00E345  2               ;------------------------------------------------------------------------------
00E345  2               ; x0000000
00E345  2               ; |
00E345  2               ; +--------->	0: short
00E345  2               ;		1: long
00E345  2               ;------------------------------------------------------------------------------
00E345  2  C2 20        	longa				; 16-Bit .A
00E347  2               
00E347  2  18           	clc
00E348  2  A5 8F        	lda	addra			; Instruction address
00E34A  2  65 B4        	adc	instsize		; Instruction size
00E34C  2  85 92        	sta	addrb			; Base address
00E34E  2  38           	sec
00E34F  2  A5 A9        	lda	operand			; Target address
00E351  2  E5 92        	sbc	addrb			; base address
00E353  2  85 A9        	sta	operand			; Offset
00E355  2               
00E355  2  E2 20        	shorta				; 8-Bit .A
00E357  2               
00E357  2  90 11        	bcc	@d			; Backward branch
00E359  2               ;------------------------------------------------------------------------------
00E359  2               ; Process short forward branch
00E359  2               ;------------------------------------------------------------------------------
00E359  2  EB           	xba				; Offset MSB should be zero
00E35A  2  D0 1F        	bne	@f			; If it isn't -> out of range
00E35C  2               
00E35C  2  EB           	xba				; Offset LSB should be $00 - $7F
00E35D  2  30 1C        	bmi	@f			; It isn't -> out of range
00E35F  2               
00E35F  2               @a:
00E35F  2  A9 01        	lda	#s_byte			; Final instruction size
00E361  2  18           	clc				; Branch is in range
00E362  2  60           	rts
00E363  2               ;------------------------------------------------------------------------------
00E363  2               ; Process long forward branch
00E363  2               ;------------------------------------------------------------------------------
00E363  2               @b:
00E363  2  EB           	xba				; Offset MSB should be positive
00E364  2  30 15        	bmi	@f			; It isn't -> branch out of range
00E366  2               
00E366  2               @c:
00E366  2  A9 02        	lda	#s_word
00E368  2  18           	clc
00E369  2  60           	rts
00E36A  2               
00E36A  2               ;------------------------------------------------------------------------------
00E36A  2               ; Process backward branch
00E36A  2               ;------------------------------------------------------------------------------
00E36A  2               @d:
00E36A  2  24 A8        	bit	_btype			; Long or short?
00E36C  2  30 0A        	bmi	@e			; Long ...
00E36E  2               
00E36E  2               ;------------------------------------------------------------------------------
00E36E  2               ; Process short backward branch
00E36E  2               ;------------------------------------------------------------------------------
00E36E  2  EB           	xba				; Offset MSB should be negative
00E36F  2  10 0A        	bpl	@f			; It isn't -> out of range
00E371  2               
00E371  2  49 FF        	eor	#%11111111		; Complement offset MSB 2s
00E373  2  D0 06        	bne	@f			; Out of range
00E375  2               
00E375  2  EB           	xba				; Offset LSB should be $80 - $FF
00E376  2  30 E7        	bmi	@a			; It is -> Branch in range
00E378  2               
00E378  2               ;------------------------------------------------------------------------------
00E378  2               ; Process long backward branch
00E378  2               ;------------------------------------------------------------------------------
00E378  2               @e:
00E378  2  EB           	xba				; Offset MSB should be negative
00E379  2  30 EB        	bmi	@c			; It is -> branch in range
00E37B  2               
00E37B  2               @f:
00E37B  2  38           	sec				; Range error
00E37C  2  60           	rts
00E37D  2               
00E37D  2               ;------------------------------------------------------------------------------
00E37D  2               ; getcharr: Get a Character from Input Buffer
00E37D  2               ;
00E37D  2               ;------------------------------------------------------------------------------
00E37D  2               getcharr:
00E37D  2  C6 AD        	dec	ibufidx			; Move back a character
00E37F  2               
00E37F  2               ;------------------------------------------------------------------------------
00E37F  2               ; getchar: Get a Character from Input Buffer
00E37F  2               ;	Preparatory Ops : none
00E37F  2               ;
00E37F  2               ;	Register Returns: .A: character or <NUL>
00E37F  2               ;	                  .B: entry value
00E37F  2               ;	                  .X: entry value
00E37F  2               ;	                  .Y: entry value
00E37F  2               ;
00E37F  2               ;	MPU Flags: NVmxDIZC
00E37F  2               ;	           ||||||||
00E37F  2               ;	           |||||||+---> entry value
00E37F  2               ;	           ||||||+----> 1: <NUL> gotten
00E37F  2               ;	           |||||+-----> entry value
00E37F  2               ;	           ||||+------> entry value
00E37F  2               ;	           |||+-------> entry value
00E37F  2               ;	           ||+--------> entry value
00E37F  2               ;	           |+---------> not defined
00E37F  2               ;	           +----------> not defined
00E37F  2               getchar:
00E37F  2  DA           	phx
00E380  2  5A           	phy
00E381  2  08           	php				; Save register sizes
00E382  2               
00E382  2  E2 30        	shortr				; Force 8-bit registers .A, .X and .Y
00E384  2               
00E384  2  A6 AD        	ldx	ibufidx			; Buffer index
00E386  2  BD 00 02     	lda	ibuffer, X		; Get character
00E389  2  E6 AD        	inc	ibufidx			; Bump index
00E38B  2  28           	plp				; Restore register widths
00E38C  2  7A           	ply
00E38D  2  FA           	plx
00E38E  2  EB           	xba				; Condition
00E38F  2  EB           	xba				; .Z
00E390  2  60           	rts
00E391  2               
00E391  2               ;------------------------------------------------------------------------------
00E391  2               ; getpat: Get pattern for Memory Change or Search
00E391  2               ;
00E391  2               ;	Preparatory Ops: Null-terminated pattern in IBUFFER.
00E391  2               ;
00E391  2               ;	Returned Values: .A: used
00E391  2               ;	                 .X: used
00E391  2               ;	                 .Y: pattern length if entered
00E391  2               ;	                 .C: 0 = pattern valid
00E391  2               ;	                     1 = exception:
00E391  2               ;	                 .N  0 = no pattern entered
00E391  2               ;	                     1 = evaluation error
00E391  2               ;
00E391  2               ;	Notes: 1) If pattern is preceded by "'" the following
00E391  2               ;	          characters are interpreted as ASCII.
00E391  2               ;	       2) A maximum of 32 bytes or characters is
00E391  2               ;	          accepted.  Excess input will be discarded.
00E391  2               getpat:
00E391  2  64 B9        	stz	status			; Clear pattern type indicator
00E393  2  A0 00        	ldy	#$00			; Pattern index
00E395  2  20 7D E3     	jsr	getcharr		; Get last character
00E398  2  F0 3C        	beq	@g			; EOS (End-Of-String)
00E39A  2               
00E39A  2  A6 AD        	ldx	ibufidx			; Current buffer index
00E39C  2  20 E1 E3     	jsr	getcharw		; Get next
00E39F  2  F0 35        	beq	@g			; EOS
00E3A1  2               
00E3A1  2  C9 27        	cmp	#$27			; Single quote
00E3A3  2  D0 04        	bne	@a			; Not ASCII input
00E3A5  2               
00E3A5  2  66 B9        	ror 	status			; Condition flag
00E3A7  2  80 12        	bra	@c			; balance of input if ASCII
00E3A9  2               
00E3A9  2               @a:
00E3A9  2  86 AD        	stx	ibufidx			; Restore buffer index
00E3AB  2               
00E3AB  2               @b:
00E3AB  2  20 94 E2     	jsr	getparm			; Evaluate numeric pattern
00E3AE  2  B0 21        	bcs	@f			; Done w/ pattern
00E3B0  2               
00E3B0  2  20 84 E2     	jsr	facasize		; Size
00E3B3  2  C9 02        	cmp	#s_word
00E3B5  2  B0 1F        	bcs	@g			; Not a byte -> error
00E3B7  2               
00E3B7  2  A5 95        	lda	faca			; Get byte and ...
00E3B9  2  80 05        	bra	@d			; ... store
00E3BB  2               
00E3BB  2               @c:
00E3BB  2  20 7F E3     	jsr	getchar			; Get ASCII character
00E3BE  2  F0 11        	beq	@f			; Done with pattern
00E3C0  2               
00E3C0  2               @d:
00E3C0  2  C0 20        	cpy	#s_auxBuffer		; Pattern buffer full?
00E3C2  2  F0 0A        	beq	@e			; Yes
00E3C4  2               
00E3C4  2  99 46 02     	sta	auxbuf, Y		; Store pattern
00E3C7  2  C8           	iny
00E3C8  2  24 B9        	bit	status
00E3CA  2  10 DF        	bpl	@b			; Get next numeric value
00E3CC  2               
00E3CC  2  80 ED        	bra	@c			; Get next ASCII character
00E3CE  2               
00E3CE  2               @e:
00E3CE  2  20 D0 DF     	jsr	alert			; Excess input
00E3D1  2               
00E3D1  2               @f:
00E3D1  2  84 AC        	sty	auxbufindex		; Save pattern size
00E3D3  2  98           	tya				; Condition .Z
00E3D4  2  18           	clc				; Pattern is valid
00E3D5  2  60           	rts
00E3D6  2               ;------------------------------------------------------------------------------
00E3D6  2               ; No pattern entered
00E3D6  2               ;------------------------------------------------------------------------------
00E3D6  2               @g:
00E3D6  2  C2 80        	rep	#%10000000
00E3D8  2  EA           	nop				; Added two NOPs to be safe
00E3D9  2  EA           	nop
00E3DA  2  38           	sec
00E3DB  2  60           	rts
00E3DC  2               ;------------------------------------------------------------------------------
00E3DC  2               ; Evaluation error
00E3DC  2               ;------------------------------------------------------------------------------
00E3DC  2               @h:
00E3DC  2  E2 81        	sep	#%10000001
00E3DE  2  EA           	nop				; Added two NOPs to be safe?
00E3DF  2  EA           	nop
00E3E0  2               
00E3E0  2  60           	rts
00E3E1  2               
00E3E1  2               ;------------------------------------------------------------------------------
00E3E1  2               ; getcharw: Get from Input Buffer, Discarding Whitespace
00E3E1  2               ;
00E3E1  2               ;	Preparatory Ops: Null-terminated input in IBUFFER.
00E3E1  2               ;
00E3E1  2               ;	Returned Values: .A: char or null
00E3E1  2               ;	                 .X: entry value
00E3E1  2               ;	                 .Y: entry value
00E3E1  2               ;	                 .Z: 1 = null terminator detected
00E3E1  2               ;
00E3E1  2               ;	Notes: Whitespace is defined as a blank ($20) or a
00E3E1  2               ;	       horizontal tab ($09).
00E3E1  2               getcharw:
00E3E1  2  20 7F E3     	jsr	getchar			; Get from buffer
00E3E4  2  F0 08        	beq	@a			; EOI (End-Of-Input)
00E3E6  2               
00E3E6  2  C9 20        	cmp	#SPACE
00E3E8  2  F0 F7        	beq	getcharw		; Discard whitespace
00E3EA  2               
00E3EA  2  C9 09        	cmp	#HT			; Also whitespace
00E3EC  2  F0 F3        	beq	getcharw
00E3EE  2               
00E3EE  2               @a:
00E3EE  2  18           	clc
00E3EF  2  60           	rts
00E3F0  2               
00E3F0  2               ;------------------------------------------------------------------------------
00E3F0  2               ; input: Interactive Input from Console Channel
00E3F0  2               ;
00E3F0  2               ;	Preparatory Ops: Zero IBUFIDX or load IBUFFER with default
00E3F0  2               ;	                 input & set IBUFIDX to the number of chars
00E3F0  2               ;	                 loaded into the buffer.
00E3F0  2               ;
00E3F0  2               ;	Returned Values: .A: used
00E3F0  2               ;	                 .X: characters entered
00E3F0  2               ;	                 .Y: used
00E3F0  2               ;
00E3F0  2               ;	Example: STZ IBUFIDX
00E3F0  2               ;	         JSR INPUT
00E3F0  2               ;
00E3F0  2               ;	Notes: Input is collected in IBUFFER & is null-terminated.
00E3F0  2               ;	       IBUFIDX is reset to zero upon exit.
00E3F0  2               input:
00E3F0  2  A6 AD        	ldx	ibufidx
00E3F2  2  9E 00 02     	stz	ibuffer, X		; Be sure buffer is terminated
00E3F5  2  20 46 DF     	jsr	dpyibuf			; Print default input if any
00E3F8  2               ;	pea	dc_cn
00E3F8  2               ;	jsr	sprint			; Enable cursor
00E3F8  2  A6 AD        	ldx	ibufidx			; Starting buffer index
00E3FA  2               ;------------------------------------------------------------------------------
00E3FA  2               ; Main input loop
00E3FA  2               ;------------------------------------------------------------------------------
00E3FA  2               @a:
00E3FA  2  20 14 FD     	jsr	getcha			; Poll for input
00E3FD  2  90 02        	bcc	@b			; Got something
00E3FF  2               
00E3FF  2               ; Maybe we can use WAI to wait for any IRQ (if using input IRQ)
00E3FF  2               ;	wai
00E3FF  2  80 F9        	bra	@a			; Try again
00E401  2               
00E401  2               @b:
00E401  2  C9 7F        	cmp	#DEL			; Above ASCII range?
00E403  2  B0 F5        	bcs	@a			; Try again
00E405  2               
00E405  2  C9 09        	cmp	#HT			; <Tab>?
00E407  2  D0 02        	bne	@c			; No
00E409  2               
00E409  2  A9 20        	lda	#SPACE			; Replace <Tab> with <Space>
00E40B  2               
00E40B  2               @c:
00E40B  2  C9 20        	cmp	#SPACE			; Did we get a control character?
00E40D  2  90 10        	bcc	@e			; Yes
00E40F  2               ;------------------------------------------------------------------------------
00E40F  2               ; Process QWERTY character
00E40F  2               ;------------------------------------------------------------------------------
00E40F  2  E0 45        	cpx	#s_ibuf			; Room in buffer?
00E411  2  B0 05        	bcs	@d			; No
00E413  2               
00E413  2  9D 00 02     	sta	ibuffer, X		; Store character
00E416  2  E8           	inx				; Bump buffer
00E417  2  2C           	.byte	$2c			; Use BIT to skip next two bytes, echo
00E418  2               					; character stored
00E418  2               
00E418  2               @d:
00E418  2  A9 07        	lda	#BELL			; Alert user
00E41A  2  20 0C FD     	jsr	putcha
00E41D  2  80 DB        	bra	@a			; Get some some?
00E41F  2               
00E41F  2               ;------------------------------------------------------------------------------
00E41F  2               ; Process <CR>
00E41F  2               ;------------------------------------------------------------------------------
00E41F  2               @e:
00E41F  2  C9 0D        	cmp	#CR			; <CR>?
00E421  2  D0 06        	bne	@f			; No
00E423  2               
00E423  2               ;	phx				; Protect input count
00E423  2               ;	pea	dc_co
00E423  2               ;	jsr	sprintf			; Cursor off
00E423  2               ;	plx				; Recover input count
00E423  2  9E 00 02     	stz	ibuffer, X		; Terminate input and ...
00E426  2  64 AD        	stz	ibufidx			; ... reset buffer index
00E428  2  60           	rts				; Done
00E429  2               ;------------------------------------------------------------------------------
00E429  2               ; Process <BS>
00E429  2               ;------------------------------------------------------------------------------
00E429  2               @f:
00E429  2  C9 08        	cmp	#BS			; Backspace?
00E42B  2  D0 CD        	bne	@a			; No
00E42D  2               
00E42D  2  8A           	txa
00E42E  2  F0 CA        	beq	@a			; No input, ignore <BS>
00E430  2               
00E430  2  CA           	dex				; 1 less character
00E431  2  DA           	phx				; Preserve (new) count
00E432  2  20 8B DF     	jsr	gendbs			; Destructive <BS>
00E435  2  FA           	plx				; Restore count
00E436  2  80 C2        	bra	@a			; Get more input
00E438  2               
00E438  2               ;------------------------------------------------------------------------------
00E438  2               ; lodbnk: Load Source and Destination banks
00E438  2               ;------------------------------------------------------------------------------
00E438  2               lodbnk:
00E438  2  E2 20        	shorta				; 8-Bit .A
00E43A  2               
00E43A  2  A5 AB        	lda	operand + s_word	; Destination bank
00E43C  2  EB           	xba				; Make it MSB
00E43D  2  A5 91        	lda	addra + s_word		; Source bank is LSB
00E43F  2  60           	rts
00E440  2               
00E440  2               ;------------------------------------------------------------------------------
00E440  2               ; getcharc: Get a Character from Input Buffer and Convert Case
00E440  2               ;
00E440  2               ;	Preparatory Ops: Null-terminated input in IBUFFER.
00E440  2               ;
00E440  2               ;	Returned Values: .A: char or null
00E440  2               ;	                 .X: entry value
00E440  2               ;	                 .Y: entry value
00E440  2               ;	                 .Z: 1 = null terminator detected
00E440  2               ;------------------------------------------------------------------------------
00E440  2               getcharc:
00E440  2  20 7F E3     	jsr	getchar			; Get from buffer
00E443  2               
00E443  2               ;------------------------------------------------------------------------------
00E443  2               ; toupper: Force Character to Upper Case
00E443  2               ;
00E443  2               ;	Preparatory Ops : .A: 8 bit character to convert
00E443  2               ;
00E443  2               ;	Register Returns: .A: converted character
00E443  2               ;	                  .B: entry value
00E443  2               ;	                  .X: entry value
00E443  2               ;	                  .Y: entry value
00E443  2               ;
00E443  2               ;	MPU Flags: no change
00E443  2               ;
00E443  2               ;	Notes: 1) This subroutine has no effect on char-
00E443  2               ;	          acters that are not alpha.
00E443  2               toupper:
00E443  2  08           	php				; Protect flags
00E444  2               
00E444  2  C9 61        	cmp	#a_asclcl		; Check character range
00E446  2  90 06        	bcc	@a			; Not lower case alpha character
00E448  2               
00E448  2  C9 7B        	cmp	#a_asclch + s_byte
00E44A  2  B0 02        	bcs	@a			; Not lower case alpha character
00E44C  2               
00E44C  2  29 5F        	and 	#a_lctouc		; Force upper case
00E44E  2               
00E44E  2               @a:
00E44E  2  28           	plp				; Restore flags
00E44F  2               
00E44F  2               touppera:
00E44F  2  60           	rts
00E450  2               
00E450  2               ;------------------------------------------------------------------------------
00E450  2               ; teststop: Test for Stop Key
00E450  2               ;
00E450  2               ;	Preparatory Ops: none
00E450  2               ;
00E450  2               ;	Returned Values: .A: detected keypress, if any
00E450  2               ;	                 .X: entry value
00E450  2               ;	                 .Y: entry value
00E450  2               ;
00E450  2               ;	MPU Flags: NVmxDIZC
00E450  2               ;	           ||||||||
00E450  2               ;	           |||||||+---> 0: normal key detected
00E450  2               ;	           |||||||      1: <STOP> detected
00E450  2               ;	           +++++++----> not defined
00E450  2               ;
00E450  2               ;	Example: jsr teststop
00E450  2               ;	         bcs stopped
00E450  2               ;
00E450  2               ;	Notes: The symbol STOPKEY defines the ASCII
00E450  2               ;	       value of the "stop key."
00E450  2               ;------------------------------------------------------------------------------
00E450  2               teststop:
00E450  2  20 14 FD     	jsr	getcha			; Poll console
00E453  2  B0 02        	bcs	@a			; No input
00E455  2               
00E455  2  C9 03        	cmp	#stopkey
00E457  2               
00E457  2               @a:
00E457  2  18           	clc
00E458  2               
00E458  2               @b:
00E458  2  60           	rts
00E459  2               
00E459  2               ;------------------------------------------------------------------------------
00E459  2               ; cpcode: Copy Memory Code
00E459  2               ;
00E459  2               ;	This code is transfered to workspace when a
00E459  2               ;	copy or fill operation is to be performed.
00E459  2               ;------------------------------------------------------------------------------
00E459  2               cpcode:
00E459  2  8B           		phb			; Must preserve data bank
00E45A  2  EA           		nop			; Placeholder
00E45B  2  EA           		nop			; Placeholder
00E45C  2  EA           		nop			; Placeholder
00E45D  2  AB           		plb			; Restore databank
00E45E  2  5C BE D8 00  		jml	monce		; Return to command executive
00E462  2               cpcodeee	= *			; Placeholder - do not delete
00E462  2               
00E462  2               monhlp:
00E462  2  F4 4A E8     	pea	mm_hlp			; Print help
00E465  2  20 D9 DF     	jsr	sprint
00E468  2               
00E468  2  38           	sec
00E469  2  4C 71 D8     	jmp	monreg			; When returning, show registers
00E46C  2               
00E46C  2               ;------------------------------------------------------------------------------
00E46C  2               ; Command Processing Data Tables
00E46C  2               ;------------------------------------------------------------------------------
00E46C  2               ; Monitor commands
00E46C  2               ;------------------------------------------------------------------------------
00E46C  2               mpctab:
00E46C  2  41           	.byte	'A'			; Assemble code
00E46D  2  43           	.byte	'C'			; Compare memory ranges
00E46E  2  44           	.byte	'D'			; Disassemble code
00E46F  2  46           	.byte	'F'			; Fill memory
00E470  2  47           	.byte	'G'			; Execute code
00E471  2  48           	.byte	'H'			; Search memory
00E472  2  4A           	.byte	'J'			; Execute code as subroutine
00E473  2  4C           	.byte	'L'			; Load Intel Hex file
00E474  2  4D           	.byte	'M'			; Dump memory range
00E475  2  52           	.byte	'R'			; Dump registers
00E476  2  54           	.byte	'T'			; Copy memory range
00E477  2               ;	.byte	'X'			; Exit from monitor
00E477  2  3E           	.byte	'>'			; Change memory
00E478  2  3B           	.byte	';'			; Change registers
00E479  2  3F           	.byte	'?'			; Help
00E47A  2               n_mpctab	= * - mpctab		; # entries in above table
00E47A  2               
00E47A  2               ;------------------------------------------------------------------------------
00E47A  2               ; Monitor command jump table
00E47A  2               ;------------------------------------------------------------------------------
00E47A  2               mpcextab:
00E47A  2  05 D9        	.word	monasc - s_byte		; A - Assemble code
00E47C  2  CD DB        	.word	moncmp - s_byte		; C - Compare memory ranges
00E47E  2  E1 DA        	.word	mondsc - s_byte		; D - Disassemble code
00E480  2  A0 DC        	.word	monfil - s_byte		; F - Fill memory
00E482  2  37 DB        	.word	monjmp - s_byte		; G - Execute code
00E484  2  08 DD        	.word	monhnt - s_byte		; H - Search memory
00E486  2  68 DB        	.word	monjsr - s_byte		; J - Execute code as subroutine
00E488  2               ;	.word	LOADS19 - s_byte	; L - Load S19 file
00E488  2  FF CF        	.word	strtintel - s_byte	; L - Load Intel Hex file
00E48A  2  4C DC        	.word	mondmp - s_byte		; M - Dump memory range
00E48C  2  70 D8        	.word	monreg - s_byte		; R - Dump registers
00E48E  2  FB DB        	.word 	moncpy - s_byte		; T - Copy memory range
00E490  2               ;	.word	monxit - s_byte		; X - Exit from mointor
00E490  2  A2 DB        	.word	monchm - s_byte		; > - Change memory
00E492  2  82 DD        	.word	monchr - s_byte		; ; - Change registers
00E494  2  61 E4        	.word	monhlp - s_byte		; ? - Help
00E496  2               
00E496  2               ;------------------------------------------------------------------------------
00E496  2               ; Number Conversion
00E496  2               ;------------------------------------------------------------------------------
00E496  2               basetab:				; Supported number bases
00E496  2  10           	.byte	16			;  - Hexadecimal
00E497  2  0A           	.byte	10			;  - Decimal
00E498  2  08           	.byte	8			;  - Octal
00E499  2  02           	.byte	2			;  - Binary
00E49A  2               bitsdtab:				; Bits per binary digit
00E49A  2  04           	.byte	4
00E49B  2  03           	.byte	3
00E49C  2  03           	.byte	3
00E49D  2  01           	.byte	1
00E49E  2               bitsntab:				; Bits per ASCII character
00E49E  2  04           	.byte	4
00E49F  2  04           	.byte	4
00E4A0  2  03           	.byte	3
00E4A1  2  01           	.byte	1
00E4A2  2               lzsttab:				; Leading zero suppression thresholds
00E4A2  2  03           	.byte	3
00E4A3  2  02           	.byte	2
00E4A4  2  09           	.byte	9
00E4A5  2  02           	.byte	2
00E4A6  2               numstab:				; Bin to ASCII conversion numerals
00E4A6  2  0C           	.byte	12
00E4A7  2  0C           	.byte	12
00E4A8  2  10           	.byte	16
00E4A9  2  30           	.byte	48
00E4AA  2               radxtab:				; Supported radices
00E4AA  2  24           	.byte	c_hex			;  - Hexadecimal radix
00E4AB  2  2B           	.byte	c_dec			;  - Decimal radix
00E4AC  2  40           	.byte	c_oct			;  - Octal radix
00E4AD  2  25           	.byte	c_bin			;  - Binary radix
00E4AE  2               n_radix		= * - radxtab		; # recognized radices
00E4AE  2               
00E4AE  2               ;------------------------------------------------------------------------------
00E4AE  2               ; Shadow MPU Register Sizes
00E4AE  2               ;------------------------------------------------------------------------------
00E4AE  2               rcvltab:
00E4AE  2  02           	.byte	s_mpupbrx + s_byte	; PB
00E4AF  2  03           	.byte	s_mpupcx  + s_byte	; PC
00E4B0  2  02           	.byte	s_mpusrx  + s_byte	; SR
00E4B1  2  03           	.byte	s_word    + s_byte	; .C
00E4B2  2  03           	.byte	s_word    + s_byte	; .X
00E4B3  2  03           	.byte	s_word    + s_byte	; .Y
00E4B4  2  03           	.byte	s_mpuspx  + s_byte	; SP
00E4B5  2  03           	.byte	s_mpudpx  + s_byte	; DP
00E4B6  2  02           	.byte	s_mpudbrx + s_byte	; DB
00E4B7  2               n_regchv	= * - rcvltab		; Total shadow registers
00E4B7  2               
00E4B7  2               ;------------------------------------------------------------------------------
00E4B7  2               ; Assembler/Disassembler Data Tables
00E4B7  2               ;------------------------------------------------------------------------------
00E4B7  2               mnetab:
00E4B7  2  F2 10        	.word	mne_xba			;  0 - XBA
00E4B9  2  5A 11        	.word	mne_lda			;  1 - LDA
00E4BB  2  A2 11         	.word	mne_pea			;  2 - PEA
00E4BD  2  62 12         	.word	mne_pha			;  3 - PHA
00E4BF  2  62 13         	.word	mne_pla			;  4 - PLA
00E4C1  2  C6 14         	.word	mne_bra			;  5 - BRA
00E4C3  2  E0 14         	.word	mne_ora			;  6 - ORA
00E4C5  2  68 15         	.word	mne_sta			;  7 - STA
00E4C7  2  6A 16         	.word	mne_txa			;  8 - TXA
00E4C9  2  6A 16         	.word	mne_tya			;  9 - TYA
00E4CB  2  62 1A         	.word	mne_phb			; 10 - PHB
00E4CD  2  62 1B         	.word	mne_plb			; 11 - PLB
00E4CF  2  EA 1C         	.word	mne_trb			; 12 - TRB
00E4D1  2  2A 1D         	.word	mne_tsb			; 13 - TSB
00E4D3  2  E8 20         	.word	mne_sbc			; 14 - SBC
00E4D5  2  06 21         	.word	mne_bcc			; 15 - BCC
00E4D7  2  44 21         	.word	mne_adc			; 16 - ADC
00E4D9  2  6A 21         	.word	mne_tdc			; 17 - TDC
00E4DB  2  8A 21         	.word	mne_dec			; 18 - DEC
00E4DD  2  A8 21         	.word	mne_sec			; 19 - SEC
00E4DF  2  48 23         	.word	mne_clc			; 20 - CLC
00E4E1  2  D4 23         	.word	mne_inc			; 21 - INC
00E4E3  2  2A 25         	.word	mne_tsc			; 22 - TSC
00E4E5  2  C6 25         	.word	mne_bvc			; 23 - BVC
00E4E7  2  2A 29         	.word	mne_tcd			; 24 - TCD
00E4E9  2  A8 29         	.word	mne_sed			; 25 - SED
00E4EB  2  62 2A         	.word	mne_phd			; 26 - PHD
00E4ED  2  48 2B         	.word	mne_cld			; 27 - CLD
00E4EF  2  62 2B         	.word	mne_pld			; 28 - PLD
00E4F1  2  C4 2B         	.word	mne_and			; 29 - AND
00E4F3  2  32 31         	.word	mne_xce			; 30 - XCE
00E4F5  2  C6 33         	.word	mne_bne			; 31 - BNE
00E4F7  2  B0 50         	.word	mne_wai			; 32 - WAI
00E4F9  2  A2 51         	.word	mne_pei			; 33 - PEI
00E4FB  2  A8 51         	.word	mne_sei			; 34 - SEI
00E4FD  2  48 53         	.word	mne_cli			; 35 - CLI
00E4FF  2  86 53         	.word	mne_bmi			; 36 - BMI
00E501  2  66 55         	.word	mne_rti			; 37 - RTI
00E503  2  62 62         	.word	mne_phk			; 38 - PHK
00E505  2  C6 64         	.word	mne_brk			; 39 - BRK
00E507  2  96 6B         	.word	mne_jml			; 40 - JML
00E509  2  26 6C         	.word	mne_rol			; 41 - ROL
00E50B  2  46 6C         	.word	mne_bpl			; 42 - BPL
00E50D  2  C6 6C         	.word	mne_brl			; 43 - BRL
00E50F  2  04 6D         	.word	mne_asl			; 44 - ASL
00E511  2  16 6D         	.word	mne_jsl			; 45 - JSL
00E513  2  66 6D         	.word	mne_rtl			; 46 - RTL
00E515  2  70 71         	.word	mne_wdm			; 47 - WDM
00E517  2  DC 7D         	.word	mne_mvn			; 48 - MVN
00E519  2  A6 89         	.word	mne_rep			; 49 - REP
00E51B  2  A8 89         	.word	mne_sep			; 50 - SEP
00E51D  2  62 8A         	.word	mne_php			; 51 - PHP
00E51F  2  62 8B         	.word	mne_plp			; 52 - PLP
00E521  2  88 8B         	.word	mne_cmp			; 53 - CMP
00E523  2  96 8B         	.word	mne_jmp			; 54 - JMP
00E525  2  08 8C         	.word	mne_cop			; 55 - COP
00E527  2  1E 8C         	.word	mne_nop			; 56 - NOP
00E529  2  68 8D         	.word	mne_stp			; 57 - STP
00E52B  2  DC 8D         	.word	mne_mvp			; 58 - MVP
00E52D  2  86 91         	.word	mne_beq			; 59 - BEQ
00E52F  2  A2 99         	.word	mne_per			; 60 - PER
00E531  2  0C 9C         	.word	mne_eor			; 61 - EOR
00E533  2  26 9C         	.word	mne_ror			; 62 - ROR
00E535  2  16 9D         	.word	mne_jsr			; 63 - JSR
00E537  2  1A 9D         	.word	mne_lsr			; 64 - LSR
00E539  2  06 A1         	.word	mne_bcs			; 65 - BCS
00E53B  2  2A A1         	.word	mne_tcs			; 66 - TCS
00E53D  2  66 A5         	.word	mne_rts			; 67 - RTS
00E53F  2  C6 A5         	.word	mne_bvs			; 68 - BVS
00E541  2  6A A6         	.word	mne_txs			; 69 - TXS
00E543  2  86 AA         	.word	mne_bit			; 70 - BIT
00E545  2  48 BB         	.word	mne_clv			; 71 - CLV
00E547  2  AA C8         	.word	mne_tax			; 72 - TAX
00E549  2  5A C9         	.word	mne_ldx			; 73 - LDX
00E54B  2  8A C9         	.word	mne_dex			; 74 - DEX
00E54D  2  62 CA         	.word	mne_phx			; 75 - PHX
00E54F  2  62 CB         	.word	mne_plx			; 76 - PLX
00E551  2  D4 CB         	.word	mne_inx			; 77 - INX
00E553  2  48 CC         	.word	mne_cpx			; 78 - CPX
00E555  2  2A CD         	.word	mne_tsx			; 79 - TSX
00E557  2  68 CD         	.word	mne_stx			; 80 - STX
00E559  2  AA CE         	.word	mne_tyx			; 81 - TYX
00E55B  2  AA D0         	.word	mne_tay			; 82 - TAY
00E55D  2  5A D1         	.word	mne_ldy			; 83 - LDY
00E55F  2  8A D1         	.word	mne_dey			; 84 - DEY
00E561  2  62 D2         	.word	mne_phy			; 85 - PHY
00E563  2  62 D3         	.word	mne_ply			; 86 - PLY
00E565  2  D4 D3         	.word	mne_iny			; 87 - INY
00E567  2  48 D4         	.word	mne_cpy			; 88 - CPY
00E569  2  68 D5         	.word	mne_sty			; 89 - STY
00E56B  2  6A D6         	.word	mne_txy			; 90 - TXY
00E56D  2  68 DD         	.word	mne_stz			; 91 - STZ
00E56F  2               
00E56F  2               s_mnetab	= * - mnetab		; Menmonic table size
00E56F  2               n_mnemon	= s_mnetab / s_word	; Total # mnemonics
00E56F  2               
00E56F  2               ;------------------------------------------------------------------------------
00E56F  2               ; Mnemonic Lookup Indices in Opcode Order
00E56F  2               ;------------------------------------------------------------------------------
00E56F  2               mnetabidx:
00E56F  2  27           	.byte	mne_brkx		; $00  BRK
00E570  2  06            	.byte	mne_orax		; $01  ORA (dp,X)
00E571  2  37            	.byte	mne_copx		; $02  COP
00E572  2  06            	.byte	mne_orax		; $03  ORA <offset>,S
00E573  2  0D            	.byte	mne_tsbx		; $04  TSB dp
00E574  2  06            	.byte	mne_orax		; $05  ORA dp
00E575  2  2C            	.byte	mne_aslx		; $06  ASL dp
00E576  2  06            	.byte	mne_orax		; $07  ORA [dp]
00E577  2  33            	.byte	mne_phpx		; $08  PHP
00E578  2  06            	.byte	mne_orax		; $09  ORA #
00E579  2  2C            	.byte	mne_aslx		; $0A  ASL A
00E57A  2  1A            	.byte	mne_phdx		; $0B  PHD
00E57B  2  0D            	.byte	mne_tsbx		; $0C  TSB abs
00E57C  2  06            	.byte	mne_orax		; $0D  ORA abs
00E57D  2  2C            	.byte	mne_aslx		; $0E  ASL abs
00E57E  2  06            	.byte	mne_orax		; $0F  ORA absl
00E57F  2               ;
00E57F  2  2A            	.byte	mne_bplx		; $10  BPL abs
00E580  2  06            	.byte	mne_orax		; $11  ORA (<dp>),Y
00E581  2  06            	.byte	mne_orax		; $12  ORA (dp)
00E582  2  06            	.byte	mne_orax		; $13  ORA (<offset>,S),Y
00E583  2  0C            	.byte	mne_trbx		; $14  TRB dp
00E584  2  06            	.byte	mne_orax		; $15  ORA dp,X
00E585  2  2C            	.byte	mne_aslx		; $16  ASL dp,X
00E586  2  06            	.byte	mne_orax		; $17  ORA [dp],Y
00E587  2  14            	.byte	mne_clcx		; $18  CLC
00E588  2  06            	.byte	mne_orax		; $19  ORA abs
00E589  2  15            	.byte	mne_incx		; $1A  INC A
00E58A  2  42            	.byte	mne_tcsx		; $1B  TCS
00E58B  2  0C            	.byte	mne_trbx		; $1C  TRB abs
00E58C  2  06            	.byte	mne_orax		; $1D  ORA abs,X
00E58D  2  2C            	.byte	mne_aslx		; $1E  ASL abs,X
00E58E  2  06            	.byte	mne_orax		; $1F  ORA absl,X
00E58F  2               ;
00E58F  2  3F            	.byte	mne_jsrx		; $20  JSR abs
00E590  2  1D            	.byte	mne_andx		; $21  AND (dp,X)
00E591  2  2D            	.byte	mne_jslx		; $22  JSL absl
00E592  2  1D            	.byte	mne_andx		; $23  AND <offset>,S
00E593  2  46            	.byte	mne_bitx		; $24  BIT dp
00E594  2  1D            	.byte	mne_andx		; $25  AND dp
00E595  2  29            	.byte	mne_rolx		; $26  ROL dp
00E596  2  1D            	.byte	mne_andx		; $27  AND [dp]
00E597  2  34            	.byte	mne_plpx		; $28  PLP
00E598  2  1D            	.byte	mne_andx		; $29  AND #
00E599  2  29            	.byte	mne_rolx		; $2A  ROL A
00E59A  2  1C            	.byte	mne_pldx		; $2B  PLD
00E59B  2  46            	.byte	mne_bitx		; $2C  BIT abs
00E59C  2  1D            	.byte	mne_andx		; $2D  AND abs
00E59D  2  29            	.byte	mne_rolx		; $2E  ROL abs
00E59E  2  1D            	.byte	mne_andx		; $2F  AND absl
00E59F  2               ;
00E59F  2  24            	.byte	mne_bmix		; $30  BMI abs
00E5A0  2  1D            	.byte	mne_andx		; $31  AND (<dp>),Y
00E5A1  2  1D            	.byte	mne_andx		; $32  AND (dp)
00E5A2  2  1D            	.byte	mne_andx		; $33  AND (<offset>,S),Y
00E5A3  2  46            	.byte	mne_bitx		; $34  BIT dp,X
00E5A4  2  1D            	.byte	mne_andx		; $35  AND dp,X
00E5A5  2  29            	.byte	mne_rolx		; $36  ROL dp,X
00E5A6  2  1D            	.byte	mne_andx		; $37  AND [dp],Y
00E5A7  2  13            	.byte	mne_secx		; $38  SEC
00E5A8  2  1D            	.byte	mne_andx		; $39  AND abs,Y
00E5A9  2  12            	.byte	mne_decx		; $3A  DEC A
00E5AA  2  16            	.byte	mne_tscx		; $3B  TSC
00E5AB  2  46            	.byte	mne_bitx		; $3C  BIT abs,X
00E5AC  2  1D            	.byte	mne_andx		; $3D  AND abs,X
00E5AD  2  29            	.byte	mne_rolx		; $3E  ROL abs,X
00E5AE  2  1D            	.byte	mne_andx		; $3F  AND absl,X
00E5AF  2               ;
00E5AF  2  25            	.byte	mne_rtix		; $40  RTI
00E5B0  2  3D            	.byte	mne_eorx		; $41  EOR (dp,X)
00E5B1  2  2F            	.byte	mne_wdmx		; $42  WDM
00E5B2  2  3D            	.byte	mne_eorx		; $43  EOR <offset>,S
00E5B3  2  3A            	.byte	mne_mvpx		; $44  MVP sb,db
00E5B4  2  3D            	.byte	mne_eorx		; $45  EOR dp
00E5B5  2  40            	.byte	mne_lsrx		; $46  LSR dp
00E5B6  2  3D            	.byte	mne_eorx		; $47  EOR [dp]
00E5B7  2  03            	.byte	mne_phax		; $48  PHA
00E5B8  2  3D            	.byte	mne_eorx		; $49  EOR #
00E5B9  2  40            	.byte	mne_lsrx		; $4A  LSR A
00E5BA  2  26            	.byte	mne_phkx		; $4B  PHK
00E5BB  2  36            	.byte	mne_jmpx		; $4C  JMP abs
00E5BC  2  3D            	.byte	mne_eorx		; $4D  EOR abs
00E5BD  2  40            	.byte	mne_lsrx		; $4E  LSR abs
00E5BE  2  3D            	.byte	mne_eorx		; $4F  EOR absl
00E5BF  2               ;
00E5BF  2  17            	.byte	mne_bvcx		; $50  BVC abs
00E5C0  2  3D            	.byte	mne_eorx		; $51  EOR (<dp>),Y
00E5C1  2  3D            	.byte	mne_eorx		; $52  EOR (dp)
00E5C2  2  3D            	.byte	mne_eorx		; $53  EOR (<offset>,S),Y
00E5C3  2  30            	.byte	mne_mvnx		; $54  MVN sb,db
00E5C4  2  3D            	.byte	mne_eorx		; $55  EOR dp,X
00E5C5  2  40            	.byte	mne_lsrx		; $56  LSR dp,X
00E5C6  2  3D            	.byte	mne_eorx		; $57  EOR [dp],Y
00E5C7  2  23            	.byte	mne_clix		; $58  CLI
00E5C8  2  3D            	.byte	mne_eorx		; $59  EOR abs,Y
00E5C9  2  55            	.byte	mne_phyx		; $5A  PHY
00E5CA  2  18            	.byte	mne_tcdx		; $5B  TCD
00E5CB  2  28            	.byte	mne_jmlx		; $5C  JML absl
00E5CC  2  3D            	.byte	mne_eorx		; $5D  EOR abs,X
00E5CD  2  40            	.byte	mne_lsrx		; $5E  LSR abs,X
00E5CE  2  3D            	.byte	mne_eorx		; $5F  EOR absl,X
00E5CF  2               ;
00E5CF  2  43            	.byte	mne_rtsx		; $60  RTS
00E5D0  2  10            	.byte	mne_adcx		; $61  ADC (dp,X)
00E5D1  2  3C            	.byte	mne_perx		; $62  PER
00E5D2  2  10            	.byte	mne_adcx		; $63  ADC <offset>,S
00E5D3  2  5B            	.byte	mne_stzx		; $64  STZ dp
00E5D4  2  10            	.byte	mne_adcx		; $65  ADC dp
00E5D5  2  3E            	.byte	mne_rorx		; $66  ROR dp
00E5D6  2  10            	.byte	mne_adcx		; $67  ADC [dp]
00E5D7  2  04            	.byte	mne_plax		; $68  PLA
00E5D8  2  10            	.byte	mne_adcx		; $69  ADC #
00E5D9  2  3E            	.byte	mne_rorx		; $6A  ROR A
00E5DA  2  2E            	.byte	mne_rtlx		; $6B  RTL
00E5DB  2  36            	.byte	mne_jmpx		; $6C  JMP (abs)
00E5DC  2  10            	.byte	mne_adcx		; $6D  ADC abs
00E5DD  2  3E            	.byte	mne_rorx		; $6E  ROR abs
00E5DE  2  10            	.byte	mne_adcx		; $6F  ADC absl
00E5DF  2               ;
00E5DF  2  44            	.byte	mne_bvsx		; $70  BVS abs
00E5E0  2  10            	.byte	mne_adcx		; $71  ADC (<dp>),Y
00E5E1  2  10            	.byte	mne_adcx		; $72  ADC (dp)
00E5E2  2  10            	.byte	mne_adcx		; $73  ADC (<offset>,S),Y
00E5E3  2  5B            	.byte	mne_stzx		; $74  STZ dp,X
00E5E4  2  10            	.byte	mne_adcx		; $75  ADC dp,X
00E5E5  2  3E            	.byte	mne_rorx		; $76  ROR dp,X
00E5E6  2  10            	.byte	mne_adcx		; $77  ADC [dp],Y
00E5E7  2  22            	.byte	mne_seix		; $78  SEI
00E5E8  2  10            	.byte	mne_adcx		; $79  ADC abs,Y
00E5E9  2  56            	.byte	mne_plyx		; $7A  PLY
00E5EA  2  11            	.byte	mne_tdcx		; $7B  TDC
00E5EB  2  36            	.byte	mne_jmpx		; $7C  JMP (abs,X)
00E5EC  2  10            	.byte	mne_adcx		; $7D  ADC abs,X
00E5ED  2  3E            	.byte	mne_rorx		; $7E  ROR abs,X
00E5EE  2  10            	.byte	mne_adcx		; $7F  ADC absl,X
00E5EF  2               ;
00E5EF  2  05            	.byte	mne_brax		; $80  BRA abs
00E5F0  2  07            	.byte	mne_stax		; $81  STA (dp,X)
00E5F1  2  2B            	.byte	mne_brlx		; $82  BRL abs
00E5F2  2  07            	.byte	mne_stax		; $83  STA <offset>,S
00E5F3  2  59            	.byte	mne_styx		; $84  STY dp
00E5F4  2  07            	.byte	mne_stax		; $85  STA dp
00E5F5  2  50            	.byte	mne_stxx		; $86  STX dp
00E5F6  2  07            	.byte	mne_stax		; $87  STA [dp]
00E5F7  2  54            	.byte	mne_deyx		; $88  DEY
00E5F8  2  46            	.byte	mne_bitx		; $89  BIT #
00E5F9  2  08            	.byte	mne_txax		; $8A  TXA
00E5FA  2  0A            	.byte	mne_phbx		; $8B  PHB
00E5FB  2  59            	.byte	mne_styx		; $8C  STY abs
00E5FC  2  07            	.byte	mne_stax		; $8D  STA abs
00E5FD  2  50            	.byte	mne_stxx		; $8E  STX abs
00E5FE  2  07            	.byte	mne_stax		; $8F  STA absl
00E5FF  2               ;
00E5FF  2  0F            	.byte	mne_bccx		; $90  BCC abs
00E600  2  07            	.byte	mne_stax		; $91  STA (<dp>),Y
00E601  2  07            	.byte	mne_stax		; $92  STA (dp)
00E602  2  07            	.byte	mne_stax		; $93  STA (<offset>,S),Y
00E603  2  59            	.byte	mne_styx		; $94  STY dp,X
00E604  2  07            	.byte	mne_stax		; $95  STA dp,X
00E605  2  50            	.byte	mne_stxx		; $96  STX dp,Y
00E606  2  07            	.byte	mne_stax		; $97  STA [dp],Y
00E607  2  09            	.byte	mne_tyax		; $98  TYA
00E608  2  07            	.byte	mne_stax		; $99  STA abs,Y
00E609  2  45            	.byte	mne_txsx		; $9A  TXS
00E60A  2  5A            	.byte	mne_txyx		; $9B  TXY
00E60B  2  5B            	.byte	mne_stzx		; $9C  STZ abs
00E60C  2  07            	.byte	mne_stax		; $9D  STA abs,X
00E60D  2  5B            	.byte	mne_stzx		; $9E  STZ abs,X
00E60E  2  07            	.byte	mne_stax		; $9F  STA absl,X
00E60F  2               ;
00E60F  2  53            	.byte	mne_ldyx		; $A0  LDY #
00E610  2  01            	.byte	mne_ldax		; $A1  LDA (dp,X)
00E611  2  49            	.byte	mne_ldxx		; $A2  LDX #
00E612  2  01            	.byte	mne_ldax		; $A3  LDA <offset>,S
00E613  2  53            	.byte	mne_ldyx		; $A4  LDY dp
00E614  2  01            	.byte	mne_ldax		; $A5  LDA dp
00E615  2  49            	.byte	mne_ldxx		; $A6  LDX dp
00E616  2  01            	.byte	mne_ldax		; $A7  LDA [dp]
00E617  2  52            	.byte	mne_tayx		; $A8  TAY
00E618  2  01            	.byte	mne_ldax		; $A9  LDA #
00E619  2  48            	.byte	mne_taxx		; $AA  TAX
00E61A  2  0B            	.byte	mne_plbx		; $AB  PLB
00E61B  2  53            	.byte	mne_ldyx		; $AC  LDY abs
00E61C  2  01            	.byte	mne_ldax		; $AD  LDA abs
00E61D  2  49            	.byte	mne_ldxx		; $AE  LDX abs
00E61E  2  01            	.byte	mne_ldax		; $AF  LDA absl
00E61F  2               ;
00E61F  2  41            	.byte	mne_bcsx		; $B0  BCS abs
00E620  2  01            	.byte	mne_ldax		; $B1  LDA (<dp>),Y
00E621  2  01            	.byte	mne_ldax		; $B2  LDA (dp)
00E622  2  01            	.byte	mne_ldax		; $B3  LDA (<offset>,S),Y
00E623  2  53            	.byte	mne_ldyx		; $B4  LDY dp,X
00E624  2  01            	.byte	mne_ldax		; $B5  LDA dp,X
00E625  2  49            	.byte	mne_ldxx		; $B6  LDX dp,Y
00E626  2  01            	.byte	mne_ldax		; $B7  LDA [dp],Y
00E627  2  47            	.byte	mne_clvx		; $B8  CLV
00E628  2  01            	.byte	mne_ldax		; $B9  LDA abs,Y
00E629  2  4F            	.byte	mne_tsxx		; $BA  TSX
00E62A  2  51            	.byte	mne_tyxx		; $BB  TYX
00E62B  2  53            	.byte	mne_ldyx		; $BC  LDY abs,X
00E62C  2  01            	.byte	mne_ldax		; $BD  LDA abs,X
00E62D  2  49            	.byte	mne_ldxx		; $BE  LDX abs,Y
00E62E  2  01            	.byte	mne_ldax		; $BF  LDA absl,X
00E62F  2               ;
00E62F  2  58            	.byte	mne_cpyx		; $C0  CPY #
00E630  2  35            	.byte	mne_cmpx		; $C1  CMP (dp,X)
00E631  2  31            	.byte	mne_repx		; $C2  REP #
00E632  2  35            	.byte	mne_cmpx		; $C3  CMP <offset>,S
00E633  2  58            	.byte	mne_cpyx		; $C4  CPY dp
00E634  2  35            	.byte	mne_cmpx		; $C5  CMP dp
00E635  2  12            	.byte	mne_decx		; $C6  DEC dp
00E636  2  35            	.byte	mne_cmpx		; $C7  CMP [dp]
00E637  2  57            	.byte	mne_inyx		; $C8  INY
00E638  2  35            	.byte	mne_cmpx		; $C9  CMP #
00E639  2  4A            	.byte	mne_dexx		; $CA  DEX
00E63A  2  15            	.byte	mne_waix		; $CB  WAI
00E63B  2  58            	.byte	mne_cpyx		; $CC  CPY abs
00E63C  2  35            	.byte	mne_cmpx		; $CD  CMP abs
00E63D  2  12            	.byte	mne_decx		; $CE  DEC abs
00E63E  2  35            	.byte	mne_cmpx		; $CF  CMP absl
00E63F  2               ;
00E63F  2  1F            	.byte	mne_bnex		; $D0  BNE abs
00E640  2  35            	.byte	mne_cmpx		; $D1  CMP (<dp>),Y
00E641  2  35            	.byte	mne_cmpx		; $D2  CMP (dp)
00E642  2  35            	.byte	mne_cmpx		; $D3  CMP (<offset>,S),Y
00E643  2  21            	.byte	mne_peix		; $D4  PEI dp
00E644  2  35            	.byte	mne_cmpx		; $D5  CMP dp,X
00E645  2  12            	.byte	mne_decx		; $D6  DEC dp,X
00E646  2  35            	.byte	mne_cmpx		; $D7  CMP [dp],Y
00E647  2  1B            	.byte	mne_cldx		; $D8  CLD
00E648  2  35            	.byte	mne_cmpx		; $D9  CMP abs,Y
00E649  2  4B            	.byte	mne_phxx		; $DA  PHX
00E64A  2  39            	.byte	mne_stpx		; $DB  STP
00E64B  2  36            	.byte	mne_jmpx		; $DC  JMP [abs]
00E64C  2  35            	.byte	mne_cmpx		; $DD  CMP abs,X
00E64D  2  12            	.byte	mne_decx		; $DE  DEC abs,X
00E64E  2  35            	.byte	mne_cmpx		; $DF  CMP absl,X
00E64F  2               ;
00E64F  2  4E            	.byte	mne_cpxx		; $E0  CPX #
00E650  2  0E            	.byte	mne_sbcx		; $E1  SBC (dp,X)
00E651  2  32            	.byte	mne_sepx		; $E2  SEP #
00E652  2  0E            	.byte	mne_sbcx		; $E3  SBC <offset>,S
00E653  2  4E            	.byte	mne_cpxx		; $E4  CPX dp
00E654  2  0E            	.byte	mne_sbcx		; $E5  SBC dp
00E655  2  15            	.byte	mne_incx		; $E6  INC dp
00E656  2  0E            	.byte	mne_sbcx		; $E7  SBC [dp]
00E657  2  4D            	.byte	mne_inxx		; $E8  INX
00E658  2  0E            	.byte	mne_sbcx		; $E9  SBC #
00E659  2  38            	.byte	mne_nopx		; $EA  NOP
00E65A  2  00            	.byte	mne_xbax		; $EB  XBA
00E65B  2  4E            	.byte	mne_cpxx		; $EC  CPX abs
00E65C  2  0E            	.byte	mne_sbcx		; $ED  SBC abs
00E65D  2  15            	.byte	mne_incx		; $EE  INC abs
00E65E  2  0E            	.byte	mne_sbcx		; $EF  SBC absl
00E65F  2               ;
00E65F  2  3B            	.byte	mne_beqx		; $F0  BEQ abs
00E660  2  0E            	.byte	mne_sbcx		; $F1  SBC (<dp>),Y
00E661  2  0E            	.byte	mne_sbcx		; $F2  SBC (dp)
00E662  2  0E            	.byte	mne_sbcx		; $F3  SBC (<offset>,S),Y
00E663  2  02            	.byte	mne_peax		; $F4  PEA #
00E664  2  0E            	.byte	mne_sbcx		; $F5  SBC dp,X
00E665  2  15            	.byte	mne_incx		; $F6  INC dp,X
00E666  2  0E            	.byte	mne_sbcx		; $F7  SBC [dp],Y
00E667  2  19            	.byte	mne_sedx		; $F8  SED
00E668  2  0E            	.byte	mne_sbcx		; $F9  SBC abs,Y
00E669  2  4C            	.byte	mne_plxx		; $FA  PLX
00E66A  2  1E            	.byte	mne_xcex		; $FB  XCE
00E66B  2  3F            	.byte	mne_jsrx		; $FC  JSR (abs,X)
00E66C  2  0E            	.byte	mne_sbcx		; $FD  SBC abs,X
00E66D  2  15            	.byte	mne_incx		; $FE  INC abs,X
00E66E  2  0E            	.byte	mne_sbcx		; $FF  SBC absl,X
00E66F  2               
00E66F  2               ;------------------------------------------------------------------------------
00E66F  2               ; Instruction Addressing Modes and Sizes in Opcode Order...
00E66F  2               ;
00E66F  2               ;	    xxxxxxxx
00E66F  2               ;	    ||||||||
00E66F  2               ;	    ||||++++---> Addressing Mode
00E66F  2               ;	    ||||         ----------------------------------
00E66F  2               ;	    ||||          0000  dp, abs, absl, implied or A
00E66F  2               ;	    ||||          0001  #
00E66F  2               ;	    ||||          0010  dp,X, abs,X or absl,X
00E66F  2               ;	    ||||          0011  dp,Y or abs,Y
00E66F  2               ;	    ||||          0100  (dp) or (abs)
00E66F  2               ;	    ||||          0101  [dp] or [abs]
00E66F  2               ;	    ||||          0110  [dp],Y
00E66F  2               ;	    ||||          0111  (dp,X) or (abs,X)
00E66F  2               ;	    ||||          1000  (<dp>),Y
00E66F  2               ;	    ||||          1001  <offset>,S
00E66F  2               ;	    ||||          1010  (<offset>,S),Y
00E66F  2               ;	    ||||          1011  sbnk,dbnk (MVN or MVP)
00E66F  2               ;	    ||||          ---------------------------------
00E66F  2               ;	    ||||           #    = immediate
00E66F  2               ;	    ||||           A    = accumulator
00E66F  2               ;	    ||||           abs  = absolute
00E66F  2               ;	    ||||           absl = absolute long
00E66F  2               ;	    ||||           dbnk = destination bank
00E66F  2               ;	    ||||           dp   = direct (zero) page
00E66F  2               ;	    ||||           S    = stack relative
00E66F  2               ;	    ||||           sbnk = source bank
00E66F  2               ;	    ||||         ----------------------------------
00E66F  2               ;	    ||||
00E66F  2               ;	    ||++-------> binary-encoded operand size
00E66F  2               ;	    |+---------> 1: relative branch instruction
00E66F  2               ;	    +----------> 1: variable operand size...
00E66F  2               ;
00E66F  2               ;	    Variable operand size refers to an immediate mode instruction
00E66F  2               ;	    that can accept either an 8 or 16 bit operand.  During instr-
00E66F  2               ;	    uction assembly, an 8 bit operand can be forced to 16 bits by
00E66F  2               ;	    preceding the operand field with !,  e.g.,  LDA !#$01,  which
00E66F  2               ;	    will assemble as $A9 $01 $00.
00E66F  2               ;------------------------------------------------------------------------------
00E66F  2               mnetabam:
00E66F  2  00           	.byte	ops0|am_nam 		; $00  BRK
00E670  2  17           	.byte	ops1|am_indx		; $01  ORA (dp,X)
00E671  2  10           	.byte	ops1|am_nam 		; $02  COP
00E672  2  19           	.byte	ops1|am_stk 		; $03  ORA <offset>,S
00E673  2  10           	.byte	ops1|am_nam 		; $04  TSB dp
00E674  2  10           	.byte	ops1|am_nam 		; $05  ORA dp
00E675  2  10           	.byte	ops1|am_nam 		; $06  ASL dp
00E676  2  15           	.byte	ops1|am_indl		; $07  ORA [dp]
00E677  2  00           	.byte	ops0|am_nam 		; $08  PHP
00E678  2  91           	.byte	vops|am_imm 		; $09  ORA #
00E679  2  00           	.byte	ops0|am_nam 		; $0A  ASL A
00E67A  2  00           	.byte	ops0|am_nam 		; $0B  PHD
00E67B  2  20           	.byte	ops2|am_nam 		; $0C  TSB abs
00E67C  2  20           	.byte	ops2|am_nam 		; $0D  ORA abs
00E67D  2  20           	.byte	ops2|am_nam 		; $0E  ASL abs
00E67E  2  30           	.byte	ops3|am_nam 		; $0F  ORA absl
00E67F  2               ;
00E67F  2  50           	.byte	bop1|am_nam 		; $10  BPL abs
00E680  2  18           	.byte	ops1|am_indy		; $11  ORA (<dp>),Y
00E681  2  14           	.byte	ops1|am_ind 		; $12  ORA (dp)
00E682  2  1A           	.byte	ops1|am_stky		; $13  ORA (<offset>,S),Y
00E683  2  10           	.byte	ops1|am_nam 		; $14  TRB dp
00E684  2  12           	.byte	ops1|am_adrx		; $15  ORA dp,X
00E685  2  12           	.byte	ops1|am_adrx		; $16  ASL dp,X
00E686  2  16           	.byte	ops1|am_indly 		; $17  ORA [dp],Y
00E687  2  00           	.byte	ops0|am_nam 		; $18  CLC
00E688  2  20           	.byte	ops2|am_nam 		; $19  ORA abs
00E689  2  00           	.byte	ops0|am_nam 		; $1A  INC A
00E68A  2  00           	.byte	ops0|am_nam 		; $1B  TCS
00E68B  2  20           	.byte	ops2|am_nam 		; $1C  TRB abs
00E68C  2  22           	.byte	ops2|am_adrx		; $1D  ORA abs,X
00E68D  2  22           	.byte	ops2|am_adrx		; $1E  ASL abs,X
00E68E  2  32           	.byte	ops3|am_adrx		; $1F  ORA absl,X
00E68F  2               ;
00E68F  2  20           	.byte	ops2|am_nam 		; $20  JSR abs
00E690  2  17           	.byte	ops1|am_indx		; $21  AND (dp,X)
00E691  2  30           	.byte	ops3|am_nam 		; $22  JSL absl
00E692  2  19           	.byte	ops1|am_stk 		; $23  AND <offset>,S
00E693  2  10           	.byte	ops1|am_nam 		; $24  BIT dp
00E694  2  10           	.byte	ops1|am_nam 		; $25  AND dp
00E695  2  10           	.byte	ops1|am_nam 		; $26  ROL dp
00E696  2  15           	.byte	ops1|am_indl		; $27  AND [dp]
00E697  2  00           	.byte	ops0|am_nam 		; $28  PLP
00E698  2  91           	.byte	vops|am_imm 		; $29  AND #
00E699  2  00           	.byte	ops0|am_nam 		; $2A  ROL A
00E69A  2  00           	.byte	ops0|am_nam 		; $2B  PLD
00E69B  2  20           	.byte	ops2|am_nam 		; $2C  BIT abs
00E69C  2  20           	.byte	ops2|am_nam 		; $2D  AND abs
00E69D  2  20           	.byte	ops2|am_nam 		; $2E  ROL abs
00E69E  2  30           	.byte	ops3|am_nam 		; $2F  AND absl
00E69F  2               ;
00E69F  2  50           	.byte	bop1|am_nam 		; $30  BMI abs
00E6A0  2  18           	.byte	ops1|am_indy		; $31  AND (<dp>),Y
00E6A1  2  14           	.byte	ops1|am_ind 		; $32  AND (dp)
00E6A2  2  1A           	.byte	ops1|am_stky		; $33  AND (<offset>,S),Y
00E6A3  2  12           	.byte	ops1|am_adrx		; $34  BIT dp,X
00E6A4  2  12           	.byte	ops1|am_adrx		; $35  AND dp,X
00E6A5  2  12           	.byte	ops1|am_adrx		; $36  ROL dp,X
00E6A6  2  16           	.byte	ops1|am_indly 		; $37  AND [dp],Y
00E6A7  2  00           	.byte	ops0|am_nam 		; $38  SEC
00E6A8  2  23           	.byte	ops2|am_adry		; $39  AND abs,Y
00E6A9  2  00           	.byte	ops0|am_nam 		; $3A  DEC A
00E6AA  2  00           	.byte	ops0|am_nam 		; $3B  TSC
00E6AB  2  22           	.byte	ops2|am_adrx		; $3C  BIT abs,X
00E6AC  2  22           	.byte	ops2|am_adrx		; $3D  AND abs,X
00E6AD  2  22           	.byte	ops2|am_adrx		; $3E  ROL abs,X
00E6AE  2  32           	.byte	ops3|am_adrx		; $3F  AND absl,X
00E6AF  2               ;
00E6AF  2  00           	.byte	ops0|am_nam 		; $40  RTI
00E6B0  2  17           	.byte	ops1|am_indx		; $41  EOR (dp,X)
00E6B1  2  00           	.byte	ops0|am_nam 		; $42  WDM
00E6B2  2  19           	.byte	ops1|am_stk 		; $43  EOR <offset>,S
00E6B3  2  2B           	.byte	ops2|am_move		; $44  MVP sb,db
00E6B4  2  10           	.byte	ops1|am_nam 		; $45  EOR dp
00E6B5  2  10           	.byte	ops1|am_nam 		; $46  LSR dp
00E6B6  2  15           	.byte	ops1|am_indl		; $47  EOR [dp]
00E6B7  2  00           	.byte	ops0|am_nam 		; $48  PHA
00E6B8  2  91           	.byte	vops|am_imm 		; $49  EOR #
00E6B9  2  00           	.byte	ops0|am_nam 		; $4A  LSR A
00E6BA  2  00           	.byte	ops0|am_nam 		; $4B  PHK
00E6BB  2  20           	.byte	ops2|am_nam 		; $4C  JMP abs
00E6BC  2  20           	.byte	ops2|am_nam 		; $4D  EOR abs
00E6BD  2  20           	.byte	ops2|am_nam 		; $4E  LSR abs
00E6BE  2  30           	.byte	ops3|am_nam 		; $4F  EOR absl
00E6BF  2               ;
00E6BF  2  50           	.byte	bop1|am_nam 		; $50  BVC abs
00E6C0  2  18           	.byte	ops1|am_indy		; $51  EOR (<dp>),Y
00E6C1  2  14           	.byte	ops1|am_ind 		; $52  EOR (dp)
00E6C2  2  1A           	.byte	ops1|am_stky		; $53  EOR (<offset>,S),Y
00E6C3  2  2B           	.byte	ops2|am_move		; $54  MVN sb,db
00E6C4  2  12           	.byte	ops1|am_adrx		; $55  EOR dp,X
00E6C5  2  12           	.byte	ops1|am_adrx		; $56  LSR dp,X
00E6C6  2  16           	.byte	ops1|am_indly 		; $57  EOR [dp],Y
00E6C7  2  00           	.byte	ops0|am_nam 		; $58  CLI
00E6C8  2  23           	.byte	ops2|am_adry		; $59  EOR abs,Y
00E6C9  2  00           	.byte	ops0|am_nam 		; $5A  PHY
00E6CA  2  00           	.byte	ops0|am_nam 		; $5B  TCD
00E6CB  2  30           	.byte	ops3|am_nam 		; $5C  JML absl
00E6CC  2  22           	.byte	ops2|am_adrx		; $5D  EOR abs,X
00E6CD  2  22           	.byte	ops2|am_adrx		; $5E  LSR abs,X
00E6CE  2  32           	.byte	ops3|am_adrx		; $5F  EOR absl,X
00E6CF  2               ;
00E6CF  2  00           	.byte	ops0|am_nam 		; $60  RTS
00E6D0  2  17           	.byte	ops1|am_indx		; $61  ADC (dp,X)
00E6D1  2  60           	.byte	bop2|am_nam 		; $62  PER
00E6D2  2  19           	.byte	ops1|am_stk 		; $63  ADC <offset>,S
00E6D3  2  10           	.byte	ops1|am_nam 		; $64  STZ dp
00E6D4  2  10           	.byte	ops1|am_nam 		; $65  ADC dp
00E6D5  2  10           	.byte	ops1|am_nam 		; $66  ROR dp
00E6D6  2  15           	.byte	ops1|am_indl		; $67  ADC [dp]
00E6D7  2  00           	.byte	ops0|am_nam 		; $68  PLA
00E6D8  2  91           	.byte	vops|am_imm 		; $69  ADC #
00E6D9  2  00           	.byte	ops0|am_nam 		; $6A  ROR A
00E6DA  2  00           	.byte	ops0|am_nam 		; $6B  RTL
00E6DB  2  24           	.byte	ops2|am_ind 		; $6C  JMP (abs)
00E6DC  2  20           	.byte	ops2|am_nam 		; $6D  ADC abs
00E6DD  2  20           	.byte	ops2|am_nam 		; $6E  ROR abs
00E6DE  2  30           	.byte	ops3|am_nam 		; $6F  ADC absl
00E6DF  2               ;
00E6DF  2  50           	.byte	bop1|am_nam 		; $70  BVS abs
00E6E0  2  18           	.byte	ops1|am_indy		; $71  ADC (<dp>),Y
00E6E1  2  14           	.byte	ops1|am_ind 		; $72  ADC (dp)
00E6E2  2  1A           	.byte	ops1|am_stky		; $73  ADC (<offset>,S),Y
00E6E3  2  12           	.byte	ops1|am_adrx		; $74  STZ dp,X
00E6E4  2  12           	.byte	ops1|am_adrx		; $75  ADC dp,X
00E6E5  2  12           	.byte	ops1|am_adrx		; $76  ROR dp,X
00E6E6  2  16           	.byte	ops1|am_indly 		; $77  ADC [dp],Y
00E6E7  2  00           	.byte	ops0|am_nam 		; $78  SEI
00E6E8  2  23           	.byte	ops2|am_adry		; $79  ADC abs,Y
00E6E9  2  00           	.byte	ops0|am_nam 		; $7A  PLY
00E6EA  2  00           	.byte	ops0|am_nam 		; $7B  TDC
00E6EB  2  27           	.byte	ops2|am_indx		; $7C  JMP (abs,X)
00E6EC  2  22           	.byte	ops2|am_adrx		; $7D  ADC abs,X
00E6ED  2  22           	.byte	ops2|am_adrx		; $7E  ROR abs,X
00E6EE  2  32           	.byte	ops3|am_adrx		; $7F  ADC absl,X
00E6EF  2               ;
00E6EF  2  50           	.byte	bop1|am_nam 		; $80  BRA abs
00E6F0  2  17           	.byte	ops1|am_indx		; $81  STA (dp,X)
00E6F1  2  60           	.byte	bop2|am_nam 		; $82  BRL abs
00E6F2  2  19           	.byte	ops1|am_stk 		; $83  STA <offset>,S
00E6F3  2  10           	.byte	ops1|am_nam 		; $84  STY dp
00E6F4  2  10           	.byte	ops1|am_nam 		; $85  STA dp
00E6F5  2  10           	.byte	ops1|am_nam 		; $86  STX dp
00E6F6  2  15           	.byte	ops1|am_indl		; $87  STA [dp]
00E6F7  2  00           	.byte	ops0|am_nam 		; $88  DEY
00E6F8  2  91           	.byte	vops|am_imm 		; $89  BIT #
00E6F9  2  00           	.byte	ops0|am_nam 		; $8A  TXA
00E6FA  2  00           	.byte	ops0|am_nam 		; $8B  PHB
00E6FB  2  20           	.byte	ops2|am_nam 		; $8C  STY abs
00E6FC  2  20           	.byte	ops2|am_nam 		; $8D  STA abs
00E6FD  2  20           	.byte	ops2|am_nam 		; $8E  STX abs
00E6FE  2  30           	.byte	ops3|am_nam 		; $8F  STA absl
00E6FF  2               ;
00E6FF  2  50           	.byte	bop1|am_nam 		; $90  BCC abs
00E700  2  18           	.byte	ops1|am_indy		; $91  STA (<dp>),Y
00E701  2  14           	.byte	ops1|am_ind 		; $92  STA (dp)
00E702  2  1A           	.byte	ops1|am_stky		; $93  STA (<offset>,S),Y
00E703  2  12           	.byte	ops1|am_adrx		; $94  STY dp,X
00E704  2  12           	.byte	ops1|am_adrx		; $95  STA dp,X
00E705  2  13           	.byte	ops1|am_adry		; $96  STX dp,Y
00E706  2  16           	.byte	ops1|am_indly 		; $97  STA [dp],Y
00E707  2  00           	.byte	ops0|am_nam 		; $98  TYA
00E708  2  23           	.byte	ops2|am_adry		; $99  STA abs,Y
00E709  2  00           	.byte	ops0|am_nam 		; $9A  TXS
00E70A  2  00           	.byte	ops0|am_nam 		; $9B  TXY
00E70B  2  20           	.byte	ops2|am_nam 		; $9C  STZ abs
00E70C  2  22           	.byte	ops2|am_adrx		; $9D  STA abs,X
00E70D  2  22           	.byte	ops2|am_adrx		; $9E  STZ abs,X
00E70E  2  32           	.byte	ops3|am_adrx		; $9F  STA absl,X
00E70F  2               ;
00E70F  2  91           	.byte	vops|am_imm 		; $A0  LDY #
00E710  2  17           	.byte	ops1|am_indx		; $A1  LDA (dp,X)
00E711  2  91           	.byte	vops|am_imm 		; $A2  LDX #
00E712  2  19           	.byte	ops1|am_stk 		; $A3  LDA <offset>,S
00E713  2  10           	.byte	ops1|am_nam 		; $A4  LDY dp
00E714  2  10           	.byte	ops1|am_nam 		; $A5  LDA dp
00E715  2  10           	.byte	ops1|am_nam 		; $A6  LDX dp
00E716  2  15           	.byte	ops1|am_indl		; $A7  LDA [dp]
00E717  2  00           	.byte	ops0|am_nam 		; $A8  TAY
00E718  2  91           	.byte	vops|am_imm 		; $A9  LDA #
00E719  2  00           	.byte	ops0|am_nam 		; $AA  TAX
00E71A  2  00           	.byte	ops0|am_nam 		; $AB  PLB
00E71B  2  20           	.byte	ops2|am_nam 		; $AC  LDY abs
00E71C  2  20           	.byte	ops2|am_nam 		; $AD  LDA abs
00E71D  2  20           	.byte	ops2|am_nam 		; $AE  LDX abs
00E71E  2  30           	.byte	ops3|am_nam 		; $AF  LDA absl
00E71F  2               ;
00E71F  2  50           	.byte	bop1|am_nam 		; $B0  BCS abs
00E720  2  18           	.byte	ops1|am_indy		; $B1  LDA (<dp>),Y
00E721  2  14           	.byte	ops1|am_ind 		; $B2  LDA (dp)
00E722  2  1A           	.byte	ops1|am_stky		; $B3  LDA (<offset>,S),Y
00E723  2  12           	.byte	ops1|am_adrx		; $B4  LDY dp,X
00E724  2  12           	.byte	ops1|am_adrx		; $B5  LDA dp,X
00E725  2  13           	.byte	ops1|am_adry		; $B6  LDX dp,Y
00E726  2  16           	.byte	ops1|am_indly 		; $B7  LDA [dp],Y
00E727  2  00           	.byte	ops0|am_nam 		; $B8  CLV
00E728  2  23           	.byte	ops2|am_adry		; $B9  LDA abs,Y
00E729  2  00           	.byte	ops0|am_nam 		; $BA  TSX
00E72A  2  00           	.byte	ops0|am_nam 		; $BB  TYX
00E72B  2  22           	.byte	ops2|am_adrx		; $BC  LDY abs,X
00E72C  2  22           	.byte	ops2|am_adrx		; $BD  LDA abs,X
00E72D  2  23           	.byte	ops2|am_adry		; $BE  LDX abs,Y
00E72E  2  32           	.byte	ops3|am_adrx		; $BF  LDA absl,X
00E72F  2               ;
00E72F  2  91           	.byte	vops|am_imm 		; $C0  CPY #
00E730  2  17           	.byte	ops1|am_indx		; $C1  CMP (dp,X)
00E731  2  11           	.byte	ops1|am_imm 		; $C2  REP #
00E732  2  19           	.byte	ops1|am_stk 		; $C3  CMP <offset>,S
00E733  2  10           	.byte	ops1|am_nam 		; $C4  CPY dp
00E734  2  10           	.byte	ops1|am_nam 		; $C5  CMP dp
00E735  2  10           	.byte	ops1|am_nam 		; $C6  DEC dp
00E736  2  15           	.byte	ops1|am_indl		; $C7  CMP [dp]
00E737  2  00           	.byte	ops0|am_nam 		; $C8  INY
00E738  2  91           	.byte	vops|am_imm 		; $C9  CMP #
00E739  2  00           	.byte	ops0|am_nam 		; $CA  DEX
00E73A  2  00           	.byte	ops0|am_nam 		; $CB  WAI
00E73B  2  20           	.byte	ops2|am_nam 		; $CC  CPY abs
00E73C  2  20           	.byte	ops2|am_nam 		; $CD  CMP abs
00E73D  2  20           	.byte	ops2|am_nam 		; $CE  DEC abs
00E73E  2  30           	.byte	ops3|am_nam 		; $CF  CMP absl
00E73F  2               ;
00E73F  2  50           	.byte	bop1|am_nam 		; $D0  BNE abs
00E740  2  18           	.byte	ops1|am_indy		; $D1  CMP (<dp>),Y
00E741  2  14           	.byte	ops1|am_ind 		; $D2  CMP (dp)
00E742  2  1A           	.byte	ops1|am_stky		; $D3  CMP (<offset>,S),Y
00E743  2  10           	.byte	ops1|am_nam 		; $D4  PEI dp
00E744  2  12           	.byte	ops1|am_adrx		; $D5  CMP dp,X
00E745  2  12           	.byte	ops1|am_adrx		; $D6  DEC dp,X
00E746  2  16           	.byte	ops1|am_indly 		; $D7  CMP [dp],Y
00E747  2  00           	.byte	ops0|am_nam 		; $D8  CLD
00E748  2  23           	.byte	ops2|am_adry		; $D9  CMP abs,Y
00E749  2  00           	.byte	ops0|am_nam 		; $DA  PHX
00E74A  2  00           	.byte	ops0|am_nam 		; $DB  STP
00E74B  2  25           	.byte	ops2|am_indl		; $DC  JMP [abs]
00E74C  2  22           	.byte	ops2|am_adrx		; $DD  CMP abs,X
00E74D  2  22           	.byte	ops2|am_adrx		; $DE  DEC abs,X
00E74E  2  32           	.byte	ops3|am_adrx		; $DF  CMP absl,X
00E74F  2               ;
00E74F  2  91           	.byte	vops|am_imm 		; $E0  CPX #
00E750  2  17           	.byte	ops1|am_indx		; $E1  SBC (dp,X)
00E751  2  11           	.byte	ops1|am_imm 		; $E2  SEP #
00E752  2  19           	.byte	ops1|am_stk 		; $E3  SBC <offset>,S
00E753  2  10           	.byte	ops1|am_nam 		; $E4  CPX dp
00E754  2  10           	.byte	ops1|am_nam 		; $E5  SBC dp
00E755  2  10           	.byte	ops1|am_nam 		; $E6  INC dp
00E756  2  15           	.byte	ops1|am_indl		; $E7  SBC [dp]
00E757  2  00           	.byte	ops0|am_nam 		; $E8  INX
00E758  2  91           	.byte	vops|am_imm 		; $E9  SBC #
00E759  2  00           	.byte	ops0|am_nam 		; $EA  NOP
00E75A  2  00           	.byte	ops0|am_nam 		; $EB  XBA
00E75B  2  20           	.byte	ops2|am_nam 		; $EC  CPX abs
00E75C  2  20           	.byte	ops2|am_nam 		; $ED  SBC abs
00E75D  2  20           	.byte	ops2|am_nam 		; $EE  INC abs
00E75E  2  30           	.byte	ops3|am_nam 		; $EF  SBC absl
00E75F  2               ;
00E75F  2  50           	.byte	bop1|am_nam 		; $F0  BEQ abs
00E760  2  18           	.byte	ops1|am_indy		; $F1  SBC (<dp>),Y
00E761  2  14           	.byte	ops1|am_ind 		; $F2  SBC (dp)
00E762  2  1A           	.byte	ops1|am_stky		; $F3  SBC (<offset>,S),Y
00E763  2  21           	.byte	ops2|am_imm 		; $F4  PEA #
00E764  2  12           	.byte	ops1|am_adrx		; $F5  SBC dp,X
00E765  2  12           	.byte	ops1|am_adrx		; $F6  INC dp,X
00E766  2  16           	.byte	ops1|am_indly 		; $F7  SBC [dp],Y
00E767  2  00           	.byte	ops0|am_nam 		; $F8  SED
00E768  2  23           	.byte	ops2|am_adry		; $F9  SBC abs,Y
00E769  2  00           	.byte	ops0|am_nam 		; $FA  PLX
00E76A  2  00           	.byte	ops0|am_nam 		; $FB  XCE
00E76B  2  27           	.byte	ops2|am_indx		; $FC  JSR (abs,X)
00E76C  2  22           	.byte	ops2|am_adrx		; $FD  SBC abs,X
00E76D  2  22           	.byte	ops2|am_adrx		; $FE  INC abs,X
00E76E  2  32           	.byte	ops3|am_adrx		; $FF  SBC absl,X
00E76F  2               
00E76F  2               ;------------------------------------------------------------------------------
00E76F  2               ; .X & .Y immediate mode opcodes...
00E76F  2               ;
00E76F  2               ;------------------------------------------------------------------------------
00E76F  2               vopidx:
00E76F  2  E0           	.byte	opc_cpxi        	; CPX #
00E770  2  C0           	.byte	opc_cpyi        	; CPY #
00E771  2  A2           	.byte	opc_ldxi        	; LDX #
00E772  2  A0           	.byte	opc_ldyi        	; LDY #
00E773  2               n_vopidx	= * - vopidx		; # of opcodes
00E773  2               
00E773  2               ;------------------------------------------------------------------------------
00E773  2               ; Addressing Mode Symbology Lookup
00E773  2               ;------------------------------------------------------------------------------
00E773  2               ms_lutab:
00E773  2  8B E7        	.word	ms_nam			; No symbol
00E775  2  95 E7        	.word	ms_imm			; #
00E777  2  8D E7        	.word	ms_addrx		; <addr>, X
00E779  2  91 E7        	.word	ms_addry		; <addr>, Y
00E77B  2  97 E7        	.word	ms_ind			; (<addr>)
00E77D  2  9A E7        	.word	ms_indl			; [<dp>]
00E77F  2  9D E7        	.word	ms_indly		; [<dp>], Y
00E781  2  A2 E7        	.word	ms_indx			; (<addr>, X)
00E783  2  A7 E7        	.word	ms_indy			; (<dp>), Y
00E785  2  AF E7        	.word	ms_stk			; <offset>, S
00E787  2  B3 E7        	.word	ms_stky			; (<offset>, S), Y
00E789  2  8B E7        	.word	ms_nam			; <sbank>, <dbank>
00E78B  2               
00E78B  2               ;------------------------------------------------------------------------------
00E78B  2               ; Addressing Mode Symbology String
00E78B  2               ;------------------------------------------------------------------------------
00E78B  2               ms_nam:
00E78B  2  20 00        	.byte	' ',$00			; No symbol
00E78D  2               ms_addrx:
00E78D  2  20 2C 58 00  	.byte	" ,X", $00		; <addr>, X
00E791  2               ms_addry:
00E791  2  20 2C 59 00  	.byte	" ,Y", $00		; <addr>, Y
00E795  2               ms_imm:
00E795  2  23 00        	.byte	'#', $00		; #
00E797  2               ms_ind:
00E797  2  28 29 00     	.byte	"()", $00		; (<addr>)
00E79A  2               ms_indl:
00E79A  2  5B 5D 00     	.byte	"[]", $00		; [<dp>]
00E79D  2               ms_indly:
00E79D  2  5B 5D 2C 59  	.byte	"[],Y", $00		; [<dp>], Y
00E7A1  2  00           
00E7A2  2               ms_indx:
00E7A2  2  28 2C 58 29  	.byte	"(,X)", $00		; (<addr>, X)
00E7A6  2  00           
00E7A7  2               ms_indy:
00E7A7  2  28 29 2C 59  	.byte	"(),Y", $00		; (<dp>), Y
00E7AB  2  00           
00E7AC  2               ms_move:
00E7AC  2  2C 24 00     	.byte	",$", $00		; <sbank>, <dbank>
00E7AF  2               ms_stk:
00E7AF  2  20 2C 53 00  	.byte	" ,S", $00		; <offset>, S
00E7B3  2               ms_stky:
00E7B3  2  28 2C 53 29  	.byte	"(,S),Y", $00		; (<offset>, S), Y
00E7B7  2  2C 59 00     
00E7BA  2               
00E7BA  2               ;------------------------------------------------------------------------------
00E7BA  2               ; Console Display Control Strings
00E7BA  2               ;------------------------------------------------------------------------------
00E7BA  2               ;dc_bf:
00E7BA  2               ;	.byte	BF			; Enable reverse foreground
00E7BA  2               ;	.byte	$00
00E7BA  2               
00E7BA  2               dc_bs:
00E7BA  2  08           	.byte	BS			; Destructive backspace
00E7BB  2  00           	.byte	$00
00E7BC  2               
00E7BC  2               ;dc_cl:
00E7BC  2               ;	.byte	CEOL			; Clear to End Of Line
00E7BC  2               ;	.byte	$00
00E7BC  2               
00E7BC  2               ;dc_cn:
00E7BC  2               ;	.byte	CN			; Cursor On
00E7BC  2               ;	.byte	$00
00E7BC  2               
00E7BC  2               ;dc_co:
00E7BC  2               ;	.byte	CO			; Cursor Off
00E7BC  2               ;	.byte	$00
00E7BC  2               
00E7BC  2               ;dc_er:
00E7BC  2               ;	.byte	ER			; Enable normal foreground
00E7BC  2               ;	.byte	$00
00E7BC  2               
00E7BC  2               dc_lf:
00E7BC  2  0A           	.byte	LF			; Newline
00E7BD  2  0D           	.byte	CR			; <CR>
00E7BE  2  00           	.byte	$00
00E7BF  2               
00E7BF  2               ;------------------------------------------------------------------------------
00E7BF  2               ; Text Strings
00E7BF  2               ;------------------------------------------------------------------------------
00E7BF  2               mm_brk:
00E7BF  2  07           	.byte	BELL
00E7C0  2  0D 0A        	.byte	CR, LF
00E7C2  2  2A 42 52 4B  	.byte	"*BRK"
00E7C6  2  00           	.byte 	$00
00E7C7  2               
00E7C7  2               mm_entry:
00E7C7  2  0D 0A        	.byte	CR, LF
00E7C9  2  53 75 70 65  	.byte	"Supermon 816 "
00E7CD  2  72 6D 6F 6E  
00E7D1  2  20 38 31 36  
00E7D5  2  20           
00E7D6  2  31 2E 30 2E  	softvers
00E7DA  2  33           
00E7DB  2  0D 0A 28 49  	.byte 	CR, LF, "(Implementation for Adria "
00E7DF  2  6D 70 6C 65  
00E7E3  2  6D 65 6E 74  
00E7E7  2  61 74 69 6F  
00E7EB  2  6E 20 66 6F  
00E7EF  2  72 20 41 64  
00E7F3  2  72 69 61 20  
00E7F7  2  30 2E 31 2E  	bios_version
00E7FB  2  33           
00E7FC  2  29 0D 0A 00  	.byte 	")", CR, LF, $00
00E800  2               
00E800  2               mm_err:
00E800  2  2A 45 52 52  	.byte	"*ERR ", $00
00E804  2  20 00        
00E806  2               
00E806  2               mm_prmpt:
00E806  2  0D 0A        	.byte 	CR, LF
00E808  2  2E           	.byte	'.'
00E809  2  00           	.byte	$00
00E80A  2               
00E80A  2               mm_regs:
00E80A  2  0D 0A        	.byte	CR, LF
00E80C  2  20 20 50 42  	.byte	"  PB  PC   NVmxDIZC  .C   .X   .Y   SP   DP  DB"
00E810  2  20 20 50 43  
00E814  2  20 20 20 4E  
00E818  2  56 6D 78 44  
00E81C  2  49 5A 43 20  
00E820  2  20 2E 43 20  
00E824  2  20 20 2E 58  
00E828  2  20 20 20 2E  
00E82C  2  59 20 20 20  
00E830  2  53 50 20 20  
00E834  2  20 44 50 20  
00E838  2  20 44 42     
00E83B  2  0D 0A        	.byte	CR, LF
00E83D  2  3A 20        	.byte	':', ' '
00E83F  2  00           	.byte	$00
00E840  2               
00E840  2               mm_rts:
00E840  2  07           	.byte	BELL
00E841  2  0D 0A        	.byte	CR, LF
00E843  2  2A 52 54 53  	.byte	"*RTS"
00E847  2  0D 0A        	.byte	CR, LF
00E849  2  00           	.byte	$00
00E84A  2               
00E84A  2               
00E84A  2               mm_hlp:
00E84A  2  0D 0A        	.byte	CR, LF
00E84C  2  53 75 70 65  	.byte	"Supermon 816 "
00E850  2  72 6D 6F 6E  
00E854  2  20 38 31 36  
00E858  2  20           
00E859  2  31 2E 30 2E  	softvers
00E85D  2  33           
00E85E  2  20 48 65 6C  	.byte	" Help",CR, LF
00E862  2  70 0D 0A     
00E865  2  0D 0A        	.byte	CR, LF
00E867  2  41 20 2D 20  	.byte	"A - Assemble code", CR, LF
00E86B  2  41 73 73 65  
00E86F  2  6D 62 6C 65  
00E873  2  20 63 6F 64  
00E877  2  65 0D 0A     
00E87A  2  43 20 2D 20  	.byte	"C - Compare memory ranges", CR, LF
00E87E  2  43 6F 6D 70  
00E882  2  61 72 65 20  
00E886  2  6D 65 6D 6F  
00E88A  2  72 79 20 72  
00E88E  2  61 6E 67 65  
00E892  2  73 0D 0A     
00E895  2  44 20 2D 20  	.byte	"D - Disassemble code", CR, LF
00E899  2  44 69 73 61  
00E89D  2  73 73 65 6D  
00E8A1  2  62 6C 65 20  
00E8A5  2  63 6F 64 65  
00E8A9  2  0D 0A        
00E8AB  2  46 20 2D 20  	.byte	"F - Fill memory", CR, LF
00E8AF  2  46 69 6C 6C  
00E8B3  2  20 6D 65 6D  
00E8B7  2  6F 72 79 0D  
00E8BB  2  0A           
00E8BC  2  47 20 2D 20  	.byte	"G - Execute code (JMP)", CR, LF
00E8C0  2  45 78 65 63  
00E8C4  2  75 74 65 20  
00E8C8  2  63 6F 64 65  
00E8CC  2  20 28 4A 4D  
00E8D0  2  50 29 0D 0A  
00E8D4  2  48 20 2D 20  	.byte	"H - Search memory", CR, LF
00E8D8  2  53 65 61 72  
00E8DC  2  63 68 20 6D  
00E8E0  2  65 6D 6F 72  
00E8E4  2  79 0D 0A     
00E8E7  2  4A 20 2D 20  	.byte	"J - Execute code as subroutine (JSR)", CR, LF
00E8EB  2  45 78 65 63  
00E8EF  2  75 74 65 20  
00E8F3  2  63 6F 64 65  
00E8F7  2  20 61 73 20  
00E8FB  2  73 75 62 72  
00E8FF  2  6F 75 74 69  
00E903  2  6E 65 20 28  
00E907  2  4A 53 52 29  
00E90B  2  0D 0A        
00E90D  2  4C 20 2D 20  	.byte	"L - Load code (Intel Hex)", CR, LF
00E911  2  4C 6F 61 64  
00E915  2  20 63 6F 64  
00E919  2  65 20 28 49  
00E91D  2  6E 74 65 6C  
00E921  2  20 48 65 78  
00E925  2  29 0D 0A     
00E928  2  4D 20 2D 20  	.byte	"M - Dump memory range", CR, LF
00E92C  2  44 75 6D 70  
00E930  2  20 6D 65 6D  
00E934  2  6F 72 79 20  
00E938  2  72 61 6E 67  
00E93C  2  65 0D 0A     
00E93F  2  52 20 2D 20  	.byte	"R - Dump registers", CR, LF
00E943  2  44 75 6D 70  
00E947  2  20 72 65 67  
00E94B  2  69 73 74 65  
00E94F  2  72 73 0D 0A  
00E953  2  54 20 2D 20  	.byte	"T - Copy memory range", CR, LF
00E957  2  43 6F 70 79  
00E95B  2  20 6D 65 6D  
00E95F  2  6F 72 79 20  
00E963  2  72 61 6E 67  
00E967  2  65 0D 0A     
00E96A  2  3E 20 2D 20  	.byte	"> - Change memory", CR, LF
00E96E  2  43 68 61 6E  
00E972  2  67 65 20 6D  
00E976  2  65 6D 6F 72  
00E97A  2  79 0D 0A     
00E97D  2  3B 20 2D 20  	.byte	"; - Change registers", CR, LF
00E981  2  43 68 61 6E  
00E985  2  67 65 20 72  
00E989  2  65 67 69 73  
00E98D  2  74 65 72 73  
00E991  2  0D 0A        
00E993  2  3F 20 2D 20  	.byte	"? - Help (this)", CR, LF
00E997  2  48 65 6C 70  
00E99B  2  20 28 74 68  
00E99F  2  69 73 29 0D  
00E9A3  2  0A           
00E9A4  2  00           	.byte	$00
00E9A5  2               
00E9A5  2               ; Descriptive strings for monitor routines (used with LCD)?
00E9A5  2               ;		 0123456789ABCDEF
00E9A5  2               mm_monce:
00E9A5  2  4D 6F 6E 69  	.asciiz	"Monitor"
00E9A9  2  74 6F 72 00  
00E9AD  2               mm_monerr:
00E9AD  2  2A 2A 45 72  	.asciiz	"**Error"
00E9B1  2  72 6F 72 00  
00E9B5  2               mm_monasc:
00E9B5  2  41 73 73 65  	.asciiz	"Assembler"
00E9B9  2  6D 62 6C 65  
00E9BD  2  72 00        
00E9BF  2               mm_mondsc:
00E9BF  2  44 69 73 61  	.asciiz	"Disassembler"
00E9C3  2  73 73 65 6D  
00E9C7  2  62 6C 65 72  
00E9CB  2  00           
00E9CC  2               mm_monjmp:
00E9CC  2  4A 4D 50 20  	.asciiz	"JMP routine"
00E9D0  2  72 6F 75 74  
00E9D4  2  69 6E 65 00  
00E9D8  2               mm_monjsr:
00E9D8  2  4A 53 52 20  	.asciiz	"JSR routine"
00E9DC  2  72 6F 75 74  
00E9E0  2  69 6E 65 00  
00E9E4  2               mm_monchm:
00E9E4  2  43 68 61 6E  	.asciiz	"Change memory"
00E9E8  2  67 65 20 6D  
00E9EC  2  65 6D 6F 72  
00E9F0  2  79 00        
00E9F2  2               mm_moncmp:
00E9F2  2  43 6F 6D 70  	.asciiz "Compare momory"
00E9F6  2  61 72 65 20  
00E9FA  2  6D 6F 6D 6F  
00E9FE  2  72 79 00     
00EA01  2               mm_moncpy:
00EA01  2  43 6F 70 79  	.asciiz	"Copy memory"
00EA05  2  20 6D 65 6D  
00EA09  2  6F 72 79 00  
00EA0D  2               mm_mondmp:
00EA0D  2  44 75 6D 70  	.asciiz	"Dump memory"
00EA11  2  20 6D 65 6D  
00EA15  2  6F 72 79 00  
00EA19  2               mm_monfil:
00EA19  2  46 69 6C 6C  	.asciiz	"Fill memory"
00EA1D  2  20 6D 65 6D  
00EA21  2  6F 72 79 00  
00EA25  2               mm_monhnt:
00EA25  2  48 75 6E 74  	.asciiz	"Hunt memory"
00EA29  2  20 6D 65 6D  
00EA2D  2  6F 72 79 00  
00EA31  2               
00EA31  2               ;---------------------------------------
00EA31  2               ; Temporary used to determine zeropage (DP) usage
00EA31  2               ; Comment when not needed
00EA31  2               ;---------------------------------------
00EA31  2               ZPUsage:
00EA31  2               ; hexintel
00EA31  2  70           	.byte	DPL
00EA32  2  71           	.byte	DPH
00EA33  2  72           	.byte	RECLEN
00EA34  2  73           	.byte	START_LO
00EA35  2  74           	.byte	START_HI
00EA36  2  75           	.byte	RECTYPE
00EA37  2  76           	.byte	RECCHKSUM
00EA38  2  77           	.byte	DLFAIL
00EA39  2  78           	.byte	TEMP
00EA3A  2               ; Monitor
00EA3A  2  80           	.byte	reg_pbx
00EA3B  2  81           	.byte	reg_pcx
00EA3C  2  83           	.byte	reg_srx
00EA3D  2  84           	.byte	reg_ax
00EA3E  2  86           	.byte	reg_xx
00EA3F  2  88           	.byte	reg_yx
00EA40  2  8A           	.byte	reg_spx
00EA41  2  8C           	.byte	reg_dpx
00EA42  2  8E           	.byte	reg_dbx
00EA43  2  8F           	.byte	addra
00EA44  2  92           	.byte	addrb
00EA45  2  95           	.byte	faca
00EA46  2  99           	.byte	facax
00EA47  2  9D           	.byte	facb
00EA48  2  A3           	.byte	facc
00EA49  2  A9           	.byte	operand
00EA4A  2  AC           	.byte	auxbufindex
00EA4B  2  AD           	.byte	ibufidx
00EA4C  2  AE           	.byte	bitsdig
00EA4D  2  AF           	.byte	numeral
00EA4E  2  B0           	.byte	radix
00EA4F  2  B1           	.byte	admodidx
00EA50  2  B2           	.byte	charcnt
00EA51  2  B4           	.byte	instsize
00EA52  2  B6           	.byte	mnepck
00EA53  2  B8           	.byte	opcode
00EA54  2  B9           	.byte	status
00EA55  2  BA           	.byte	xrtemp
00EA56  2  BB           	.byte	eopsize
00EA57  2  BC           	.byte	flimflag
00EA58  2  BD           	.byte	vecbrkia
00EA59  2  BF           	.byte	iopsize
00EA5A  2  C0           	.byte	range
00EA5B  2  C1           	.byte	vopsflag
00EA5C  2  95           	.byte	mcftwork
00EA5D  2  96           	.byte	mcftopc
00EA5E  2  97           	.byte	mcftbnk
00EA5F  2  00 02        	.word	ibuffer
00EA61  2  46 02        	.word	auxbuf
00EA63  2               ; (g)LCD specific
00EA63  2               ;	.word	dpy_data_buf
00EA63  2               ;	.byte	dpy_data_size
00EA63  2               ;	.word	dpy_data_max
00EA63  2               ;
00EA63  2               ; System wide vectors
00EA63  2  DC 02        	.word	VECTOR_BRK
00EA65  2  D4 02        	.word	VECTOR_NMI
00EA67  2  D8 02        	.word	VECTOR_INT
00EA69  2  D0 02        	.word	VECTOR_RES
00EA6B  2  E2 02        	.word	VECTOR_CHAR_IN
00EA6D  2  E4 02        	.word	VECTOR_CHAR_SCAN
00EA6F  2  E0 02        	.word	VECTOR_CHAR_OUT
00EA71  2               ;---------------------------------------
00EA71  2               ; Used to calculate memory footprint of module
00EA71  2               ;---------------------------------------
00EA71  2               _mon_end = *
00EA71  2               _mon_size = _mon_end - SYSMONITOR
00EA71  2               	.out .concat("Supermon816                       $", .sprintf("%04x", SYSMONITOR), "      $", .sprintf("%04x", _mon_end), "    $", .sprintf("%04x", _mon_size), "  (", .sprintf("%05d", _mon_size), ")")
00EA71  2               ;	.out .concat("-- Size of Monitor:	            $", .sprintf("%04x", _mon_size), " (", .sprintf("%05d", _mon_size), ")")
00EA71  2               
00EA71  2               
00EA71  1               
00EA71  1               ; Interrupt Service Routines
00EA71  1               _incl_isr:
00EA71  1  00 00 00 00  	.res		ISR - *, $00
00EA75  1  00 00 00 00  
00EA79  1  00 00 00 00  
00EA7D  1  00 00 00 00  
00EA81  1  00 00 00 00  
00EA85  1  00 00 00 00  
00EA89  1  00 00 00 00  
00EA8D  1  00 00 00 00  
00EA91  1  00 00 00 00  
00EA95  1  00 00 00 00  
00EA99  1  00 00 00 00  
00EA9D  1  00 00 00 00  
00EAA1  1  00 00 00 00  
00EAA5  1  00 00 00 00  
00EAA9  1  00 00 00 00  
00EAAD  1  00 00 00 00  
00EAB1  1  00 00 00 00  
00EAB5  1  00 00 00 00  
00EAB9  1  00 00 00 00  
00EABD  1  00 00 00 00  
00EAC1  1  00 00 00 00  
00EAC5  1  00 00 00 00  
00EAC9  1  00 00 00 00  
00EACD  1  00 00 00 00  
00EAD1  1  00 00 00 00  
00EAD5  1  00 00 00 00  
00EAD9  1  00 00 00 00  
00EADD  1  00 00 00 00  
00EAE1  1  00 00 00 00  
00EAE5  1  00 00 00 00  
00EAE9  1  00 00 00 00  
00EAED  1  00 00 00 00  
00EAF1  1  00 00 00 00  
00EAF5  1  00 00 00 00  
00EAF9  1  00 00 00 00  
00EAFD  1  00 00 00 00  
00EB01  1  00 00 00 00  
00EB05  1  00 00 00 00  
00EB09  1  00 00 00 00  
00EB0D  1  00 00 00 00  
00EB11  1  00 00 00 00  
00EB15  1  00 00 00 00  
00EB19  1  00 00 00 00  
00EB1D  1  00 00 00 00  
00EB21  1  00 00 00 00  
00EB25  1  00 00 00 00  
00EB29  1  00 00 00 00  
00EB2D  1  00 00 00 00  
00EB31  1  00 00 00 00  
00EB35  1  00 00 00 00  
00EB39  1  00 00 00 00  
00EB3D  1  00 00 00 00  
00EB41  1  00 00 00 00  
00EB45  1  00 00 00 00  
00EB49  1  00 00 00 00  
00EB4D  1  00 00 00 00  
00EB51  1  00 00 00 00  
00EB55  1  00 00 00 00  
00EB59  1  00 00 00 00  
00EB5D  1  00 00 00 00  
00EB61  1  00 00 00 00  
00EB65  1  00 00 00 00  
00EB69  1  00 00 00 00  
00EB6D  1  00 00 00     
00FC00  1               	.include	"ROM/isr.asm"
00FC00  2               ;===============================================================================
00FC00  2               ;   A D R I A   - Interrupt handler(s)
00FC00  2               ;
00FC00  2               ; 	This source file holds the interrupt handler(s)
00FC00  2               ;
00FC00  2               ;	Version history:
00FC00  2               ;		26 jan 2021 	- Inital version
00FC00  2               ;		18 feb 2021 	- Userland driver seems to work, migrating to
00FC00  2               ;				  ROM based driver
00FC00  2               ;				- For now, channel B ISR is INCOMPLETE
00FC00  2               ;		19 feb 2021	- Moved ISR to "generic" ROM space
00FC00  2               ;===============================================================================
00FC00  2               ; irq - Hardware Interrupt Request Service routine
00FC00  2               ;-------------------------------------------------------------------------------
00FC00  2               iirq:
00FC00  2  E2 30        	shortr				; 8 bit registers
00FC02  2               ;
00FC02  2               ; Determine source of IRQ(s). Here we also determine the priority of the IRQ
00FC02  2               
00FC02  2  AD 25 C0     	lda	NX_IOBASE + dr_isr	; Load IRQ register, did UART interrupt?
00FC05  2               ;
00FC05  2               ;
00FC05  2               ; Seems when adding another channel, the branch is taken too long ;) had to
00FC05  2               ; solve it somehow
00FC05  2               ;	beq	nx_irq_end		; Nope
00FC05  2  D0 03        	bne	@save_ISR		; Very short branch
00FC07  2  4C 85 FC     	jmp	iirq_end		; And we use a jump
00FC0A  2               ;
00FC0A  2               @save_ISR:
00FC0A  2  E2 20        	shorta
00FC0C  2  48           	pha				; As per tip from BDD
00FC0D  2               					; (see forum.6502.org) I now push .A
00FC0D  2               					; to the stack before!
00FC0D  2               ;
00FC0D  2               ;-----------------------
00FC0D  2               ;	Contents of stack, which we
00FC0D  2               ;	(might) use in the routine
00FC0D  2               ;-----------------------
00FC0D  2               irq_isrx	= 1			; UART IRQ status
00FC0D  2               irq_yreg	= irq_isrx + s_byte			; 16 bit .Y
00FC0D  2               irq_xreg	= irq_yreg  + s_word	; 16 bit .X
00FC0D  2               irq_areg	= irq_xreg  + s_word	; 16 bit .A
00FC0D  2               irq_dpreg	= irq_areg  + s_word	; DP
00FC0D  2               irq_dbreg	= irq_dpreg + s_mpudpx	; DBR
00FC0D  2               ; pushed by hardware
00FC0D  2               irq_srreg	= irq_dbreg + s_mpudbrx	; SR
00FC0D  2               irq_pcreg	= irq_srreg + s_mpusrx	; PC
00FC0D  2               irq_pbreg	= irq_pcreg + s_mpupcx	; PBR
00FC0D  2               ;
00FC0D  2               ;-----------------------
00FC0D  2               ; Test for C/T IRQ
00FC0D  2               ;-----------------------
00FC0D  2               test_ct:
00FC0D  2               ;
00FC0D  2  89 08        	bit	#msk_irq_ct		; Did C/T interrupt?
00FC0F  2  F0 16        	beq	test_rhr_a		; Nope, skip this section
00FC11  2               ;
00FC11  2               ;-----------------------
00FC11  2               ; Process C/T IRQ
00FC11  2               ;-----------------------
00FC11  2               @handle_ct:
00FC11  2  AE 2F C0     	ldx	NX_IOBASE + dr_cnt_stop	; Reset C/T IRQ
00FC14  2  A6 60        	ldx	nx_jiffycnt		; Get jiffy counter
00FC16  2  CA           	dex				; Decrement by one
00FC17  2  D0 0C        	bne	@upd_jiffy		; Not time, yet, to update uptime
00FC19  2               ;
00FC19  2  C2 20        	longa				; 16 bit .A
00FC1B  2  E6 61        	inc	nx_uptimecnt		; increment uptime LSW
00FC1D  2  D0 02        	bne	@reset_jiffy		; Done with uptime
00FC1F  2               ;
00FC1F  2  E6 63        	inc	nx_uptimecnt + s_word	; Increment uptime MSW
00FC21  2               ;
00FC21  2               @reset_jiffy:
00FC21  2  E2 30        	shortr				; 8 bit .A
00FC23  2  A2 64        	ldx	#hz			; Reset jiffy count
00FC25  2               ;
00FC25  2               @upd_jiffy:
00FC25  2  86 60        	stx	nx_jiffycnt		; Set new jiffy count value
00FC27  2               ;
00FC27  2               ;-----------------------
00FC27  2               ; Test for channel A RHR IRQ
00FC27  2               ;-----------------------
00FC27  2               test_rhr_a:
00FC27  2  E2 30        	shortr
00FC29  2  A3 01        	lda	irq_isrx, S		; Get original ISR from stack
00FC2B  2  89 02        	bit	#msk_irq_rxa		; Did receiver A request?
00FC2D  2  F0 1E        	beq	test_rhr_b		; Nope, check channel B
00FC2F  2               ;-----------------------
00FC2F  2               ; Process channel A RHR IRQ
00FC2F  2               ;
00FC2F  2               ; Enter loop to service RHR. Loop will not break until RHR is empty
00FC2F  2               ;-----------------------
00FC2F  2               @handle_rhr_a:
00FC2F  2  A0 01        	ldy	#msk_sr_rx_rdy		; RHR status mask
00FC31  2               @process_datum:
00FC31  2  98           	tya
00FC32  2  2C 21 C0     	bit	NX_IOBASE + dr_sra	; Do we have anything in our RHR for
00FC35  2  F0 16        	beq	test_rhr_b		; channel A? Nope: go to B
00FC37  2               
00FC37  2  AD 23 C0     	lda	NX_IOBASE + dr_rxfifoa	; YES, read datum from RHR
00FC3A  2  A6 67        	ldx	nx_rx_put_a		; RxD "put" index
00FC3C  2  E8           	inx				; Increment
00FC3D  2  E4 65        	cpx	nx_rx_get_a		; Compare with "get" index
00FC3F  2  F0 F0        	beq	@process_datum		; RxQ is full
00FC41  2               ;-----------------------
00FC41  2               ; If RxQ is full, the datum cannot be processed and is lost, corrupting the
00FC41  2               ; data stream. This should not happen is the frontend gets from RxQ in time
00FC41  2               ;-----------------------
00FC41  2  CA           	dex				; Realign RxD "put" index
00FC42  2  9D 00 20     	sta	nx_rx_qa, X		; Store datum into RxQ
00FC45  2               ;
00FC45  2  8A           	txa
00FC46  2  1A           	inc	a			; Increment RxD "put" index
00FC47  2  29 7F        	and	#buf_idx_mask		; Deal with index wrap
00FC49  2  85 67        	sta	nx_rx_put_a		; Save new "put" index
00FC4B  2               ;
00FC4B  2  80 E4        	bra	@process_datum		; Loop for next
00FC4D  2               test_rhr_b:
00FC4D  2  A3 01        	lda	irq_isrx, S
00FC4F  2               @handle_rhr_b:
00FC4F  2               ;
00FC4F  2               ;-----------------------
00FC4F  2               ; Test for channel A THR IRQ
00FC4F  2               ;-----------------------
00FC4F  2               test_thr_a:
00FC4F  2  A3 01        	lda	irq_isrx, S		; Get ISR from stack
00FC51  2               ;
00FC51  2  89 01        	bit	#msk_irq_txa		; Did Xmitter A request interrupt?
00FC53  2  F0 2B        	beq	test_thr_b		; Nope, try Xmitter B
00FC55  2               ;-----------------------
00FC55  2               ; Process channel A THR IRQ
00FC55  2               ;-----------------------
00FC55  2               @handle_thr_a:
00FC55  2  A6 66        	ldx	nx_tx_get_a		; Get current TxQ "get" index
00FC57  2  A0 04        	ldy	#msk_sr_tx_rdy		; THR status mask
00FC59  2               ;-----------------------
00FC59  2               ; Enter the loop to service the THR interrupt. This loop will continue until
00FC59  2               ; the THR is full or TxQ is empty
00FC59  2               ;-----------------------
00FC59  2               @next_datum:
00FC59  2  E4 68        	cpx	nx_tx_put_a		; Any (new) datums in TxQ?
00FC5B  2  F0 15        	beq	@tx_off			; Nope, shutdown Xmitter and go to B
00FC5D  2               ;
00FC5D  2  98           	tya				; YES ...
00FC5E  2  2C 21 C0     	bit	NX_IOBASE + dr_sra	; Any space left in THR
00FC61  2  F0 1B        	beq	@done			; no, done for now...
00FC63  2               ;-----------------------
00FC63  2               ; If the THR is full, the transmitter IRQ processing is done for now...
00FC63  2               ; Later on, when the THR's level has been reduced, another IRQ will occur and
00FC63  2               ; more datums can be processed
00FC63  2               ;-----------------------
00FC63  2  BD 80 20     	lda	nx_tx_qa, X		; Get datum from queue and ...
00FC66  2  8D 23 C0     	sta	NX_IOBASE + dr_txfifoa	; ... write to THR (FIFO)
00FC69  2  8A           	txa				; Move .X to .A
00FC6A  2  1A           	inc	a			; Increment "get" index
00FC6B  2  29 7F        	and	#buf_idx_mask		; Deal with wrap?
00FC6D  2  AA           	tax				; move .A back to .X
00FC6E  2  86 66        	stx	nx_tx_get_a		; Intermediate save "get" index
00FC70  2  80 E7        	bra	@next_datum		; And process next
00FC72  2               ;
00FC72  2               @tx_off:
00FC72  2  A9 08        	lda	#nx_cr_tx_dis		; Shutdown Xmitter A to suppress ...
00FC74  2  8D 22 C0     	sta	NX_IOBASE + dr_cra	; ... IRQs
00FC77  2  A9 40        	lda	#nx_txa_dis		; Set Xmitter A disabled flag
00FC79  2  0C 2C C0     	tsb	NX_IOBASE + dr_misc	; Do in MISC register!
00FC7C  2  04 6D        	tsb	nx_tx_status		; And in ZP (for debug)
00FC7E  2               ;
00FC7E  2               @done:
00FC7E  2  86 66        	stx	nx_tx_get_a		; Save final TxQ "get" index
00FC80  2               ;
00FC80  2               test_thr_b:
00FC80  2  A3 01        	lda	irq_isrx, S
00FC82  2               @handle_thr_b:
00FC82  2               
00FC82  2               ;
00FC82  2               ;-----------------------
00FC82  2               ; We have reached the end of our IRQ handler
00FC82  2               ;
00FC82  2               ; Clean stack from UART IRQ status
00FC82  2               ;-----------------------
00FC82  2  E2 30        	shortr
00FC84  2  68           	pla				; Clear saved UART IRQ Status & discard
00FC85  2               ;
00FC85  2               iirq_end:
00FC85  2               ;
00FC85  2               ;-----------------------
00FC85  2               ; Clear stack and restore saved registers
00FC85  2               ;-----------------------
00FC85  2  C2 30        	longr				; 16 bit registers to recover
00FC87  2  7A           	ply				; .Y
00FC88  2  FA           	plx				; .X
00FC89  2  68           	pla				; .A
00FC8A  2               ;
00FC8A  2  2B           	pld				; Restore DP
00FC8B  2  AB           	plb				; Restore DBR
00FC8C  2               ;
00FC8C  2               ;-----------------------
00FC8C  2               ;	Contents of stack
00FC8C  2               ; pushed by hardware
00FC8C  2               ;irq_srreg	= 1			; SR
00FC8C  2               ;irq_pcreg	= irq_srreg + s_mpusrx	; PC
00FC8C  2               ;irq_pbreg	= irq_pcreg + s_mpupcx	; PBR
00FC8C  2  40           	rti				; Return from IRQ
00FC8D  2               
00FC8D  2               ;---------------------------------------
00FC8D  2               ; Used to calculate memory footprint of the module
00FC8D  2               ;---------------------------------------
00FC8D  2               ISR_END		= *			; Must be declared before any
00FC8D  2               					; calculations
00FC8D  2               ISR_SIZE	= ISR_END - ISR
00FC8D  2               	.out .concat("Interrupt Service Routine(s)      $", .sprintf("%04x", ISR), "      $", .sprintf("%04x", ISR_END), "    $", .sprintf("%04x", ISR_SIZE), "  (", .sprintf("%05d", ISR_SIZE), ")")
00FC8D  2               ;	.out .concat("---- Size of ISR uploader:                 $", .sprintf("%04x", ISR_SIZE), " (", .sprintf("%5d", ISR_SIZE), ")")
00FC8D  2               
00FC8D  1               
00FC8D  1               ; Fixed jump tables (not functional (yet?)
00FC8D  1               ;_incl_jump:
00FC8D  1               ;	.res		JUMP - *, $00
00FC8D  1               ;	.include	"ROM/jumptable.asm"
00FC8D  1               
00FC8D  1               ; Reset handler(s)
00FC8D  1               _incl_reset:
00FC8D  1  00 00 00 00  	.res		RESET_ROUTINES - *, $00
00FC91  1  00 00 00 00  
00FC95  1  00 00 00 00  
00FC99  1  00 00 00 00  
00FC9D  1  00 00 00 00  
00FCA1  1  00 00 00 00  
00FCA5  1  00 00 00 00  
00FCA9  1  00 00 00 00  
00FCAD  1  00 00 00 00  
00FCB1  1  00 00 00 00  
00FCB5  1  00 00 00 00  
00FCB9  1  00 00 00 00  
00FCBD  1  00 00 00 00  
00FCC1  1  00 00 00 00  
00FCC5  1  00 00 00 00  
00FCC9  1  00 00 00 00  
00FCCD  1  00 00 00 00  
00FCD1  1  00 00 00 00  
00FCD5  1  00 00 00 00  
00FCD9  1  00 00 00 00  
00FCDD  1  00 00 00 00  
00FCE1  1  00 00 00 00  
00FCE5  1  00 00 00 00  
00FCE9  1  00 00 00 00  
00FCED  1  00 00 00 00  
00FCF1  1  00 00 00 00  
00FCF5  1  00 00 00 00  
00FCF9  1  00 00 00 00  
00FCFD  1  00 00 00     
00FD00  1               	.include	"ROM/reset.asm"
00FD00  2               ;
00FD00  2               ; Adria reset routines
00FD00  2               ;
00FD00  2               ; Version history:
00FD00  2               ;	05 Jan 2021	- Initial version
00FD00  2               ;	18 feb 2021	- Added seperate IRQ handlers for emulation and
00FD00  2               ;			  native operation
00FD00  2               ;=======================================================================
00FD00  2               ; Local equates, macros, definitions
00FD00  2               ;---------------------------------------
00FD00  2               	.org	RESET_ROUTINES		; Base address of this module
00FD00  2               
00FD00  2               ;---------------------------------------
00FD00  2               ; Fixed/known jump table(s)
00FD00  2               ;---------------------------------------
00FD00  2               ; Native/24-bit address support
00FD00  2               ;###################
00FD00  2               L_char_out:
00FD00  2  20 0C FD     	jsr	char_out
00FD03  2  6B           	rtl
00FD04  2               
00FD04  2               L_char_in:
00FD04  2  20 10 FD     	jsr	char_in
00FD07  2  6B           	rtl
00FD08  2               
00FD08  2               L_char_scan:
00FD08  2  20 14 FD     	jsr	char_scan
00FD0B  2  6B           	rtl
00FD0C  2               
00FD0C  2               ;###################
00FD0C  2               ; Emulation/16-bit address support
00FD0C  2               ;###################
00FD0C  2               char_out:
00FD0C  2  6C E0 02     	jmp	(VECTOR_CHAR_OUT)
00FD0F  2  60           	rts
00FD10  2               
00FD10  2               char_in:
00FD10  2  6C E2 02     	jmp	(VECTOR_CHAR_IN)
00FD13  2  60           	rts
00FD14  2               
00FD14  2               char_scan:
00FD14  2  6C E4 02     	jmp	(VECTOR_CHAR_SCAN)
00FD17  2  60           	rts
00FD18  2               
00FD18  2               ;---------------------------------------
00FD18  2               ; Reset handler
00FD18  2               ;---------------------------------------
00FD18  2               reset:					; We always start in 8-bit mode
00FD18  2  78           	sei				; Disable interrupts
00FD19  2  D8           	cld				; Clear flags: - decimal
00FD1A  2  18           	clc				;              - carry
00FD1B  2  FB           	xce				; but we want to go to native...
00FD1C  2               					; ... as soon as possible
00FD1C  2               
00FD1C  2  C2 30        	longr				; Set all registers to 16-bit
00FD1E  2               
00FD1E  2  A9 00 01     	lda	#stack			; Load base stack address ...
00FD21  2  1B           	tcs				; ... and copy .C as stack base
00FD22  2               
00FD22  2               ;###################
00FD22  2               ; Each vector has a 2-byte checksum. We are going to check this and
00FD22  2               ; (re)calculate it here
00FD22  2               ;###################
00FD22  2               @set_vector_reset:
00FD22  2  AD D0 02     	lda	VECTOR_RES		; On reset, perform code at
00FD25  2  49 AD DE     	eor	#$DEAD			; label. If checksum is ok,
00FD28  2  CD D2 02     	cmp	CHKSUM_RES		; jump indirect to address.
00FD2B  2  F0 0C        	beq	@set_vector_nmi		;
00FD2D  2  A9 00 D8     	lda	#JMON			; Else jump into monitor
00FD30  2  8D D0 02     	sta	VECTOR_RES
00FD33  2  49 AD DE     	eor	#$DEAD
00FD36  2  8D D2 02     	sta	CHKSUM_RES
00FD39  2               
00FD39  2               @set_vector_nmi:
00FD39  2  AD D4 02     	lda	VECTOR_NMI
00FD3C  2  49 AD DE     	eor	#$DEAD
00FD3F  2  CD D6 02     	cmp	CHKSUM_NMI
00FD42  2  F0 0C        	beq	@set_vector_int
00FD44  2  A9 AF FD     	lda	#return_int
00FD47  2  8D D4 02     	sta	VECTOR_NMI
00FD4A  2  49 AD DE     	eor	#$DEAD
00FD4D  2  8D D6 02     	sta	CHKSUM_NMI
00FD50  2               
00FD50  2               @set_vector_int:
00FD50  2  AD D8 02     	lda	VECTOR_INT
00FD53  2  49 AD DE     	eor	#$DEAD
00FD56  2  CD DA 02     	cmp	CHKSUM_INT
00FD59  2  F0 0C        	beq	@set_vector_brk
00FD5B  2  A9 00 FC     	lda	#iirq
00FD5E  2  8D D8 02     	sta	VECTOR_INT
00FD61  2  49 AD DE     	eor	#$DEAD
00FD64  2  8D DA 02     	sta	CHKSUM_INT
00FD67  2               
00FD67  2               @set_vector_brk:
00FD67  2  AD DC 02     	lda	VECTOR_BRK
00FD6A  2  49 AD DE     	eor	#$DEAD
00FD6D  2  CD DE 02     	cmp	CHKSUM_BRK
00FD70  2  F0 0C        	beq	@set_vector_inout
00FD72  2  A9 AF FD     	lda	#return_int
00FD75  2  8D DC 02     	sta	VECTOR_BRK
00FD78  2  49 AD DE     	eor	#$DEAD
00FD7B  2  8D DE 02     	sta	CHKSUM_BRK
00FD7E  2               
00FD7E  2               ; Set Character I/O vectors
00FD7E  2               @set_vector_inout:
00FD7E  2  A9 5C CD     	lda	#uart_output
00FD81  2  8D E0 02     	sta	VECTOR_CHAR_OUT
00FD84  2               
00FD84  2  A9 00 CD     	lda	#uart_scan
00FD87  2  8D E4 02     	sta	VECTOR_CHAR_SCAN
00FD8A  2               
00FD8A  2  A9 22 CD     	lda	#uart_input
00FD8D  2  8D E2 02     	sta	VECTOR_CHAR_IN
00FD90  2               
00FD90  2               
00FD90  2               @set_vector_done:
00FD90  2  E2 30        	shortr				; Return to 8-bit registers
00FD92  2               
00FD92  2  A9 00        	lda	#$00			; Set DBR to $00
00FD94  2  48           	pha				; So we start in bank $00 ...
00FD95  2  AB           	plb				; ... for sure
00FD96  2               
00FD96  2               ;###################
00FD96  2               ; In the future:
00FD96  2               ;	Test here for which input device (UART or KBD/video) and set
00FD96  2               ; 	corretc vectors ;)
00FD96  2               ;###################
00FD96  2  20 D2 CD     	jsr 	uart_init		; Initialize uart
00FD99  2               
00FD99  2  C2 30        	longr				; And back to 16-bit registers
00FD9B  2  A9 00 00     	lda	#$0000			; Clear registers
00FD9E  2  A8           	tay
00FD9F  2  AA           	tax
00FDA0  2               
00FDA0  2  E2 30        	shortr				; And back again... 8-bit
00FDA2  2               
00FDA2  2  18           	clc				; Make sure carry is cleared
00FDA3  2  D8           	cld				; As should decimal be
00FDA4  2  58           	cli				; And enable interrupts
00FDA5  2               
00FDA5  2               ;###################
00FDA5  2               ; Show BIOS header
00FDA5  2               ;###################
00FDA5  2  F4 09 FE     	pea	bios_init
00FDA8  2  20 D9 DF     	jsr	sprint
00FDAB  2               
00FDAB  2  4C 00 D8     	jmp	JMON
00FDAE  2               
00FDAE  2               KNOWN_RTS:
00FDAE  2  60           	rts
00FDAF  2               ;---------------------------------------
00FDAF  2               ; End of reset handler
00FDAF  2               ;---------------------------------------
00FDAF  2               
00FDAF  2               ;---------------------------------------
00FDAF  2               ; Interrupt handler(s)
00FDAF  2               ;---------------------------------------
00FDAF  2               return_int:
00FDAF  2               
00FDAF  2  40           	rti				; Just a simple (fixed) RTI
00FDB0  2               
00FDB0  2               handler_nmi:
00FDB0  2  6C D4 02     	jmp	(VECTOR_NMI)		; Let the user handle NMI
00FDB3  2               
00FDB3  2               ; Handle IRQ in native 65C816 mode
00FDB3  2               handler_nirq:
00FDB3  2  8B           	phb				; Save current DB
00FDB4  2  0B           	phd				; Save current DP
00FDB5  2  C2 30        	longr				; 16-bit registers
00FDB7  2  48           	pha				; Save .A, .X and .Y
00FDB8  2  DA           	phx
00FDB9  2  5A           	phy
00FDBA  2               ;-----------------------
00FDBA  2               ;	Contents of stack
00FDBA  2               ;
00FDBA  2               ;irq_yreg	= 1			; 16 bit .Y
00FDBA  2               ;irq_xreg	= irq_yreg + s_word	; 16 bit .X
00FDBA  2               ;irq_areg	= irq_xreg + s_word	; 16 bit .A
00FDBA  2               ;irq_dpreg	= irq_areg + s_word	; DP
00FDBA  2               ;irq_dbreg	= irq_dpreg + s_mpudpx	; DBR
00FDBA  2               ; pushed by hardware
00FDBA  2               ;irq_srreg	= irq_dbreg + s_mpudbx	; SR
00FDBA  2               ;irq_pcreg	= irq_srreg + s_mpusrx	; PC
00FDBA  2               ;irq_pbreg	= irq_pcreg + s_mpupcx	; PBR
00FDBA  2               ;-----------------------
00FDBA  2  6C D8 02     	jmp	(VECTOR_INT)		; Jump to (indirect) vector
00FDBD  2               
00FDBD  2               ; Handle IRQ/BRK in 65C02 Emulation mode
00FDBD  2               handler_eirq:
00FDBD  2  E2 30        	shortr
00FDBF  2  DA           	phx				; Save .A and .X
00FDC0  2  48           	pha
00FDC1  2  BA           	tsx				; Get stack pointer
00FDC2  2  BD 03 01     	lda	$0103, x		; Load .P from stack
00FDC5  2  29 10        	and	#%00010000		; Mask BRK flag
00FDC7  2               ;-----------------------
00FDC7  2               ;	Contents of stack
00FDC7  2               ; pushed by ISR
00FDC7  2               ;irq_xreg	= 1			; 16 bit .X
00FDC7  2               ;irq_areg	= irq_xreg + s_byte	; 16 bit .A
00FDC7  2               ; pushed by hardware
00FDC7  2               ;irq_srreg	= irq_dbreg + s_mpudbx	; SR
00FDC7  2               ;irq_pcreg	= irq_srreg + s_mpusrx	; PC
00FDC7  2               ;irq_pbreg	= irq_pcreg + s_mpupcx	; PBR
00FDC7  2               ;-----------------------
00FDC7  2  D0 05        	bne	handler_brk		; Did we have BRK?
00FDC9  2  68           	pla				; Nope, restore .A and .X
00FDCA  2  FA           	plx
00FDCB  2               ;-----------------------
00FDCB  2               ;	Contents of stack
00FDCB  2               ; pushed by ISR
00FDCB  2               ; pushed by hardware
00FDCB  2               ;irq_srreg	= 1		; SR
00FDCB  2               ;irq_pcreg	= irq_srreg + s_mpusrx	; PC
00FDCB  2               ;irq_pbreg	= irq_pcreg + s_mpupcx	; PBR
00FDCB  2               ;-----------------------
00FDCB  2  6C D8 02     	jmp	(VECTOR_INT)		; Let user handle interrupt
00FDCE  2               
00FDCE  2               handler_brk:
00FDCE  2  E2 30        	shortr				; 8-bit registers
00FDD0  2               
00FDD0  2  8B           	phb				; Save .DBR
00FDD1  2  0B           	phd				; Save .DP
00FDD2  2               
00FDD2  2  C2 30        	longr				; 16-bit registers
00FDD4  2  48           	pha				; Save registers (16-bit!)
00FDD5  2  DA           	phx
00FDD6  2  5A           	phy
00FDD7  2               
00FDD7  2  6C DC 02     	jmp	(VECTOR_BRK)		; handle BRK interrupt
00FDDA  2               
00FDDA  2               lowlevel_brq:
00FDDA  2  A0 00 00     	ldy	#$00
00FDDD  2               @next:
00FDDD  2  B9 EA FD     	lda	bios_ll_brk, Y
00FDE0  2  F0 06        	beq	@done
00FDE2  2  20 0C FD     	jsr	char_out
00FDE5  2  C8           	iny
00FDE6  2  80 F5        	bra 	@next
00FDE8  2               @done:
00FDE8  2  80 FE        	bra	@done			; Loop!
00FDEA  2               
00FDEA  2               ;###################
00FDEA  2               ; Main BIOS strings
00FDEA  2               ;###################
00FDEA  2               bios_ll_brk:
00FDEA  2  20 2A 2A 2A  	.byte	" *** LOW LEVEL BIOS BRK *** ", LF, CR, $00
00FDEE  2  20 4C 4F 57  
00FDF2  2  20 4C 45 56  
00FDF6  2  45 4C 20 42  
00FDFA  2  49 4F 53 20  
00FDFE  2  42 52 4B 20  
00FE02  2  2A 2A 2A 20  
00FE06  2  0A 0D 00     
00FE09  2               bios_init:
00FE09  2  20 20 20 20  	.byte	"      A   DDDDD    RRRRR    IIIII   A      ", LF, CR
00FE0D  2  20 20 41 20  
00FE11  2  20 20 44 44  
00FE15  2  44 44 44 20  
00FE19  2  20 20 20 52  
00FE1D  2  52 52 52 52  
00FE21  2  20 20 20 20  
00FE25  2  49 49 49 49  
00FE29  2  49 20 20 20  
00FE2D  2  41 20 20 20  
00FE31  2  20 20 20 0A  
00FE35  2  0D           
00FE36  2  20 20 20 20  	.byte	"     AA   D    D   R    R     I     AA     ", LF, CR
00FE3A  2  20 41 41 20  
00FE3E  2  20 20 44 20  
00FE42  2  20 20 20 44  
00FE46  2  20 20 20 52  
00FE4A  2  20 20 20 20  
00FE4E  2  52 20 20 20  
00FE52  2  20 20 49 20  
00FE56  2  20 20 20 20  
00FE5A  2  41 41 20 20  
00FE5E  2  20 20 20 0A  
00FE62  2  0D           
00FE63  2  20 20 20 20  	.byte	"    A A   D    D   R    R     I     A A    ", LF, CR
00FE67  2  41 20 41 20  
00FE6B  2  20 20 44 20  
00FE6F  2  20 20 20 44  
00FE73  2  20 20 20 52  
00FE77  2  20 20 20 20  
00FE7B  2  52 20 20 20  
00FE7F  2  20 20 49 20  
00FE83  2  20 20 20 20  
00FE87  2  41 20 41 20  
00FE8B  2  20 20 20 0A  
00FE8F  2  0D           
00FE90  2  20 20 20 41  	.byte	"   A  A   D    D   RRRRR      I     A  A   ", LF, CR
00FE94  2  20 20 41 20  
00FE98  2  20 20 44 20  
00FE9C  2  20 20 20 44  
00FEA0  2  20 20 20 52  
00FEA4  2  52 52 52 52  
00FEA8  2  20 20 20 20  
00FEAC  2  20 20 49 20  
00FEB0  2  20 20 20 20  
00FEB4  2  41 20 20 41  
00FEB8  2  20 20 20 0A  
00FEBC  2  0D           
00FEBD  2  20 20 41 41  	.byte	"  AAAAA   D    D   R R        I     AAAAA  ", LF, CR
00FEC1  2  41 41 41 20  
00FEC5  2  20 20 44 20  
00FEC9  2  20 20 20 44  
00FECD  2  20 20 20 52  
00FED1  2  20 52 20 20  
00FED5  2  20 20 20 20  
00FED9  2  20 20 49 20  
00FEDD  2  20 20 20 20  
00FEE1  2  41 41 41 41  
00FEE5  2  41 20 20 0A  
00FEE9  2  0D           
00FEEA  2  20 41 20 20  	.byte	" A    A   D    D   R  R       I     A    A ", LF, CR
00FEEE  2  20 20 41 20  
00FEF2  2  20 20 44 20  
00FEF6  2  20 20 20 44  
00FEFA  2  20 20 20 52  
00FEFE  2  20 20 52 20  
00FF02  2  20 20 20 20  
00FF06  2  20 20 49 20  
00FF0A  2  20 20 20 20  
00FF0E  2  41 20 20 20  
00FF12  2  20 41 20 0A  
00FF16  2  0D           
00FF17  2  41 20 20 20  	.byte	"A     A   DDDDD    R    R   IIIII   A     A", LF, CR
00FF1B  2  20 20 41 20  
00FF1F  2  20 20 44 44  
00FF23  2  44 44 44 20  
00FF27  2  20 20 20 52  
00FF2B  2  20 20 20 20  
00FF2F  2  52 20 20 20  
00FF33  2  49 49 49 49  
00FF37  2  49 20 20 20  
00FF3B  2  41 20 20 20  
00FF3F  2  20 20 41 0A  
00FF43  2  0D           
00FF44  2  0A 0D        	.byte	LF, CR
00FF46  2  0A 0D        	.byte	LF, CR
00FF48  2  56 65 72 73  	.byte	"Version: "
00FF4C  2  69 6F 6E 3A  
00FF50  2  20           
00FF51  2  30 2E 31 2E  	bios_version
00FF55  2  33           
00FF56  2  20 2D 20 58  	.byte	" - Xander Maas, 2021", LF, CR
00FF5A  2  61 6E 64 65  
00FF5E  2  72 20 4D 61  
00FF62  2  61 73 2C 20  
00FF66  2  32 30 32 31  
00FF6A  2  0A 0D        
00FF6C  2  3C 64 65 76  	.byte	"<development version!", LF, CR, LF, CR, $00
00FF70  2  65 6C 6F 70  
00FF74  2  6D 65 6E 74  
00FF78  2  20 76 65 72  
00FF7C  2  73 69 6F 6E  
00FF80  2  21 0A 0D 0A  
00FF84  2  0D 00        
00FF86  2               ;---------------------------------------
00FF86  2               ; Fill to 65816 reset vectors ($FFE0)
00FF86  2               ;---------------------------------------
00FF86  2  00 00 00 00  	.res	$FFD0 - *, $00
00FF8A  2  00 00 00 00  
00FF8E  2  00 00 00 00  
00FF92  2  00 00 00 00  
00FF96  2  00 00 00 00  
00FF9A  2  00 00 00 00  
00FF9E  2  00 00 00 00  
00FFA2  2  00 00 00 00  
00FFA6  2  00 00 00 00  
00FFAA  2  00 00 00 00  
00FFAE  2  00 00 00 00  
00FFB2  2  00 00 00 00  
00FFB6  2  00 00 00 00  
00FFBA  2  00 00 00 00  
00FFBE  2  00 00 00 00  
00FFC2  2  00 00 00 00  
00FFC6  2  00 00 00 00  
00FFCA  2  00 00 00 00  
00FFCE  2  00 00        
00FFD0  2               
00FFD0  2               ;---------------------------------------
00FFD0  2               ; Required reset vectors
00FFD0  2               ;---------------------------------------
00FFD0  2               	.org	$FFE0
00FFE0  2               	.segment	"VECTORS"
00FFE0  2               reset16:
00FFE0  2  18 FD        	.word	reset			; $FFE0 - Reserved
00FFE2  2  18 FD        	.word	reset			; $FFE2 - Reserved
00FFE4  2  18 FD        	.word	reset			; $FFE4 - COP
00FFE6  2  CE FD        	.word	handler_brk		; $FFE6 - BRK
00FFE8  2  18 FD        	.word	reset			; $FFE8 - ABRT
00FFEA  2  B0 FD        	.word	handler_nmi		; $FFEA - NMI
00FFEC  2  18 FD        	.word	reset			; $FFEC - Reset
00FFEE  2  B3 FD        	.word	handler_nirq		; $FFEE - IRQ
00FFF0  2               
00FFF0  2               reset8:
00FFF0  2  18 FD        	.word	reset			; $FFF0 - Reserved
00FFF2  2  18 FD        	.word	reset			; $FFF2 - Reserved
00FFF4  2  18 FD        	.word	reset			; $FFF4 - COP
00FFF6  2  18 FD        	.word	reset			; $FFF6 - Reserved
00FFF8  2  18 FD        	.word	reset			; $FFF8 - ABRT
00FFFA  2  B0 FD        	.word	handler_nmi		; $FFFA - NMI
00FFFC  2  18 FD        	.word	reset			; $FFFC - Reset
00FFFE  2  BD FD        	.word	handler_eirq		; $FFFE - IRQ/BRK
010000  2               
010000  2               ;=======================================================================
010000  2               ; End of routines
010000  2               ; Calculation of usage
010000  2               _reset_end	=	* -1
010000  2               _reset_size 	=	_reset_end - RESET_ROUTINES
010000  2               ;	.out	.concat("---- Size of Reset routines:          $", .sprintf("%04x", _reset_size), "(", .sprintf("%05d", _reset_size), ")")
010000  2               	.out .concat("Reset                             $", .sprintf("%04x", RESET_ROUTINES), "      $", .sprintf("%04x", _reset_end), "    $", .sprintf("%04x", _reset_size), "  (", .sprintf("%05d", _reset_size), ")")
010000  2               ;=======================================================================
010000  2               
010000  1               
010000  1               
